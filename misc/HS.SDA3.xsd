<s:schema xmlns:s="http://www.w3.org/2001/XMLSchema">
<s:complexType name="Container">
    <s:annotation>
        <s:documentation>The container class for the SDA3.&lt;br&gt;
This is intended to be used as an XML container to hold and manipulate&lt;br&gt;
other SDA3 objects. It is NOT intended to be used as an instantiated object&lt;br&gt;
to hold an entire patient record as an in-memory object. API methods are&lt;br&gt;
available to walk the stream and instantiate individual streamlet objects.&lt;br&gt;
Do not use the standard Cach√© XMLImport/Export methods on SDA.  We provide&lt;br&gt;
methods that are orders of magnitude faster, far better in memory use,&lt;br&gt;
support code translations, etc.  See InitializeXMLParse and GetNextSDA&lt;br&gt;
for importing data. Any SDA object can be exported by invoking&lt;br&gt;
ToQuickXMLStream or ToQuickXMLString on it. If you wish to use the&lt;br&gt;
Container for DTL, do it as an XML Vdoc.  When HealthShare is installed, we&lt;br&gt;
import the XML schema into the HSLIB namespace to make it available.  See&lt;br&gt;
methods ExportXMLSchema and ExportXMLSchemaAPI for how to export the XML&lt;br&gt;
schema.
@API.Extensible
@Modifier Availability InterSystems</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="Patient" type="Patient">
            <s:annotation>
                <s:documentation>One patient&lt;br&gt;&lt;br&gt;
HL7:  PID,PD1,EVN,NTE,MRG,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.Patient</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Encounters" type="ArrayOfEncounter">
            <s:annotation>
                <s:documentation>List of encounters for this patient&lt;br&gt;&lt;br&gt;
HL7:  PV1,PV2,PID,MRG,MSH,EVN&lt;br&gt;
VIEWERLIB: see HS.SDA3.Encounter</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Alerts" type="ArrayOfAlert">
            <s:annotation>
                <s:documentation>List of alerts for patient&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.Alert</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AdvanceDirectives" type="ArrayOfAdvanceDirective">
            <s:annotation>
                <s:documentation>List of advance directives for patient&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.AdvanceDirective</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Allergies" type="ArrayOfAllergy">
            <s:annotation>
                <s:documentation>List of allergies that patient has&lt;br&gt;&lt;br&gt;
HL7:  AL1,IAM,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.Allergy</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="IllnessHistories" type="ArrayOfIllnessHistory">
            <s:annotation>
                <s:documentation>List of past history entries&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.IllnessHistory</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SocialHistories" type="ArrayOfSocialHistory">
            <s:annotation>
                <s:documentation>List of social history entries&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.SocialHistory</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FamilyHistories" type="ArrayOfFamilyHistory">
            <s:annotation>
                <s:documentation>List of family history entries&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.FamilyHistory</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Guarantors" type="ArrayOfGuarantor">
            <s:annotation>
                <s:documentation>List of guarantors for this patient - not supported&lt;br&gt;
This property is present for historic reasons only and should not be used.&lt;br&gt;
The Guarantor property on HS.SDA3.Encounter should be used instead.&lt;br&gt;
Attempting to process an SDA into the Streamlet Cache&lt;br&gt;
containing Guarantors in this property will cause them to be rejected with&lt;br&gt;
errors.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Diagnoses" type="ArrayOfDiagnosis">
            <s:annotation>
                <s:documentation>List of diagnoses&lt;br&gt;&lt;br&gt;
HL7:  DG1,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.Diagnosis</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Observations" type="ArrayOfObservation">
            <s:annotation>
                <s:documentation>List of observations made&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Note that the way some properties of Observation are parsed will depend on&lt;br&gt;
the ObservationCompatibilityMode setting of the HL7 Inbound Process&lt;br&gt;
operation of the Edge production. See HS.SDA3.Observation for more info.&lt;br&gt;&lt;br&gt;
HL7:  OBX,NTE&lt;br&gt;
VIEWERLIB: see HS.SDA3.Observation</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationGroups" type="ArrayOfObservationGroup">
            <s:annotation>
                <s:documentation>List of observation groups&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Problems" type="ArrayOfProblem">
            <s:annotation>
                <s:documentation>List of problems&lt;br&gt;&lt;br&gt;
HL7:  PRB,NTE,ROL,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.Problem</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PhysicalExams" type="ArrayOfPhysicalExam">
            <s:annotation>
                <s:documentation>List of physical exams conducted&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.PhysicalExam</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Procedures" type="ArrayOfProcedure">
            <s:annotation>
                <s:documentation>List of procedures&lt;br&gt;&lt;br&gt;
HL7:  PR1,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.Procedure</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Documents" type="ArrayOfDocument">
            <s:annotation>
                <s:documentation>List of documents&lt;br&gt;&lt;br&gt;
HL7:  TXA,OBX,NTE,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.Document</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="LabOrders" type="ArrayOfLabOrder">
            <s:annotation>
                <s:documentation>HL7:  ORC,OBR,NTE,TQ1,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.LabOrder</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RadOrders" type="ArrayOfRadOrder">
            <s:annotation>
                <s:documentation>HL7:  ORC,OBR,NTE,TQ1,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.RadOrder</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OtherOrders" type="ArrayOfOtherOrder">
            <s:annotation>
                <s:documentation>HL7:  ORC,OBR,NTE,TQ1,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.OtherOrder</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Medications" type="ArrayOfMedication">
            <s:annotation>
                <s:documentation>HL7:  ORC,TQ1,RXO,RXE,RXR,RXC,NTE,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.Medication</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Vaccinations" type="ArrayOfVaccination">
            <s:annotation>
                <s:documentation>HL7:  ORC,TQ1,RXA,RXR,MSH&lt;br&gt;
VIEWERLIB: see HS.SDA3.Vaccination</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Appointments" type="ArrayOfAppointment">
            <s:annotation>
                <s:documentation>HL7:  SCH,AIS,AIP,AIL,MSH,TQ1,NTE&lt;br&gt;
VIEWERLIB: see HS.SDA3.Appointment</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Referrals" type="ArrayOfReferral">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ClinicalRelationships" type="ArrayOfClinicalRelationship">
            <s:annotation>
                <s:documentation>This is populated only from the HealthShare Registry, as part of a special&lt;br&gt;
fetch. ClinicalRelationships should not be submitted by a data provider.&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.ClinicalRelationship</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ProgramMemberships" type="ArrayOfProgramMembership">
            <s:annotation>
                <s:documentation>This is populated only from the HealthShare Registry, as part of a special&lt;br&gt;
fetch. ProgramMemberships should not be submitted by a data provider.&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.ProgramMembership</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="MemberEnrollments" type="ArrayOfMemberEnrollment">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="MedicalClaims" type="ArrayOfMedicalClaim">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PharmacyClaims" type="ArrayOfPharmacyClaim">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="MedicalExplanationOfBenefits" type="ArrayOfMedicalExplanationOfBenefit"/>
        <s:element minOccurs="0" name="PharmacyExplanationOfBenefits" type="ArrayOfPharmacyExplanationOfBenefit"/>
        <s:element minOccurs="0" name="CustomObjects" type="ArrayOfCustomObject">
            <s:annotation>
                <s:documentation>For handling custom data that can be stored as streamlets&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.CustomObject</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GenomicsOrders" type="ArrayOfGenomicsOrder">
            <s:annotation>
                <s:documentation>List of Genetics orders, that can contain VCF data in a blob
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CarePlans" type="ArrayOfCarePlan">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="HealthConcerns" type="ArrayOfHealthConcern">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Goals" type="ArrayOfGoal">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SocialDeterminants" type="ArrayOfSocialDeterminant">
            <s:annotation>
                <s:documentation>List of Social Determinants&lt;br&gt;&lt;br&gt;
VIEWERLIB: TBD</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SessionId">
            <s:annotation>
                <s:documentation>Not used&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ControlId">
            <s:annotation>
                <s:documentation>ControlId or message ID (for tracking and debugging)&lt;br&gt;
Assigned by the system&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Action">
            <s:annotation>
                <s:documentation>What action to take for this SDA in the ECR&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The Action parsed to the SDA depends on the value of MSH-9 (Message Type):&lt;br&gt;
ADT_A13 -&gt; CancelDischarge&lt;br&gt;
ADT_A09 -&gt; DeleteEncounter&lt;br&gt;
ADT_A18 -&gt; Merge&lt;br&gt;
ADT_A23 -&gt; DeleteEncounter&lt;br&gt;
ADT_A29 -&gt; DeletePatient&lt;br&gt;
ADT_A30 -&gt; Merge&lt;br&gt;
ADT_A39 -&gt; Merge&lt;br&gt;
ADT_A45 -&gt; Move&lt;br&gt;
ADT_A50 -&gt; Merge&lt;br&gt;
Any other supported type -&gt; AddOrUpdate&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The actions to be taken against the Patient or Encounter will be determined&lt;br&gt;
from the Action and the EventDescription, not just one or the other.&lt;br&gt;
Additionally, the Patient ActionCode may take precedence over Action and&lt;br&gt;
EventDescription. The full logic to determine the Patient action is:&lt;br&gt;
-If Patient ActionCode="R", Patient action is "Replace".&lt;br&gt;
-Else if Patient ActionCode="D", Patient action is "Delete".&lt;br&gt;
-Else if Action="DeletePatient", Patient action is "Delete".&lt;br&gt;
-Else if EventDescription="ADT_A47", Patient action is "ChangeNum".&lt;br&gt;
-Else if EventDescription="ADT_A50", Patient action is null (regular&lt;br&gt;
add/update).&lt;br&gt;
-Else if Action="Merge", Patient action is "Merge".&lt;br&gt;
-Else Patient action is null (regular add/update).&lt;br&gt;&lt;br&gt;
The logic to determine the Encounter action is:&lt;br&gt;
-If Action="DeleteEncounter", Encounter action is "Delete".&lt;br&gt;
-Else if EventDescription="ADT_A50", Encounter action is "ChangeNum".&lt;br&gt;
-Else if EventDescription="ADT_A45", Encounter action is "Move".&lt;br&gt;
-Else if EventDescription="ADT_A13", Encounter action is "CD"&lt;br&gt;
-Else the Encounter action is determined from the Encounter ActionCode.&lt;br&gt;&lt;br&gt;
Note, for instance, that Action="CancelDischarge" actually doesn't do&lt;br&gt;
anything, but rather it is EventDescription="ADT_A13" that cancels a&lt;br&gt;
discharge. "AddOrUpdate" is the default and is the same as Action="".&lt;br&gt;
"CancelAdmit" and "QueryResponse" do nothing and are the same as null or&lt;br&gt;
"AddOrUpdate". On export, Action is always set to "QueryResponse".&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:enumeration value="AddOrUpdate"/>
                    <s:enumeration value="Merge"/>
                    <s:enumeration value="Move"/>
                    <s:enumeration value="DeletePatient"/>
                    <s:enumeration value="DeleteEncounter"/>
                    <s:enumeration value="CancelAdmit"/>
                    <s:enumeration value="CancelDischarge"/>
                    <s:enumeration value="QueryResponse"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EventDescription">
            <s:annotation>
                <s:documentation>A description of the event that precipitated this message.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The actions to be taken against the Patient or Encounter will be determined&lt;br&gt;
from the Action and the EventDescription, not just one or the other.&lt;br&gt;
Additionally, the Patient ActionCode may take precedence over Action and&lt;br&gt;
EventDescription. See the annotation on Action for a full description of&lt;br&gt;
the logic.&lt;br&gt;
In the MPIUpdateManager, if the MPIUpdateFlag (either from the update&lt;br&gt;
request, or, if that is null, the DefaultMPIUpdateMode setting of the&lt;br&gt;
operation) is "ADTOnly", then the update will only be sent to the Registry&lt;br&gt;
on add or if EventDescription starts with "ADT".&lt;br&gt;&lt;br&gt;
HL7:  MSH-9 : MessageType&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="UpdateECRDemographics" type="s:boolean">
            <s:annotation>
                <s:documentation>This property is not used. Rather, the UpdateECRDemographics property of&lt;br&gt;
HS.Message.ECRUpdateRequest is used to determine whether to update Patient&lt;br&gt;
and Encounter streamlets. See ECRUpdateRequest for full documentation.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SendingFacility">
            <s:annotation>
                <s:documentation>The sending facility; the organization which sent the message&lt;br&gt;
Strictly speaking, it may not be the originator of the data, as the&lt;br&gt;
SendingFacility may just be a "relay". But this distinction is not always&lt;br&gt;
followed.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
As Container is not a streamlet, SendingFacility is not stored as part of&lt;br&gt;
any streamlet. However it is stored as part of the internal MRN that&lt;br&gt;
HealthShare stores for every Patient streamlet. The format is:&lt;br&gt;
&lt;pre&gt;
[SendingFacility]^[PatientNumber.Organization.Code]^[PatientNumber.Number]&lt;br&gt;
&lt;/pre&gt;
Where PatientNumber is the first item in HS.SDA3.Patient:PatientNumbers&lt;br&gt;
with NumberType="MRN". Aggregation keys are indexed by MRN and vice versa&lt;br&gt;
in ^HS.SDAStreamletMRN:&lt;br&gt;
&lt;pre&gt;
^HS.SDAStreamletMRN("MRN", [MRN]) = [AggregationKey]&lt;br&gt;
^HS.SDAStreamletMRN("Key", [AggregationKey]) = [MRN]&lt;br&gt;
&lt;/pre&gt;
Patient streamlets are matched on MRN/AggregationKey.&lt;br&gt;
In the EncounterActions method of HS.SDA3.Streamlet.Encounter, if a new&lt;br&gt;
Encounter has no HealthCareFacility, one is defaulted in with Code and&lt;br&gt;
Organization.Code = SendingFacility.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If any HealthCareFacility CodeTableDetail with no Organization is loaded&lt;br&gt;
into the Viewer Cache, an Organization with Code = SendingFacility will be&lt;br&gt;
defaulted in.&lt;br&gt;&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="AdditionalInfo" type="ArrayOfAdditionalInfoItemPairOfAdditionalInfoKeyAdditionalInfoItem">
            <s:annotation>
                <s:documentation>The data contained within AdditionalInfo will not be used or stored in the&lt;br&gt;
Streamlet Cache, however it will be copied to the AddUpdateHubRequest and&lt;br&gt;
sent to the Registry where a pre- and/or post-processor on the Hub MPI&lt;br&gt;
Manager can make use of it.&lt;br&gt;
The support for user-defined "InfoTypes" was removed in 2009.1.2, and keys&lt;br&gt;
starting with "InfoTypes" should no longer be used. (They are used&lt;br&gt;
internally, and will be overwritten).&lt;br&gt;
Example syntax for AdditionalInfo:&lt;br&gt;
&lt;pre&gt;
&amp;lt;AdditionalInfo&amp;gt;&amp;lt;AdditionalInfoItem AdditionalInfoKey="MyData"&amp;gt;ABC&amp;lt;/AdditionalInfoItem&amp;gt;&amp;lt;/AdditionalInfo&amp;gt;
&lt;/pre&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="Patient">
    <s:annotation>
        <s:documentation>Unlike other Streamlet types, the Patient Streamlet class implements its&lt;br&gt;
own Aggregate method, as many of the properties of Patient are aggregated&lt;br&gt;
at the Access Gateway in non-standard ways. If the annotation on a property&lt;br&gt;
below does not include a description of how it is aggregated, then the&lt;br&gt;
aggregation logic is:&lt;br&gt;
-If [the existing property is null] or [the inbound record is the best&lt;br&gt;
record and the inbound property is not null], set the existing property to&lt;br&gt;
the inbound.&lt;br&gt;
-Otherwise the inbound value is not aggregated.&lt;br&gt;
In this context the "best record" refers to the record of the patient's&lt;br&gt;
from the most trusted facility, which is the one with the lowest Tier in&lt;br&gt;
the Facility Registry.&lt;br&gt;&lt;br&gt;
&lt;b&gt;IMPORTANT:&lt;/b&gt;&lt;br&gt;
Because the properties of Patient are aggregated manually, if a property is&lt;br&gt;
added to this class, the Aggregate method of the Patient streamlet class&lt;br&gt;
must be updated to aggregate the new property.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PatientExtension"/>
        <s:element minOccurs="0" name="MPIID">
            <s:annotation>
                <s:documentation>Master Patient Index ID&lt;br&gt;
MPIID is the first property in this class so that it appears early in the&lt;br&gt;
SDA XML and is easy to find during the AG load.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
Though this technically can be stored at the Edge, the value at the Edge&lt;br&gt;
will not contribute to an aggregated record at the Access Gateway. When a&lt;br&gt;
BatchFetchRequest is initiated at the Access Gateway (when a user selects&lt;br&gt;
one or more results on the Patient Search Screen, for example), only the&lt;br&gt;
first MPIID in the list of requests will be stored with the aggregated SDA.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERForeignId)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Name" type="Name">
            <s:annotation>
                <s:documentation>Primary name for this person (e.g. legal name)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PID-5 is a repeating field. Any instance with subfield 7 (Name Type Code)&lt;br&gt;
= "A" is considered an Alias and is parsed as such. The first non-Alias&lt;br&gt;
instance of PID-5 is used as Name.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
When a patient's records are first requested at the Access Gateway, the&lt;br&gt;
aggregated record is created using the demographics from the Patient&lt;br&gt;
Registry, including Name. HealthShare then attempts to merge into this the&lt;br&gt;
Names (including Alias Names) of any record received at the AG. If the&lt;br&gt;
inbound and existing Names match on FamilyName, GivenName, and MiddleName,&lt;br&gt;
then they are considered a match, and the inbound Name will be merged into&lt;br&gt;
the existing one. For PreferredName, FamilyNamePrefix, NamePrefix,&lt;br&gt;
NameSuffix, and ProfessionalSuffix, if the existing value is null, it is&lt;br&gt;
set to the inbound value. If the inbound Name did not match the existing&lt;br&gt;
Name, it is then compared to each of the existing Aliases, matching on&lt;br&gt;
FamilyName, MiddleName, and GivenName. If no match is found, the Name is&lt;br&gt;
inserted into the list of Aliases. Then, if the Clinical Viewer is&lt;br&gt;
installed, the Name will also have its DOB property set from the BirthTime&lt;br&gt;
of the inbound SDA Patient, and its MRN property set from the Number of the&lt;br&gt;
first PatientNumber of the inbound Patient with NumberType="MRN".&lt;br&gt;&lt;br&gt;
HL7:  PID-5 : PatientName&lt;br&gt;&lt;br&gt;
.FamilyName&lt;br&gt;
HL7:  PID-5.1.1 : PatientName.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERName)&lt;br&gt;
.FamilyNamePrefix&lt;br&gt;
HL7:  PID-5.1.2 : PatientName.FamilyName.OwnSurnamePrefix&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERName5)&lt;br&gt;
.GivenName&lt;br&gt;
HL7:  PID-5.2 : PatientName.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERName2)&lt;br&gt;
.MiddleName&lt;br&gt;
HL7:  PID-5.3 : PatientName.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERName3)&lt;br&gt;
.NameSuffix&lt;br&gt;
HL7:  PID-5.4 : PatientName.Suffix&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERName6)&lt;br&gt;
.NamePrefix&lt;br&gt;
HL7:  PID-5.5 : PatientName.Prefix&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERName7)&lt;br&gt;
.ProfessionalSuffix&lt;br&gt;
HL7:  PID-5.14 : PatientName.ProfessionalSuffix&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERName8)&lt;br&gt;
.PreferredName&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERName4)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="BlankNameReason" type="s:string">
            <s:annotation>
                <s:documentation>If Name is null, this is the reason.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If any instance of PID-5.7 is "S" or "U", BlankNameReason will be set to&lt;br&gt;
the value of the last such instance.&lt;br&gt;
From HL7 code table 2.5.1:200 (Name Type):&lt;br&gt;
S - Coded Pseudo-Name to ensure anonymity&lt;br&gt;
U - Unspecified&lt;br&gt;&lt;br&gt;
HL7:  PID-5.7 : PatientName.NameTypeCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="MothersMaidenName" type="s:string">
            <s:annotation>
                <s:documentation>Patient's mother's maiden name&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though PID-6 is a repeating field, only the first non-null instance will be&lt;br&gt;
used.&lt;br&gt;&lt;br&gt;
HL7:  PID-6.1.1 : MothersMaidenName.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERComplement)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="MothersFullName" type="Name">
            <s:annotation>
                <s:documentation>Patient's mother's full name&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though PID-6 is a repeating field, only the first non-null instance will be&lt;br&gt;
used.&lt;br&gt;&lt;br&gt;
HL7:  PID-6 : MothersMaidenName&lt;br&gt;&lt;br&gt;
.FamilyName&lt;br&gt;
HL7:  PID-6.1.1 : MothersMaidenName.FamilyName.Surname&lt;br&gt;
.FamilyNamePrefix&lt;br&gt;
HL7:  PID-6.1.2 : MothersMaidenName.FamilyName.OwnSurnamePrefix&lt;br&gt;
.GivenName&lt;br&gt;
HL7:  PID-6.2 : MothersMaidenName.GivenName&lt;br&gt;
.MiddleName&lt;br&gt;
HL7:  PID-6.3 : MothersMaidenName.SecondandFurtherGivenNames&lt;br&gt;
.NameSuffix&lt;br&gt;
HL7:  PID-6.4 : MothersMaidenName.Suffix&lt;br&gt;
.NamePrefix&lt;br&gt;
HL7:  PID-6.5 : MothersMaidenName.Prefix&lt;br&gt;
.ProfessionalSuffix&lt;br&gt;
HL7:  PID-6.14 : MothersMaidenName.ProfessionalSuffix&lt;br&gt;
.PreferredName&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Aliases" type="ArrayOfName">
            <s:annotation>
                <s:documentation>Aliases (other names)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to every non-null instance of PID-9, HL7ToSDA3 will also parse&lt;br&gt;
every instance of PID-5 with subfield 7 (Name Type Code) = "A" (Alias&lt;br&gt;
Name) as an Alias.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
When a patient's records are first requested at the Access Gateway, the&lt;br&gt;
aggregated record is created using the demographics from the Patient&lt;br&gt;
Registry, including Name. HealthShare then attempts to merge into this the&lt;br&gt;
Names (including Alias Names) of any record received at the AG. If the&lt;br&gt;
inbound and existing Names match on FamilyName, GivenName, and MiddleName,&lt;br&gt;
then they are considered a match, and the inbound Name will be merged into&lt;br&gt;
the existing one. For PreferredName, FamilyNamePrefix, NamePrefix,&lt;br&gt;
NameSuffix, and ProfessionalSuffix, if the existing value is null, it is&lt;br&gt;
set to the inbound value. If the inbound Name did not match the existing&lt;br&gt;
Name, it is then compared to each of the existing Aliases, matching on&lt;br&gt;
FamilyName, MiddleName, and GivenName. If no match is found, the Name is&lt;br&gt;
inserted into the list of Aliases. Then, if the Clinical Viewer is&lt;br&gt;
installed, the Name will also have its DOB property set from the BirthTime&lt;br&gt;
of the inbound SDA Patient, and its MRN property set from the Number of the&lt;br&gt;
first PatientNumber of the inbound Patient with NumberType="MRN".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If FamilyName, GivenName, and MiddleName are all null, an alert will be&lt;br&gt;
logged in the Ensemble Event Log and the Alias will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  PID-5 : PatientName&lt;br&gt;
HL7:  PID-9 : PatientAlias&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(ChildPAPersonSurnameAlias)&lt;br&gt;&lt;br&gt;
.FamilyName&lt;br&gt;
HL7:  PID-5.1.1 : PatientName.FamilyName.Surname&lt;br&gt;
HL7:  PID-9.1.1 : PatientAlias.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.PAPersonSurnameAlias(SURName)&lt;br&gt;
.FamilyNamePrefix&lt;br&gt;
HL7:  PID-5.1.2 : PatientName.FamilyName.OwnSurnamePrefix&lt;br&gt;
HL7:  PID-9.1.2 : PatientAlias.FamilyName.OwnSurnamePrefix&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.GivenName&lt;br&gt;
HL7:  PID-5.2 : PatientName.GivenName&lt;br&gt;
HL7:  PID-9.2 : PatientAlias.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PAPersonSurnameAlias(SURName2)&lt;br&gt;
.MiddleName&lt;br&gt;
HL7:  PID-5.3 : PatientName.SecondandFurtherGivenNames&lt;br&gt;
HL7:  PID-9.3 : PatientAlias.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.PAPersonSurnameAlias(SURName3)&lt;br&gt;
.NameSuffix&lt;br&gt;
HL7:  PID-5.4 : PatientName.Suffix&lt;br&gt;
HL7:  PID-9.4 : PatientAlias.Suffix&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.NamePrefix&lt;br&gt;
HL7:  PID-5.5 : PatientName.Prefix&lt;br&gt;
HL7:  PID-9.5 : PatientAlias.Prefix&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ProfessionalSuffix&lt;br&gt;
HL7:  PID-5.14 : PatientName.ProfessionalSuffix&lt;br&gt;
HL7:  PID-9.14 : PatientAlias.ProfessionalSuffix&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;  
.DOB&lt;br&gt;
Set so that an Alias Name in the Clinical Viewer can be displayed with the&lt;br&gt;
DOB of the patient record from which it originated.&lt;br&gt;
Aggregation cache:&lt;br&gt;
DOB is set at the time an inbound Alias is aggregated into the existing&lt;br&gt;
list of Aliases. It is set to the BirthTime of the inbound SDA Patient.&lt;br&gt;
Note that this is only done if the Clinical Viewer is installed.&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of DOB is stored. (SURDob is date-only.)&lt;br&gt;
VIEWERLIB: User.HS.PAPersonSurnameAlias(SURDob)&lt;br&gt;
.MRN&lt;br&gt;
Set so that an Alias Name in the Clinical Viewer can be displayed with the&lt;br&gt;
MRN of the patient record from which it originated.&lt;br&gt;
Aggregation cache:&lt;br&gt;
MRN is set at the time an inbound Name is aggregated into the existing list&lt;br&gt;
of Alias Names. It is set to the Number of the first PatientNumber of the&lt;br&gt;
inbound Patient SDA with NumberType="MRN". Note that this is only done if&lt;br&gt;
the Clinical Viewer is installed.&lt;br&gt;
VIEWERLIB: User.HS.PAPersonSurnameAlias(SURPatientFromID)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PrimaryLanguage" type="Language">
            <s:annotation>
                <s:documentation>Patient's primary language&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PID-15 is only parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  PID-15 : PrimaryLanguage&lt;br&gt;
SDATableName=Language, ViewerClass=User.HS.PACPreferredLanguage&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERPrefLanguageDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PID-15.1 : PrimaryLanguage.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PACPreferredLanguage(PREFLCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PID-15.2 : PrimaryLanguage.Text&lt;br&gt;
VIEWERLIB: User.HS.PACPreferredLanguage(PREFLDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PID-15.3 : PrimaryLanguage.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OtherLanguages" type="ArrayOfPatientLanguage">
            <s:annotation>
                <s:documentation>List of patient's other languages&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
When an Patient update is received with OtherLanguages, HealthShare will&lt;br&gt;
compare the inbound and existing lists for matches and merge where&lt;br&gt;
possible. Matching is done on:&lt;br&gt;
-PreferredLanguage.Code+Description&lt;br&gt;
-Use&lt;br&gt;
Matching on PreferredLanguage is ALPHAUP collated. Matching on Use is&lt;br&gt;
exact. PreferredLanguage is inbound and existing required for a match. Use&lt;br&gt;
is inbound and existing optional (a null value will not cause the&lt;br&gt;
comparison to not be a match). If a match is found, the inbound&lt;br&gt;
PatientLanguage is merged into the existing (null properties of the&lt;br&gt;
existing will be set to the values of the corresponding inbound&lt;br&gt;
properties). Otherwise the inbound PatientLanguage is inserted into the&lt;br&gt;
existing list.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
The logic to update OtherLanguages in the Aggregation Cache is the same as&lt;br&gt;
for the Streamlet Cache.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the PatientLanguage does not have a PreferredLanguage, an Alert will be&lt;br&gt;
logged in the Ensemble Event Log and the PatientLanguage will not be saved.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(ChildPAPersonLanguage)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Religion" type="Religion">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
PID-17 is only parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  PID-17 : Religion&lt;br&gt;
SDATableName=Religion, ViewerClass=User.HS.CTReligion&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERReligionDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PID-17.1 : Religion.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTReligion(CTRLGCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PID-17.2 : Religion.Text&lt;br&gt;
VIEWERLIB: User.HS.CTReligion(CTRLGDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PID-17.3 : Religion.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="MaritalStatus" type="MaritalStatus">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
PID-16 is only parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  PID-16 : MaritalStatus&lt;br&gt;
SDATableName=MaritalStatus, ViewerClass=User.HS.CTMarital&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERMaritalDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PID-17.1 : MaritalStatus.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTMarital(CTMARCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PID-17.2 : MaritalStatus.Text&lt;br&gt;
VIEWERLIB: User.HS.CTMarital(CTMARDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PID-17.3 : MaritalStatus.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Gender" type="Gender">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though PID-8 is not a coded element type of field, HL7ToSDA3 still only&lt;br&gt;
parses the first piece with respect to the Component Separator. This is&lt;br&gt;
parsed to the to the Gender Code. HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
PAPERSexDR can only be set on the initial load to the Viewer Cache and&lt;br&gt;
therefore must come from the patient's set of best demographics from the&lt;br&gt;
Patient Registry. If these demographics contain no gender, the patient's&lt;br&gt;
gender will appear in the Clinical Viewer as "NS" for "Not Specified".&lt;br&gt;&lt;br&gt;
HL7:  PID-8 : AdministrativeSex&lt;br&gt;
SDATableName=Gender, ViewerClass=User.HS.CTSex&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERSexDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="BirthGender" type="Gender">
            <s:annotation>
                <s:documentation>Birth Gender, as required for meaningful use. 
Consistent with FHIR, we make it an attribute of Patient.
However, this means we lose the effectiveTime of the SocialHistoryObservation.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Race" type="Race">
            <s:annotation>
                <s:documentation>HealthShare now supports multiple races in the Races property.  The single&lt;br&gt;
instance Race property is maintained (as the first Races entry) for&lt;br&gt;
backwards compatibility.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though PID-10 is repeating, only the first instance with subfield 1 or 2&lt;br&gt;
not null will be parsed to Race.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if Race.Code is the&lt;br&gt;
delete instruction (two double quotes), the Description is set to the&lt;br&gt;
delete instruction and the Races property is cleared. Else, if the first&lt;br&gt;
entry in Races has Code = the delete instruction, both Race.Code and&lt;br&gt;
Description are set to the delete instruction, and Races is cleared. Else,&lt;br&gt;
if Races has at least 1 entry, Race is set to a clone of the first entry.&lt;br&gt;
Else, if Race is defined, a clone of it is inserted into Races.&lt;br&gt;
Race and Races are updated in the Streamlet Cache via the OnUpdateSDARace&lt;br&gt;
and OnUpdateSDARaces methods. The OnUpdateSDARace method actually doesn't&lt;br&gt;
do anything, however the OnUpdateSDARaces method can affect Race in several&lt;br&gt;
ways. If the inbound Race.Code is the delete instruction, the existing Race&lt;br&gt;
is set to null and the existing Races is cleared. Else, if the inbound Race&lt;br&gt;
is defined and the inbound Races is not, a clone of the inbound Race is&lt;br&gt;
inserted into the inbound Races. Then, if there is at least one entry in&lt;br&gt;
the inbound Races, the existing Race is set set to a clone of the first&lt;br&gt;
entry in the inbound Races, and the existing Races is cleared and clones of&lt;br&gt;
the entries in the inbound Races inserted.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
In the Aggregate method of the Streamlet class, Race is aggregated into the&lt;br&gt;
patient record like most other properties of Patient: if the existing value&lt;br&gt;
is null or the inbound record is the best record, set the existing value to&lt;br&gt;
the inbound one.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Note that it is the Race property, and not Races or any of its entries,&lt;br&gt;
that is inserted into the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PID-10 : Race&lt;br&gt;
SDATableName=Race, ViewerClass=User.HS.PACIndigStatus&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERIndigStatDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PID-10.1 : Race.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PACIndigStatus(INDSTCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PID-10.2 : Race.Text&lt;br&gt;
VIEWERLIB: User.HS.PACIndigStatus(INDSTDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PID-10.3 : Race.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  PID-10.7 : Race.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Races" type="ArrayOfRace">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Every instance of PID-10 with subfield 1 or 2 not null is parsed to Races.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if Race.Code is the&lt;br&gt;
delete instruction (two double quotes), the Description is set to the&lt;br&gt;
delete instruction and the Races property is cleared. Else, if the first&lt;br&gt;
entry in Races has Code = the delete instruction, both Race.Code and&lt;br&gt;
Description are set to the delete instruction, and Races is cleared. Else,&lt;br&gt;
if Races has at least 1 entry, Race is set to a clone of the first entry.&lt;br&gt;
Else, if Race is defined, a clone of it is inserted into Races.&lt;br&gt;
Race and Races are updated in the Streamlet Cache via the OnUpdateSDARace&lt;br&gt;
and OnUpdateSDARaces methods. The OnUpdateSDARace method actually doesn't&lt;br&gt;
do anything. In OnUpdateSDARaces, if the inbound Race.Code is the delete&lt;br&gt;
instruction, the existing Race is set to null and the existing Races is&lt;br&gt;
cleared. Else, if the inbound Race is defined and the inbound Races is not,&lt;br&gt;
a clone of the inbound Race is inserted into the inbound Races. Then, if&lt;br&gt;
there is at least one entry in the inbound Races, the existing Race is set&lt;br&gt;
to a clone of the first entry in the inbound Races, and the existing Races&lt;br&gt;
is cleared and clones of the entries in the inbound Races inserted.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
In the Aggregate method of the Streamlet class, the inbound Races are&lt;br&gt;
compared to the existing ones, and any inbound Race that does not match an&lt;br&gt;
existing one is inserted into the existing list. Matching is done on Code,&lt;br&gt;
Description, and SDACodingStandard.&lt;br&gt;&lt;br&gt;
HL7:  PID-10 : Race&lt;br&gt;
SDATableName=Race, ViewerClass=User.HS.PACIndigStatus&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PID-10.1 : Race.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PACIndigStatus(INDSTCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PID-10.2 : Race.Text&lt;br&gt;
VIEWERLIB: User.HS.PACIndigStatus(INDSTDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PID-10.3 : Race.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  PID-10.7 : Race.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EthnicGroup" type="EthnicGroup">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though PID-22 is a repeating field, only the first non-null instance will&lt;br&gt;
be parsed, and only if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  PID-22 : EthnicGroup&lt;br&gt;
SDATableName=EthnicGroup, ViewerClass=None&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PID-22.1 : EthnicGroup.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  PID-22.2 : EthnicGroup.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PID-22.3 : EthnicGroup.NameofCodingSystem&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  PID-22.7 : EthnicGroup.CodingSystemVersionID&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SupportContacts" type="ArrayOfSupportContact">
            <s:annotation>
                <s:documentation>List of next of kin/support contacts&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
It is possible for one NK1 segment to be parsed as two SupportContacts.&lt;br&gt;
One is parsed from fields 2 through 9, the other from fields 13, 30, 31,&lt;br&gt;
and 32. See the SupportContact class for more info.&lt;br&gt;&lt;br&gt;
HL7:  NK1&lt;br&gt;
VIEWERLIB: see HS.SDA3.SupportContact</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="BirthTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date and time of birth&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of BirthTime is stored. (PAPERDob is date-only.)&lt;br&gt;&lt;br&gt;
HL7:  PID-7.1 : DateTimeofBirth.Time&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERDob)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="BirthPlace" type="Address">
            <s:annotation>
                <s:documentation>Place of birth&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="BirthOrder" type="Numeric">
            <s:annotation>
                <s:documentation>If the patient was part of a multiple birth, this is an integer indicating&lt;br&gt;
the patient's birth order, unless this is "0", which indicates that the&lt;br&gt;
patient was not part of a multiple birth.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If the first character, case-insensitive, of PID-24 is "N", then BirthOrder&lt;br&gt;
will be parsed as "0", else BirthOrder will be parsed from PID-25.&lt;br&gt;&lt;br&gt;
HL7:  PID-24 : MultipleBirthIndicator&lt;br&gt;
HL7:  PID-25 : BirthOrder&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="IsProtected" type="Boolean">
            <s:annotation>
                <s:documentation>A boolean value indicating whether the patient is protected&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
A value of "Y" in the HL7 will be parsed as 1, "N" will be parsed as 0, the&lt;br&gt;
delete instruction (two double quotes) will be parsed as-is, and any other&lt;br&gt;
value in the HL7 will not be parsed.&lt;br&gt;&lt;br&gt;
HL7:  PD1-12 : ProtectionIndicator&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ProtectedEffectiveDate" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date when protected status went into effect&lt;br&gt;&lt;br&gt;
HL7:  PD1-13 : ProtectionIndicatorEffectiveDate&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DeathTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time of death&lt;br&gt;&lt;br&gt;
HL7:  PID-29.1 : PatientDeathDateandTime.Time&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERDeceasedDate) + User.HS.PAPerson(PAPERDeceasedTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="IsDead" type="Boolean">
            <s:annotation>
                <s:documentation>A boolean value indicating whether the patient is dead&lt;br&gt;
Death time, location, etc. may not be known.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
A value of "Y" in the HL7 will be parsed as 1, "N" will be parsed as 0, the&lt;br&gt;
delete instruction (two double quotes) will be parsed as-is, and any other&lt;br&gt;
value in the HL7 will not be parsed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
A value of 1 in the SDA will be stored as "Y" in the Viewer Cache. No other&lt;br&gt;
value will be stored.&lt;br&gt;&lt;br&gt;
HL7:  PID-30 : PatientDeathIndicator&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERDeceased)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DeathLocation">
            <s:annotation>
                <s:documentation>Where patient died&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERLocationOfDeath)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="255"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="DeathDeclaredBy" type="CareProvider">
            <s:annotation>
                <s:documentation>Care provider who declared patient dead&lt;br&gt;&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERDoctorDeclaredDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Citizenship" type="Citizenship">
            <s:annotation>
                <s:documentation>Country of Citizenship (or Nationality)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though PID-26 is a repeating field, only the first non-null instance is&lt;br&gt;
used, and only if subfield 1 or 2 is not null. If no value is parsed from&lt;br&gt;
PID-26, HL7ToSDA3 will use PID-28, but only if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  PID-26 : Citizenship&lt;br&gt;
HL7:  PID-28 : Nationality&lt;br&gt;
SDATableName=Citizenship, ViewerClass=User.HS.CTNation&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERNationDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PID-26.1 : Citizenship.Identifier&lt;br&gt;
HL7:  PID-28.1 : Nationality.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTNation(CTNATCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PID-26.2 : Citizenship.Text&lt;br&gt;
HL7:  PID-28.2 : Nationality.Text&lt;br&gt;
VIEWERLIB: User.HS.CTNation(CTNATDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PID-26.3 : Citizenship.NameofCodingSystem&lt;br&gt;
HL7:  PID-28.3 : Nationality.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PatientNumbers" type="ArrayOfPatientNumber">
            <s:annotation>
                <s:documentation>List of Patient Numbers&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
HL7ToSDA3 will attempt to parse PatientNumbers from PID-2, -3, -4, -19, and&lt;br&gt;
20 according to the following logic.&lt;br&gt;
PID-2:&lt;br&gt;
Will only be parsed if subfield 1 is not null and subfield 5 is "MR",&lt;br&gt;
"MRN", "PI", or "". Number is parsed from subfield 1. NumberType is parsed&lt;br&gt;
as "MRN". The Organization Code is parsed from subfield 4.1 or, if that is&lt;br&gt;
null, MSH-4.1. HL7ToSDA3 does not set the Organization Description.&lt;br&gt;
ISOAssigningAuthority is parsed from subfield 4.&lt;br&gt;
PID-3:&lt;br&gt;
Every instance of PID-3 will be parsed. Number is parsed from subfield 1.&lt;br&gt;
NumberType is parsed from subfield 5, but is subject to certain mapping&lt;br&gt;
rules. Values of "MRN", "SSN", "DL", "XX", "PPN", "SNC", "NI", "OTH", and&lt;br&gt;
"" will always be parsed as-is. Values of "MR" and "PI" will always be&lt;br&gt;
parsed as "MRN". What is parsed for any other value depends on the value of&lt;br&gt;
the Configuration Registry key&lt;br&gt;
"\General\LegacyPatientIdentifierTypeRestriction". If it is logically&lt;br&gt;
"true" (1, for example), then any other value of PID-3.5 will be parsed as&lt;br&gt;
"OTH". If the registry key is logically "false" or undefined, then the&lt;br&gt;
value will be parsed as-is. The Organization Code of the PatientNumber is&lt;br&gt;
parsed from PID-3.4.1. If that value is null and the parsed NumberType is&lt;br&gt;
"MRN" or "", then MSH-4.1 will be used as the Organization Code. HL7ToSDA3&lt;br&gt;
does not set the Organization Description. ISOAssigningAuthority is parsed&lt;br&gt;
from subfield 4.&lt;br&gt;
PID-4:&lt;br&gt;
Is parsed the same way PID-3 is, though sequentially after PID-3, so&lt;br&gt;
PatientNumbers that come from PID-4 appear after those from PID-3 in the&lt;br&gt;
SDA.&lt;br&gt;
PID-19:&lt;br&gt;
Will only be parsed if it is not null, and if no PatientNumber with&lt;br&gt;
NumberType="SSN" was parsed from PID-3 or -4. In this case, Number is&lt;br&gt;
parsed from PID-19 and NumberType is parsed as "SSN".&lt;br&gt;
PID-20:&lt;br&gt;
Will only be parsed if subfield 1 is not null, and only if no PatientNumber&lt;br&gt;
with NumberType="DL" was parsed from PID-3 or -4. In this case, Number is&lt;br&gt;
parsed from PID-20.1, NumberType is parsed as "DL", and Organization.Code&lt;br&gt;
is parsed from PID-20.2.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
When an existing Patient in the Streamlet Cache is updated, only existing&lt;br&gt;
PatientNumbers with a NumberType that is not in the inbound list are&lt;br&gt;
preserved. Other existing PatientNumbers are replaced in the update.&lt;br&gt;
In the OnValidate method of the Streamlet class, the NumberType of each&lt;br&gt;
PatientNumber is validated. Values of "MRN", "SSN", "DL", "SNC", "NI",&lt;br&gt;
"XX", and "PPN" are always valid. If the value of the Configuration&lt;br&gt;
Registry key "\General\LegacyPatientIdentifierTypeRestriction" is logically&lt;br&gt;
true, then the only other valid NumberType is "OTH". Otherwise, to be&lt;br&gt;
valid, the NumberType must be set up as an Identifier Type in HealthShare&lt;br&gt;
(HealthShare Management &gt; Registry &gt; Other Management &gt; Identifier Types)&lt;br&gt;
and be flagged as active and an additional patient identifier. If the&lt;br&gt;
NumberType is not valid, the PatientNumber will be removed from the list&lt;br&gt;
and an alert logged in the Ensemble Event Log.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
On aggregate, the inbound list of PatientNumbers will be compared to the&lt;br&gt;
existing list, matching on NumberType, Number, and Organization.Code. If a&lt;br&gt;
match is found, the ISOAssigningAuthority of the inbound PatientNumber will&lt;br&gt;
be saved to the existing. If no match is found, the inbound PatientNumber&lt;br&gt;
will be inserted into the existing list.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The Number of the first PatientNumber with NumberType="MRN" will be saved&lt;br&gt;
to PAPerson.PAPMIIPNo and PAPMIOPNo. Likewise with NumberType="SSN" and&lt;br&gt;
PAPerson.PAPMIMedicare, "DL" and PAPERPassportNumber, "SNC" and&lt;br&gt;
PAPMISafetyNetCardNo, and "NI" and PAPERID.&lt;br&gt;&lt;br&gt;
HL7:  PID-2 : PatientID&lt;br&gt;
HL7:  PID-3 : PatientIdentifierList&lt;br&gt;
HL7:  PID-4 : AlternatePatientID&lt;br&gt;
HL7:  PID-19 : SSNNumber&lt;br&gt;
HL7:  PID-20 : DriversLicenseNumberPatient&lt;br&gt;&lt;br&gt;
.Number&lt;br&gt;
HL7:  PID-2.1 : PatientID.IDNumber&lt;br&gt;
HL7:  PID-3.1 : PatientIdentifierList.IDNumber&lt;br&gt;
HL7:  PID-4.1 : AlternatePatientID.IDNumber&lt;br&gt;
HL7:  PID-19 : SSNNumber&lt;br&gt;
HL7:  PID-20.1 : DriversLicenseNumberPatient.LicenseNumber&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPMIIPNo)&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPMIOPNo)&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPMIMedicare)&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERPassportNumber)&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPMISafetyNetCardNo)&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERID)&lt;br&gt;
.NumberType&lt;br&gt;
HL7:  PID-3.5 : PatientIdentifierList.IdentifierTypeCode&lt;br&gt;
HL7:  PID-4.5 : AlternatePatientID.IdentifierTypeCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Organization&lt;br&gt;
HL7:  PID-2.4.1 : PatientID.AssigningAuthority.NamespaceID&lt;br&gt;
HL7:  PID-3.4.1 : PatientIdentifierList.AssigningAuthority.NamespaceID&lt;br&gt;
HL7:  PID-4.4.1 : AlternatePatientID.AssigningAuthority.NamespaceID&lt;br&gt;
HL7:  PID-20.2 : DriversLicenseNumberPatient.IssuingStateProvinceCountry&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
VIEWERLIB: see HS.SDA3.PatientNumber&lt;br&gt;
.ISOAssigningAuthority&lt;br&gt;
HL7:  PID-2.4 : PatientID.AssigningAuthority&lt;br&gt;
HL7:  PID-3.4 : PatientIdentifierList.AssigningAuthority&lt;br&gt;
HL7:  PID-4.4 : AlternatePatientID.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PriorPatientNumbers" type="ArrayOfPatientNumber">
            <s:annotation>
                <s:documentation>If this SDA is for a patient merge or change number or encounter move, then&lt;br&gt;
this property contains the PatientNumbers for the victim or source patient&lt;br&gt;
record.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Each instance of MRG-1 with subfield 4 not null will be parsed.&lt;br&gt;&lt;br&gt;
Steamlet cache:&lt;br&gt;
PriorPatientNumbers is not saved to the Streamlet Cache. However, the first&lt;br&gt;
entry in it with NumberType="MRN" will be appended to the InactiveMRNs&lt;br&gt;
property as "[SendingFacility]^[AssigningAuthority]^[Number]".&lt;br&gt;&lt;br&gt;
HL7:  MRG-1 : PriorPatientIdentifierList&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Number&lt;br&gt;
HL7:  MRG-1.1 : PriorPatientIdentifierList.IDNumber&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Organization&lt;br&gt;
The Assigning Authority for the number&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MRG-1.4.1 is parsed into the Organization Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
HL7:  MRG-1.4.1 : PriorPatientIdentifierList.AssigningAuthority.NamespaceID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.NumberType&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The source for NumberType is MRG-1.5, subject to certain mapping rules.&lt;br&gt;
Values of "MRN", "SSN", "DL", "XX", "PPN", "SNC", "NI", "OTH", and "" will&lt;br&gt;
always be parsed as-is. Values of "MR" and "PI" will always be parsed as&lt;br&gt;
"MRN". What is parsed for any other value depends on the value of the&lt;br&gt;
Configuration Registry key&lt;br&gt;
"\General\LegacyPatientIdentifierTypeRestriction". If it is logically&lt;br&gt;
"true" (1, for example), then any other value of MRG-1.5 will be parsed as&lt;br&gt;
"OTH". If the registry key is logically "false" or undefined, then the&lt;br&gt;
value will be parsed as-is.&lt;br&gt;
HL7:  MRG-1.5 : PriorPatientIdentifierList.IdentifierTypeCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Addresses" type="ArrayOfAddress">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Every non-null instance of PID-11 will be parsed.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
The inbound list of Addresses is compared to the existing, matching on&lt;br&gt;
Street, City.Code, State.Code, and Zip.Code. If a match is found, the&lt;br&gt;
FromTime, ToTime, Country, and County of the inbound Address will update the&lt;br&gt;
properties of the existing. Otherwise, the inbound Address is inserted into&lt;br&gt;
the existing list.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The first Address in the list is loaded into the properties of PAPerson.&lt;br&gt;
Every Address in the list, including the first, is loaded into the Viewer&lt;br&gt;
Cache as a PATempAddress.&lt;br&gt;&lt;br&gt;
HL7:  PID-11 : PatientAddress&lt;br&gt;&lt;br&gt;
.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Subfield 2, if not null, is concatenated to subfield 1.1 as: "[1.1]; [2]".&lt;br&gt;
Viewer cache:&lt;br&gt;
PAPERStName can only be set during the initial load to the Viewer Cache.&lt;br&gt;
HL7:  PID-11.1.1 : PatientAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  PID-11.2 : PatientAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERStName)&lt;br&gt;
VIEWERLIB: User.HS.PATempAddress(ADDRStreet)&lt;br&gt;
.City&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PID-11.3 is parsed to the City Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;
Viewer cache:&lt;br&gt;
PAPERCityCodeDR can only be set during the initial load to the Viewer&lt;br&gt;
Cache.&lt;br&gt;
HL7:  PID-11.3 : PatientAddress.City&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERCityCodeDR)&lt;br&gt;
VIEWERLIB: User.HS.PATempAddress(ADDRCityDR)&lt;br&gt;
.State&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PID-11.4 is parsed to the State Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;
Viewer cache:&lt;br&gt;
PAPERCTProvinceDR can only be set during the initial load to the Viewer&lt;br&gt;
Cache.&lt;br&gt;
HL7:  PID-11.4 : PatientAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERCTProvinceDR)&lt;br&gt;
VIEWERLIB: User.HS.PATempAddress(ADDRProvinceDR)&lt;br&gt;
.Zip&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PID-11.5 is parsed to the Zip Code. HL7ToSDA3 does not set the Description.&lt;br&gt;
Viewer cache:&lt;br&gt;
PAPERZipDR can only be set during the initial load to the Viewer Cache.&lt;br&gt;
HL7:  PID-11.5 : PatientAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERZipDR)&lt;br&gt;
VIEWERLIB: User.HS.PATempAddress(ADDRZipDR)&lt;br&gt;
.Country&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PID-11.6 is parsed to the Country Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;
Viewer cache:&lt;br&gt;
PAPERCountryDR can only be set if it is null.&lt;br&gt;
HL7:  PID-11.6 : PatientAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERCountryBirthDR)&lt;br&gt;
VIEWERLIB: User.HS.PATempAddress(ADDRCountryDR)&lt;br&gt;
.County&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PID-11.9 is parsed to the County Code.  HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;
Viewer cache:&lt;br&gt;
Not Stored.&lt;br&gt;
.FromTime&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part is stored in the Viewer Cache. (PAPEREffDateCurrAddress&lt;br&gt;
and ADDRDateFrom are both date-only.)&lt;br&gt;
If, during the initial load, the first Address in the list has no FromTime,&lt;br&gt;
PAPEREffDateCurrAddress is set to the date part of Patient.EnteredOn.&lt;br&gt;
HL7:  PID-11.13.1 : PatientAddress.EffectiveDate.Time&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPEREffDateCurrAddress)&lt;br&gt;
VIEWERLIB: User.HS.PATempAddress(ADDRDateFrom)&lt;br&gt;
.ToTime&lt;br&gt;
Viewer cache:&lt;br&gt;
Not stored for the first (current) Address.&lt;br&gt;
HL7:  PID-11.14.1 : PatientAddress.ExpirationDate.Time&lt;br&gt;
VIEWERLIB: User.HS.PATempAddress(ADDRDateTo)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactInfo" type="ContactInfo">
            <s:annotation>
                <s:documentation>Contact information for the Patient&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For each instance of PID-13 and -14, the algorithm to parse a phone number&lt;br&gt;
out of that field is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else continue to the next instance of this field.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the Streamlet Cache, an update to existing ContactInfo updates each&lt;br&gt;
property individually, rather than simply overwriting the existing&lt;br&gt;
ContactInfo object.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
Similar to the Streamlet Cache, in the Aggregation Cache each property of&lt;br&gt;
ContactInfo is updated individually.&lt;br&gt;&lt;br&gt;
HL7:  PID-13 : PhoneNumberHome&lt;br&gt;
HL7:  PID-14 : PhoneNumberBusiness&lt;br&gt;&lt;br&gt;
.HomePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
HomePhoneNumber is parsed from the first instance of PID-13 with subfield 2&lt;br&gt;
in ["",PRN,ORN,VHN,ASN,EMR], and subfield 3 in ["",PH], and from which a&lt;br&gt;
number can be parsed using the above algorithm.&lt;br&gt;
HL7:  PID-13 : PhoneNumberHome&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERTelH)&lt;br&gt;
.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
WorkPhoneNumber is parsed from the first instance of PID-14 with subfield 2&lt;br&gt;
in ["",WPN,ASN,EMR], and subfield 3 in ["",PH], and from a number can be&lt;br&gt;
parsed using the above algorithm.&lt;br&gt;
HL7:  PID-14 : PhoneNumberBusiness&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERTelO)&lt;br&gt;
.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MobilePhoneNumber is parsed from the first instance of PID-13 with subfield&lt;br&gt;
2="BPN" or subfield 3 in [CP,BP], and from which a number can be parsed&lt;br&gt;
using the above algorithm. If no MobilePhoneNumber can be parsed from,&lt;br&gt;
PID-13, HL7ToSDA3 attempts to parse one from PID-14 matching the same&lt;br&gt;
conditions.&lt;br&gt;
HL7:  PID-13 : PhoneNumberHome&lt;br&gt;
HL7:  PID-14 : PhoneNumberBusiness&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERMobPhone)&lt;br&gt;
.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
EmailAddress is parsed from the first non-null instance of PID-13.4, or, if&lt;br&gt;
no EmailAddress can be parsed from that field, from the first non-null&lt;br&gt;
instance of PID-14.4.&lt;br&gt;
HL7:  PID-13.4 : PhoneNumberHome.EmailAddress&lt;br&gt;
HL7:  PID-14.4 : PhoneNumberBusiness.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPEREmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FamilyDoctor" type="FamilyDoctor">
            <s:annotation>
                <s:documentation>Patient's family doctor&lt;br&gt;
Also known as GeneralPractitioner(GP), PrimaryCareProvider&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though PD1-4 is a repeating field, HL7ToSDA3 will only parse the first&lt;br&gt;
non-null instance.&lt;br&gt;&lt;br&gt;
HL7:  PD1-4 : PatientPrimaryCareProvider&lt;br&gt;
SDATableName=FamilyDoctor, ViewerClass=User.HS.PACRefDoctor&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERFamilyDoctorDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PD1-4.1 : PatientPrimaryCareProvider.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Description is composed of the given and family names concatenated together&lt;br&gt;
as: "[FamilyName], [GivenName]".&lt;br&gt;
HL7:  PD1-4.2.1 : PatientPrimaryCareProvider.FamilyName.Surname&lt;br&gt;
HL7:  PD1-4.3 : PatientPrimaryCareProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PD1-4.9 : PatientPrimaryCareProvider.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  PD1-4.2.1 : PatientPrimaryCareProvider.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDFamilyName)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  PD1-4.3 : PatientPrimaryCareProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDForename)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  PD1-4.4 : PatientPrimaryCareProvider.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDMiddleName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  PD1-4.6 : PatientPrimaryCareProvider.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  PD1-4.7 : PatientPrimaryCareProvider.NameSuffix&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="InactiveMRNs">
            <s:annotation>
                <s:documentation>A comma-delimited list of a patient's inactive (victim) MRNs.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For a patient merge or change number, the InactiveMRNs value from the&lt;br&gt;
victim record is copied to the survivor record, and the MRN of the victim&lt;br&gt;
record is added to it. For a regular update, the inbound property will be&lt;br&gt;
concatenated to the existing.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
In the Aggregation Cache, the inbound property is simply concatenated to&lt;br&gt;
existing property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERRemark)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="1000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Occupation" type="Occupation">
            <s:annotation>
                <s:documentation>The patient's occupation&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PublicityCode" type="PublicityCode">
            <s:annotation>
                <s:documentation>What level of publicity is allowed for this visit (Family only, No&lt;br&gt;
publicity, etc.)&lt;br&gt;
In the context of immunization messages, this refers to how a person wishes&lt;br&gt;
to be contacted in a reminder or recall situation.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PD1-11 will only be parsed if subfield 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  PD1-11 : PublicityCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PD1-11.1 : PublicityCode.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  PD1-11.2 : PublicityCode.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PD1-11.3 : PublicityCode.NameofCodingSystem</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PublicityEffectiveDate" type="TimeStamp">
            <s:annotation>
                <s:documentation>When the PublicityCode went into effect&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PD1-18 will only be parsed if PD1-11.2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  PD1-18 : PublicityCodeEffectiveDate&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments">
            <s:annotation>
                <s:documentation>Comments on the Patient&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Currently the only message type supported by HealthShare with NTE segments&lt;br&gt;
that will be parsed as Patient Comments is ORU_R01.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="999"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ImmunizationRegistryStatus" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  PD1-16 : ImmunizationRegistryStatus&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ImmunizationRegistryStatusEffectiveDate" type="TimeStamp">
            <s:annotation>
                <s:documentation>The effective date for ImmunizationRegistryStatus&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PD1-17 will only be parsed if PD1-16 is not null.&lt;br&gt;&lt;br&gt;
HL7: PD1-17 : ImmunizationRegistryStatusEffectiveDate&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CommunicationPreference">
            <s:annotation>
                <s:documentation>The patient's communication preference&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:enumeration value="Email"/>
                    <s:enumeration value="Phone"/>
                    <s:enumeration value="Mail"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Providers" type="ArrayOfDocumentProvider">
            <s:annotation>
                <s:documentation>Used by care community</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Organizations" type="ArrayOfDocumentOrganization">
            <s:annotation>
                <s:documentation>Used by care community</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though EVN-5 is a repeating field, only the first non-null instance will be&lt;br&gt;
used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the SDA contains no&lt;br&gt;
CreatedBy, it will be defaulted to EnteredBy.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
In the Aggregation cache, EnteredBy can only be populated from the best&lt;br&gt;
(most trusted) record.&lt;br&gt;&lt;br&gt;
HL7:  EVN-5 : OperatorID&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERUserUpdate)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  EVN-5.1 : OperatorID.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Description is composed of the given and family names concatenated together&lt;br&gt;
as: "[FamilyName], [GivenName]".&lt;br&gt;
HL7:  EVN-5.2.1 : OperatorID.FamilyName.Surname&lt;br&gt;
HL7:  EVN-5.3 : OperatorID.GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  EVN-5.9 : OperatorID.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CreatedBy" type="User">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the SDA contains no&lt;br&gt;
CreatedBy, it will be defaulted to EnteredBy.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
In the Aggregation cache, CreatedBy can only be populated from the best&lt;br&gt;
(most trusted) record.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
PID-34.1 will be parsed to the EnteredAt Code if not null, else MSH-4.1&lt;br&gt;
will be. In either case, HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
The EnteredAt Code will always be set to the facility code of the best&lt;br&gt;
(most trusted) facility that a request goes out to. If the Access Manager&lt;br&gt;
has an InboundCodeSystemProfile specified, and that profile specifies an&lt;br&gt;
SDACodingStandard for Organization, then that value will be used. If the&lt;br&gt;
SDACodingStandard is filled in and there is a Description in the Code&lt;br&gt;
Registry for that Code and SDACodingStandard, that Description will be&lt;br&gt;
used.&lt;br&gt;&lt;br&gt;
HL7:  PID-34 : LastUpdateFacility&lt;br&gt;
HL7:  MSH-4 : SendingFacility&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERLastUpdateHospitalDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PID-34.1 : LastUpdateFacility.NamespaceID&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if EnteredOn is null, it&lt;br&gt;
will be defaulted to the current date and time. Then, if CreatedOn is null,&lt;br&gt;
it will be defaulted to EnteredOn.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
In the Aggregation cache, EnteredOn can only be populated from the best&lt;br&gt;
(most trusted) record.&lt;br&gt;&lt;br&gt;
HL7:  PID-33.1 : LastUpdateDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.PAPerson(PAPERUpdateDate) + User.HS.PAPerson(PAPERUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CreatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if CreatedOn is null, it&lt;br&gt;
is defaulted to EnteredOn, which may have been defaulted to the current&lt;br&gt;
date and time.&lt;br&gt;&lt;br&gt;
Aggregation cache:&lt;br&gt;
In the Aggregation cache, CreatedOn can only be populated from the best&lt;br&gt;
(most trusted) record.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>For every other streamlet type, this property is used as a tiebreaker when&lt;br&gt;
aggregating records from the same tier facility at the Access Gateway. (See&lt;br&gt;
the annotation on the superclass property for more info.) And while this&lt;br&gt;
property is still set for Patient (by virtue of the Patient streamlet being&lt;br&gt;
saved via HS.SDA3.Streamlet.Abstract:SaveStreamlet), it is not used during&lt;br&gt;
the aggregation of Patient streamlets. The HS.SDA3.Streamlet.Patient class&lt;br&gt;
implements its own Aggregate method that does not use this property. In&lt;br&gt;
time the Patient:Aggregate method will incorporate facility tier and how&lt;br&gt;
recent the record is into its logic, but for right now we are simply&lt;br&gt;
documenting that this property is not used the way it is for other classes.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete, along with all associated streamlets&lt;br&gt;
R = Replace (First delete existing Patient and all associated streamlets,&lt;br&gt;
then insert given Patient)&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
For both "D" and "R", the existing Patient is selected via the inbound&lt;br&gt;
Container SendingFacility and the Organization Code and Number of the first&lt;br&gt;
inbound PatientNumber with NumberType="MRN".&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfNVPair">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="NVPair" nillable="true" type="NVPair"/>
    </s:sequence>
</s:complexType>
<s:complexType name="NVPair">
    <s:annotation>
        <s:documentation>Generic name-value pair object for inclusion in SDA3 objects&lt;br&gt;
NVPair appears in the SDA as a list property (CustomPairs) of every class&lt;br&gt;
that extends HS.SDA3.SuperClass. For every SDA3 class corresponding to a&lt;br&gt;
streamlet type except CustomObject, the CustomPairs are loaded into the&lt;br&gt;
Viewer Cache as web.SDA3.NVPairs. See HS.SDA3.SuperClass:CustomPairs for&lt;br&gt;
more info. See HS.SDA3.CustomObject:CustomPairs for information on how&lt;br&gt;
CustomObject CustomPairs get loaded into the Viewer Cache. For SDA3 classes&lt;br&gt;
that extend SuperClass but do not correspond to streamlet types,&lt;br&gt;
CustomPairs is not loaded into the Viewer Cache, with one exception:&lt;br&gt;
HS.SDA3.SupportContact. Though not a streamlet type, SupportContacts of a&lt;br&gt;
Patient are inserted into the Viewer Cache as NVPairs with InfoType="NOK".</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="Name" type="s:string">
                    <s:annotation>
                        <s:documentation>The name of the property this NVPair represents&lt;br&gt;
Ex: "Status"</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Value" type="s:string">
                    <s:annotation>
                        <s:documentation>The value of the property this NVPair represents&lt;br&gt;
Ex: "Active"</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="DataType">
    <s:annotation>
        <s:documentation>Base for serial (embedded) SDA objects</s:documentation>
    </s:annotation>
</s:complexType>
<s:complexType name="PatientExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Name">
    <s:annotation>
        <s:documentation>This class holds an extended name, data structure XPN in HL7v2&lt;br&gt;
For example: "Dr. Adam A. J. van Everyman III PhD,VC"&lt;br&gt;
XPN: |Everyman&amp;van^Adam^A. J.^III^Dr.^^^^^^^^^PHD,VC|&lt;br&gt;
FamilyName: Everyman&lt;br&gt;
FamilyNamePrefix: van&lt;br&gt;
NamePrefix: Dr.&lt;br&gt;
NameSuffix: III&lt;br&gt;
GivenName: Adam&lt;br&gt;
MiddleName: A. J.&lt;br&gt;
ProfessionalSuffix: PHD,VC</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="NameExtension"/>
                <s:element minOccurs="0" name="FamilyName">
                    <s:annotation>
                        <s:documentation>The main part of the FamilyName, for sorting, etc.</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="80"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="FamilyNamePrefix">
                    <s:annotation>
                        <s:documentation>The prefix for the FamilyName, e.g. "van der"</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="NamePrefix">
                    <s:annotation>
                        <s:documentation>The prefix for the name, e.g. "Dr."</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="NameSuffix">
                    <s:annotation>
                        <s:documentation>The suffix for the name, e.g. "Jr", "III"</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="GivenName">
                    <s:annotation>
                        <s:documentation>The (first) given name</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="60"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="MiddleName">
                    <s:annotation>
                        <s:documentation>The (other) given names or initials&lt;br&gt;
 e.g. "John J", "William James", "A. T."</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="ProfessionalSuffix">
                    <s:annotation>
                        <s:documentation>The professional credentials, e.g. "MD", "PhD"</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="Type">
                    <s:annotation>
                        <s:documentation>Type of name for distinguishing a person's name from his/her birth name
VALUELIST taken from EntitynaepartQuaifier of HL7 2.16.840.1.113883.5.43
Same as in HS.Types.PersonName property Type</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="Alias"/>
                            <s:enumeration value="Adopted"/>
                            <s:enumeration value="Birth"/>
                            <s:enumeration value="Display"/>
                            <s:enumeration value="Legal"/>
                            <s:enumeration value="License"/>
                            <s:enumeration value="Maiden"/>
                            <s:enumeration value="Nickname"/>
                            <s:enumeration value="Previous"/>
                            <s:enumeration value="Tribal"/>
                            <s:enumeration value="Unknown"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="PreferredName">
                    <s:annotation>
                        <s:documentation>The name the person is usually known by other than the first name.</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="DOB" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>The patient's date of birth, when this Name is used as a patient alias.&lt;br&gt;
This property should not be populated by a data provider.  It is copied&lt;br&gt;
here from the Patient BirthTime as records are aggregated at the Access&lt;br&gt;
Gateway so that this Name, as an Alias, can be displayed in the Clinical&lt;br&gt;
Viewer with the DOB of the record from which it originated.  This property&lt;br&gt;
is not saved as part of the Patient Streamlet.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="MRN" type="s:string">
                    <s:annotation>
                        <s:documentation>The patient's medical record number, when this Name is used as a patient&lt;br&gt;
alias. This property should not be populated by a data provider.  It is&lt;br&gt;
copied here from the PatientNumber with NumberType="MRN" as records are&lt;br&gt;
aggregated at the Access Gateway so that this Name, as an Alias, can be&lt;br&gt;
displayed in the Clinical Viewer with the MRN of the record from which it&lt;br&gt;
originated.  This property is not saved as part of the Patient Streamlet.</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="NameExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:simpleType name="TimeStamp">
    <s:restriction base="s:string"/>
</s:simpleType>
<s:complexType name="ArrayOfName">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Name" nillable="true" type="Name"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Language">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="LanguageExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACPreferredLanguage(PREFLCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACPreferredLanguage(PREFLDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfPriorCode">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="PriorCode" nillable="true" type="PriorCode"/>
    </s:sequence>
</s:complexType>
<s:complexType name="PriorCode">
    <s:annotation>
        <s:documentation>PriorCode appears in the SDA as a list property (PriorCodes) of&lt;br&gt;
HS.SDA3.CodeTableTranslated and all classes that extend&lt;br&gt;
CodeTableTranslated.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="PriorCodeExtension"/>
                <s:element minOccurs="0" name="Code">
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="32000"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="Description">
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="32000"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="CodeSystem">
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="32000"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="Type">
                    <s:annotation>
                        <s:documentation>Supported values:&lt;br&gt;
O - Original&lt;br&gt;
A - Alternate&lt;br&gt;
N - Normalized&lt;br&gt;&lt;br&gt;
When a PriorCode is parsed from HL7, Type is set to "A". When a&lt;br&gt;
CodeTableTranslated is being translated, if the last entry in the list of&lt;br&gt;
PriorCodes has Type="O", then the pre-translation Code, Description, and&lt;br&gt;
SDACodingStandard will be inserted into PriorCodes as a PriorCode with&lt;br&gt;
Type="N". Else they will be inserted with Type="O".</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="A"/>
                            <s:enumeration value="O"/>
                            <s:enumeration value="N"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="CodeSystemVersionId">
                    <s:annotation>
                        <s:documentation>The coding system version ID&lt;br&gt;
For example, HL7v2.x data structure CNE or CWE, piece 8 if Type="A", or&lt;br&gt;
piece 7 if Type="O"</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="32000"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="PriorCodeExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="LanguageExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="CodeTableExtension">
    <s:annotation>
        <s:documentation>Base for extending code table classes
While identical to HS.SDA3.DataType, we use this to resolve XML name conflicts</s:documentation>
    </s:annotation>
</s:complexType>
<s:simpleType name="StrippedString">
    <s:restriction base="s:string">
        <s:maxLength value="32000"/>
    </s:restriction>
</s:simpleType>
<s:complexType name="ArrayOfPatientLanguage">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="PatientLanguage" nillable="true" type="PatientLanguage"/>
    </s:sequence>
</s:complexType>
<s:complexType name="PatientLanguage">
    <s:annotation>
        <s:documentation>PatientLanguage appears in the SDA as a list property (OtherLanguages) of&lt;br&gt;
HS.SDA3.Patient. See the annotations on this property for information on&lt;br&gt;
how PatientLanguage is matched at the Edge and inserted into the Viewer&lt;br&gt;
Cache.&lt;br&gt;</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PatientLanguageExtension"/>
        <s:element minOccurs="0" name="PreferredLanguage" type="Language">
            <s:annotation>
                <s:documentation>SDATableName=Language, ViewerClass=User.HS.PACPreferredLanguage&lt;br&gt;
VIEWERLIB: User.HS.PAPersonLanguage(LANGLanguageDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Use">
            <s:annotation>
                <s:documentation>What the language should be used for.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPersonLanguage(LANGUse)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Note: This property is needed by the Sweden project, do not remove.&lt;br&gt;
Prodlog 78545&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="User">
    <s:annotation>
        <s:documentation>Note that unlike most code tables in the Viewer Cache, SSUser is preserved&lt;br&gt;
across Access Gateway resets.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="UserExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
If Code is not null, it will be inserted into SSUSRInitials, else the first&lt;br&gt;
character of Description will be inserted into SSUSRInitials.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
If Code is not null, it will be inserted into SSUSRInitials, else the first&lt;br&gt;
character of Description will be inserted into SSUSRInitials.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="UserExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Organization">
    <s:annotation>
        <s:documentation>In the Viewer Cache, Organizations are matched on Code and&lt;br&gt;
SDACodingStandard only. Other properties stored in the Viewer Cache,&lt;br&gt;
including Description, will be updated if they are different in the inbound&lt;br&gt;
Organization versus the matched CTHospital.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="OrganizationA">
            <s:sequence>
                <s:element minOccurs="0" name="MedicalDirector" type="CareProvider">
                    <s:annotation>
                        <s:documentation>VIEWERLIB: Not stored</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="OrganizationA">
    <s:annotation>
        <s:documentation>In the Viewer Cache, Organizations are matched on Code and&lt;br&gt;
SDACodingStandard only. Other properties stored in the Viewer Cache,&lt;br&gt;
including Description, will be updated if they are different in the inbound&lt;br&gt;
Organization versus the matched CTHospital.
This class is used in place of HS.SDA3.CodeTableDetail.Organization in order to avoid a dependency look
caused by the MedicalDirector property referencing a CareProvider, which now has an AtOrganization property</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="OrganizationExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTHospital(HOSPCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTHospital(HOSPDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Address" type="Address">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
If an inbound Organization matches an existing CTHospital on Code and&lt;br&gt;
SDACodingStandard, then if the Street, City, State, and Zip are not all&lt;br&gt;
null, then the Street, City, State, Zip, County, and Country of the&lt;br&gt;
Organization will be compared to the corresponding properties of the&lt;br&gt;
CTHospital, and if any are found to be different, the CTHospital is&lt;br&gt;
determined to need an update (of all properties, not just Address).&lt;br&gt;
If the CTHospital is determined to need an update, then as long as the&lt;br&gt;
Street, City, State, Zip, County, and Country properties of the inbound&lt;br&gt;
Organization are not all null, they will all be inserted into the Viewer&lt;br&gt;
Cache, even if some of them are are null, and even if they overwrite&lt;br&gt;
non-null values.&lt;br&gt;&lt;br&gt;
.Street&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPAddress)&lt;br&gt;
.City&lt;br&gt;
SDATableName=City, ViewerClass=User.HS.CTCity&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCity)&lt;br&gt;
.State&lt;br&gt;
SDATableName=State, ViewerClass=User.HS.CTProvince&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPProvinceDR)&lt;br&gt;
.Zip&lt;br&gt;
SDATableName=Zip, ViewerClass=User.HS.CTZip&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPZipDR)&lt;br&gt;
.County&lt;br&gt;
SDATableName=County, ViewerClass=User.HS.CTCountyParish&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountyParishDR)&lt;br&gt;
.Country&lt;br&gt;
SDATableName=Country, ViewerClass=User.HS.CTCountry&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountryDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactInfo" type="ContactInfo">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
If an inbound Organization matches an existing CTHospital on Code and&lt;br&gt;
SDACodingStandard, then if the EmailAddress or WorkPhoneNumber of the&lt;br&gt;
Organization is not null and different from the corresponding property of&lt;br&gt;
the CTHospital, then the CTHospital is determined to need an update (of all&lt;br&gt;
properties, not just ContactInfo).&lt;br&gt;
If the CTHospital is determined to need an update, then the EmailAddress&lt;br&gt;
and WorkPhoneNumber will be inserted into the Viewer Cache if not null.&lt;br&gt;&lt;br&gt;
.WorkPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPPhone)&lt;br&gt;
.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPEmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Trusts" type="ArrayOfTrust">
            <s:annotation>
                <s:documentation>The trusts to which this organization belongs&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If an inbound Organization matches an existing CTHospital on Code and&lt;br&gt;
SDACodingStandard, then if the Organization has Trusts and if the inbound&lt;br&gt;
list of Trusts is not the same as the existing list (note that order of the&lt;br&gt;
list matters), then the CTHospital is determined to need an update (of all&lt;br&gt;
properties, not just Trusts).&lt;br&gt;
If the CTHospital is determined to need an update, then if the inbound&lt;br&gt;
Organization has any Trusts, they will update the Viewer Cache in&lt;br&gt;
"snapshot" mode.  That is, the existing Trusts will be cleared, and the&lt;br&gt;
inbound ones inserted.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(ChildCTHospitalTrusts)-&gt;User.HS.CTHospitalTrusts(TRUSTTrustDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Identifiers" type="ArrayOfIdentifier">
            <s:annotation>
                <s:documentation>Identifiers for the organization. Examples:
National Provider Identifier (NPI), tax ID number,
Clinical Laboratory Improvement Amendments (CLIA) Number.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="IsActive" type="Boolean">
            <s:annotation>
                <s:documentation>Whether the organization's record is still in active use.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="OrganizationExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Address">
    <s:annotation>
        <s:documentation>Address appears in the SDA as properties of the Guarantor, HealthFund,&lt;br&gt;
Patient, and SupportContact, as well as CareProvider, FamilyDoctor,&lt;br&gt;
HealthFund, Organization, and ReferralDoctor in the HS.SDA3.CodeTableDetail&lt;br&gt;
package. How Address is parsed from HL7 and what fields, if any, are&lt;br&gt;
inserted into the Viewer Cache will depend on the specific property the&lt;br&gt;
Address is being used for, and are documented in the annotations for that&lt;br&gt;
property.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="AddressExtension"/>
                <s:element minOccurs="0" name="FromTime" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>Effective start date for this address</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ToTime" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>Effective end date for this address</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Street">
                    <s:annotation>
                        <s:documentation>Everything in the address before city&lt;br&gt;
For multi-line street addresses, the suggested format is:&lt;br&gt;
"[firstline]; [secondline]; [thirdline]..."&lt;br&gt;
For example: "144/89; Moo 10; Soi 6"</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="City" type="City">
                    <s:annotation>
                        <s:documentation>SDATableName=City, ViewerClass=User.HS.CTCity</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="State" type="State">
                    <s:annotation>
                        <s:documentation>SDATableName=State, ViewerClass=User.HS.CTProvince</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Zip" type="Zip">
                    <s:annotation>
                        <s:documentation>ZIP or postal code&lt;br&gt;&lt;br&gt;
SDATableName=Zip, ViewerClass=User.HS.CTZip</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Country" type="Country">
                    <s:annotation>
                        <s:documentation>SDATableName=Country, ViewerClass=User.HS.CTCountry</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="County" type="County">
                    <s:annotation>
                        <s:documentation>SDATableName=County, ViewerClass=User.HS.CTCountyParish</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="AddressExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="City">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="CityExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCity(CTCITCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCity(CTCITDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="CityExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="State">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="StateExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTProvince(PROVCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTProvince(PROVDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="StateExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Zip">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ZipExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTZip(CTZIPCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTZip(CTZIPDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ZipExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Country">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="CountryExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCountry(CTCOUCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCountry(CTCOUDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="CountryExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="County">
    <s:annotation>
        <s:documentation>The Viewer Cache table for County, CT_CountyParish, is not constrained to&lt;br&gt;
have unique Descriptions, so Description will never have a uniqueness&lt;br&gt;
suffix added to it in the Viewer Cache.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="CountyExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCountyParish(CNTYPARCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCountyParish(CNTYPARDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="CountyExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ContactInfo">
    <s:annotation>
        <s:documentation>ContactInfo appears in the SDA as properties of the Guarantor, HealthFund,&lt;br&gt;
Patient, and SupportContact, as well as CareProvider, FamilyDoctor,&lt;br&gt;
HealthFund, Organization, and ReferralDoctor in the HS.SDA3.CodeTableDetail&lt;br&gt;
package. How ContactInfo is parsed from HL7 and what fields, if any, are&lt;br&gt;
inserted into the Viewer Cache will depend on the specific property the&lt;br&gt;
ContactInfo is being used for, and are documented in the annotations for&lt;br&gt;
that property.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ContactInfoExtension"/>
                <s:element minOccurs="0" name="HomePhoneNumber">
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="80"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="WorkPhoneNumber">
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="80"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="MobilePhoneNumber">
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="80"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="EmailAddress">
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="254"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ContactInfoExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfTrust">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Trust" nillable="true" type="Trust"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Trust">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="TrustExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACTrust(TRUSTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACTrust(TRUSTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="TrustExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfIdentifier">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Identifier" nillable="true" type="Identifier"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Identifier">
    <s:complexContent>
        <s:extension base="AbstractIdentifier">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="IdentifierExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType abstract="true" name="AbstractIdentifier">
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="Number">
                    <s:annotation>
                        <s:documentation>&lt;p&gt;
The identifier.
&lt;/p&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="ISOAssigningAuthority">
                    <s:annotation>
                        <s:documentation>&lt;p&gt;
The coding system or assigning authority for the Number.
&lt;/p&gt;&lt;p&gt;
This identifies who actually assigned the Number. So if the NumberType is an MRN, 
this could be the URI of the health network which assigned that MRN to the patient.
Or, if the number comes from a coding system, this property can be set to a URI
to that coding system specification, or to an IdentityCode value from a row in the OID registry table 
that has its Type set to "CodeSystem" and other values in the row could provide 
further details about that coding system.
&lt;/p&gt;&lt;p&gt;
MAXLEN = 50 for compatibility with HS.SDA3.PatientNumber.
&lt;/p&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="50"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="NumberType">
                    <s:annotation>
                        <s:documentation>&lt;p&gt;
A label indicating the identifier type.
&lt;/p&gt;&lt;p&gt;
Patient identifier examples: 
Medical record number (MRN), social security number (SSN),
national identifier, driver's license, etc.
Organization identifier examples: 
National Provider Identifier (NPI), tax ID number,
Clinical Laboratory Improvement Amendments (CLIA) Number.
&lt;/p&gt;&lt;p&gt;
MAXLEN = 50 for compatibility with HS.SDA3.PatientNumber.
&lt;/p&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="50"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="NumberTypeCodeSystem">
                    <s:annotation>
                        <s:documentation>The coding system for the identifier NumberType.
This property describes the coding system for the NumberType, not the Number.
This property can provide a URI that links to a description of the coding system.
Or, this property can be set to an IdentityCode value from a row in the OID registry table 
that has its Type set to "CodeSystem" and other values in the row could provide 
further details about that coding system.</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="IdentifierExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:simpleType name="Boolean">
    <s:restriction base="s:boolean"/>
</s:simpleType>
<s:complexType name="CareProvider">
    <s:annotation>
        <s:documentation>In the Viewer Cache, CareProviders are matched on Code, SDACodingStandard,&lt;br&gt;
Description, and CareProviderType (which is itself a code table). Other&lt;br&gt;
properties are updated if different.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="CareProviderExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCareProv(CTPCPCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Name" type="Name">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
If the inbound CareProvider has a Name defined, then if the inbound&lt;br&gt;
FamilyName, GivenName, MiddleName, NamePrefix, FamilyNamePrefix,&lt;br&gt;
NameSuffix, and ProfessionalSuffix are not all null and if any differ from&lt;br&gt;
the corresponding properties of the matched CTCareProv, then the CTCareProv&lt;br&gt;
is determined to need an update (of all properties, not just Name).&lt;br&gt;
On add or update, the properties of Name listed below will only be inserted&lt;br&gt;
into the Viewer Cache if at least one of the properties is not null. If so,&lt;br&gt;
then the properties will all be inserted into the Viewer Cache, even nulls,&lt;br&gt;
and even if they overwrite non-null values.&lt;br&gt;&lt;br&gt;
.FamilyName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.FamilyNamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextOne)&lt;br&gt;
.NameSuffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.ProfessionalSuffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Address" type="Address">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
If the inbound CareProvider has an Address defined, then if the inbound&lt;br&gt;
Street, City, and Zip are not all null and if any differ from the&lt;br&gt;
corresponding properties of the matched CTCareProv, then the CTCareProv&lt;br&gt;
is determined to need an update (of all properties, not just Address).&lt;br&gt;
On add or update, the properties of Address listed below will only be&lt;br&gt;
inserted into the Viewer Cache if at least one of the properties is not&lt;br&gt;
null. If so, then the properties will all be inserted into the Viewer&lt;br&gt;
Cache, even nulls, and even if they overwrite non-null values.&lt;br&gt;
Note that CTPCPStName is of type List of %String. HealthShare will only&lt;br&gt;
ever populate the first entry in the list.&lt;br&gt;&lt;br&gt;
.Street&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPStName)&lt;br&gt;
.City&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCityDR)&lt;br&gt;
.Zip&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPZipDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactInfo" type="ContactInfo">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
For each of the properties of ContactInfo, if the inbound property is&lt;br&gt;
non-null and does not match the corresponding property of the matched&lt;br&gt;
CTCareProv, then the CTCareProv is determined to need an update (of all&lt;br&gt;
properties, not just ContactInfo).&lt;br&gt;
On add or update, for each of the properties of ContactInfo, the inbound&lt;br&gt;
property will only be inserted into the Viewer Cache if it is non-null.&lt;br&gt;&lt;br&gt;
.HomePhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTelH)&lt;br&gt;
.WorkPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTelO)&lt;br&gt;
.MobilePhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPMobilePhone)&lt;br&gt;
.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPEmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CareProviderType" type="CareProviderType">
            <s:annotation>
                <s:documentation>This field may either refer to the specialty of the clinician&lt;br&gt;
(cardiologist, radiologist, etc.) or to his role in a given scenario&lt;br&gt;
(admitting, attending, etc.).&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
CareProviderType is a match property for CareProvider in the Viewer Cache.&lt;br&gt;
That is, it must match the existing CTPCPCarPrvTpDR for the CareProviders&lt;br&gt;
to be considered a match. A null value (either inbound or existing) will&lt;br&gt;
not match a non-null value.&lt;br&gt;&lt;br&gt;
SDATableName=CareProviderType, ViewerClass=User.HS.CTCarPrvTp&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCarPrvTpDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="NameTypeCode" type="s:string">
            <s:annotation>
                <s:documentation>A code that represents the type of name. For example: "L"\"Legal",&lt;br&gt;
"M"\"Maiden", "A"\"Alias". See HL7 table 200.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="IdentifierTypeCode" type="s:string">
            <s:annotation>
                <s:documentation>A code corresponding to the type of identifier. For example: "NPI" for&lt;br&gt;
"National provider identifier".  See HL7 table 203.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AtOrganization" type="OrganizationA">
            <s:annotation>
                <s:documentation>This is to support use cases such as "individual provider at organization",
which is needed for care community.
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="CareProviderExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="CareProviderType">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="CareProviderTypeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCarPrvTp(CTCPTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTCarPrvTp(CTCPTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="CareProviderTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PatientLanguageExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Religion">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ReligionExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTReligion(CTRLGCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTReligion(CTRLGDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ReligionExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="MaritalStatus">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="MaritalStatusExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTMarital(CTMARCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTMarital(CTMARDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="MaritalStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Gender">
    <s:annotation>
        <s:documentation>For all CodeTableDetails that get loaded into the Viewer Cache, the&lt;br&gt;
matching logic in the Viewer Cache will match a null inbound Description to&lt;br&gt;
anything. For Gender only, an inbound Description that is the same as the&lt;br&gt;
inbound Code will also match anything. For example, an inbound Code="M",&lt;br&gt;
Desc="M" will match an existing Code="M", Desc="Male".&lt;br&gt;
Also, note that unlike most code tables in the Viewer Cache, CTSex is&lt;br&gt;
preserved across Access Gateway resets.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="GenderExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTSex(CTSEXCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTSex(CTSEXDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="GenderExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Race">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="RaceExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACIndigStatus(INDSTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACIndigStatus(INDSTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="RaceExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfRace">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Race" nillable="true" type="Race"/>
    </s:sequence>
</s:complexType>
<s:complexType name="EthnicGroup">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="EthnicGroupExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="CodeTableTranslated">
    <s:annotation>
        <s:documentation>Base class for coded properties that can have code history in addition to&lt;br&gt;
the current code, description, and code system. Every class that can be&lt;br&gt;
translated extends CodeTableTranslated, however not every class that&lt;br&gt;
extends CodeTableTranslated can be translated. Currently only the types&lt;br&gt;
listed on the Terminology Translation Profiles screen in the HealthShare&lt;br&gt;
Management Portal on the Registry can be translated. When HealthShare&lt;br&gt;
translates a code, a copy of the original is put in PriorCodes. See the HS&lt;br&gt;
documentation for more info on terminology translation.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableDetail">
            <s:sequence>
                <s:element minOccurs="0" name="OriginalText">
                    <s:annotation>
                        <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="32000"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
                    <s:annotation>
                        <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="CodeTableDetail">
    <s:annotation>
        <s:documentation>The base class for all SDA code table objects. Every code table class&lt;br&gt;
should either extend this or HS.SDA3.CodeTableTranslated.&lt;br&gt;
For each class that extends CodeTableDetail, if it gets loaded into the&lt;br&gt;
Viewer Cache, the location that each property gets loaded into will be&lt;br&gt;
documented on that property. Unless otherwise noted in the class, matching&lt;br&gt;
between CodeTableDetails and their Viewer Cache counterparts is done on&lt;br&gt;
Code, Description, and SDACodingStandard.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>The external code, e.g. "M"&lt;br&gt;&lt;br&gt;
When the CodeTableDetail is imported via the XMLImportSDAString method,&lt;br&gt;
Code will not be imported if it contains only punctuation and/or&lt;br&gt;
whitespace, unless it is the SDA3 delete instruction (two double quotes).&lt;br&gt;
There is one exception to this for HS.SDA3.CodeTableDetail.UoM, in which&lt;br&gt;
case Code may be a percent sign ("%").&lt;br&gt;&lt;br&gt;
Code may not contain the caret ("^") symbol as this is reserved for&lt;br&gt;
internal use. In the Viewer Cache only, TAB ($c(9)) is also a reserved&lt;br&gt;
character and will be replaced with a space. For LabTestItems in the Viewer&lt;br&gt;
Cache, backslash ("\") is also reserved and will be replaced with&lt;br&gt;
an underscore ("_").</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>The description, as displayed to the user, e.g. "Male"&lt;br&gt;&lt;br&gt;
When the CodeTableDetail is imported via the XMLImportSDAString method,&lt;br&gt;
Description will not be imported if it contains only punctuation and/or&lt;br&gt;
whitespace, unless it is the SDA3 delete instruction (two double quotes).&lt;br&gt;
There is one exception to this for HS.SDA3.CodeTableDetail.UoM, in which&lt;br&gt;
case Description may be a percent sign ("%"). Then, if Description is null&lt;br&gt;
or the same as Code, and SDACodingStandard and Code are not null, then&lt;br&gt;
HealthShare will attempt to find an entry in the Code Registry matching on&lt;br&gt;
Code and SDACodingStandard (converted to uppercase). If a match is found,&lt;br&gt;
Description will be defaulted from that entry. Note that this takes place&lt;br&gt;
after SDACodingStandard is defaulted, so the defaulted value of&lt;br&gt;
SDACodingStandard may be used for matching.&lt;br&gt;&lt;br&gt;
Description may contain caret ("^") characters in the SDA, however this&lt;br&gt;
character is reserved in the Viewer Cache, so in the Viewer Cache only, "^"&lt;br&gt;
will be replaced with an underscore ("_"). Also in the Viewer Cache only,&lt;br&gt;
TAB ($c(9)) is reserved and will be replaced with a space, and for&lt;br&gt;
LabTestItems, backslash ("\") is reserved will be replaced with an&lt;br&gt;
underscore.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="EthnicGroupExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSupportContact">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="SupportContact" nillable="true" type="SupportContact"/>
    </s:sequence>
</s:complexType>
<s:complexType name="SupportContact">
    <s:annotation>
        <s:documentation>SupportContact appears in the SDA as a list property (SupportContacts) of&lt;br&gt;
HS.SDA3.Patient.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In the HL7ToSDA3 transform, it is possible for one NK1 segment to be parsed&lt;br&gt;
as two SupportContacts. One (referred to in these annotations as the&lt;br&gt;
"Inidividual Contact") is parsed from fields 2 through 9 (though nothing&lt;br&gt;
will be parsed, not even an empty SupportContact, if these are all null).&lt;br&gt;
The second ("Organization Contact") is parsed from fields 13, 30, 31, and&lt;br&gt;
32, and only if field 13 is not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
Note that SupportContacts are not their own type of Streamlets, but are a&lt;br&gt;
serial property of HS.SDA3.Patient. In both the Streamlet Cache (Edge&lt;br&gt;
Gateway) and the Aggregation Cache (Access Gateway), updates to a Patient's&lt;br&gt;
list of SupportContacts are compared to existing SupportContacts. Matches&lt;br&gt;
will update existing SupportContacts, while non-matches are simply added to&lt;br&gt;
the existing list. Matching is done on:&lt;br&gt;
-Name.FamilyName&lt;br&gt;
-Name.GivenName&lt;br&gt;
-Name.MiddleName&lt;br&gt;
-Address.Street&lt;br&gt;
-Address.City.Code+Description&lt;br&gt;
-Address.State.Code+Description&lt;br&gt;
-Address.Zip.Code+Description&lt;br&gt;
-Address.Country.Code+Description&lt;br&gt;
All properties are ALPHAUP collated before matching. All properties are&lt;br&gt;
inbound and existing optional (a null value will not cause the comparison&lt;br&gt;
to be a non-match). For the purposes of matching, both inbound and existing&lt;br&gt;
Descriptions, if null, will be defaulted to Code.&lt;br&gt;
When a match is made and an inbound SupportContact is to be merged into an&lt;br&gt;
existing one, the update logic for most properties is: set the existing&lt;br&gt;
property to the value of the inbound only if the existing is null.&lt;br&gt;
Exceptions to this will be noted below.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, no attempt is made to match inbound SupportContacts to&lt;br&gt;
existing PANoks. Every time the PAPerson is updated in the Viewer Cache, if&lt;br&gt;
the SDA Patient has any SupportContacts, any existing PANoks are deleted,&lt;br&gt;
and the entire list of SupportContacts is inserted.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="Extension" type="SupportContactExtension"/>
        <s:element minOccurs="0" name="Name" type="Name">
            <s:annotation>
                <s:documentation>Primary name for this person (e.g. legal name)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
NK1-2 is parsed to the Individual Contact, and NK1-30 to the Organization&lt;br&gt;
Contact. Though both NK1-2 and -30 are repeating fields, HL7ToSDA3 will&lt;br&gt;
only use the first instance of each.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
When a match is found between an inbound SupportContact and an existing&lt;br&gt;
one, each property of Name is updated individually, rather than the update&lt;br&gt;
of Name being "all or nothing".&lt;br&gt;&lt;br&gt;
HL7:  NK1-2 : Name&lt;br&gt;
HL7:  NK1-30 : ContactPersonsName&lt;br&gt;&lt;br&gt;
.FamilyName&lt;br&gt;
HL7:  NK1-2.1.1 : Name.FamilyName.Surname&lt;br&gt;
HL7:  NK1-30.1.1 : ContactPersonsName.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKName)&lt;br&gt;
.FamilyNamePrefix&lt;br&gt;
HL7:  NK1-2.1.2 : Name.FamilyName.OwnSurnamePrefix&lt;br&gt;
HL7:  NK1-30.1.2 : ContactPersonsName.FamilyName.OwnSurnamePrefix&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKFamilyNamePrefix)&lt;br&gt;
.GivenName&lt;br&gt;
HL7:  NK1-2.2 : Name.GivenName&lt;br&gt;
HL7:  NK1-30.2 : ContactPersonsName.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKName2)&lt;br&gt;
.MiddleName&lt;br&gt;
HL7:  NK1-2.3 : Name.SecondandFurtherGivenNames&lt;br&gt;
HL7:  NK1-30.3 : ContactPersonsName.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKName3)&lt;br&gt;
.NameSuffix&lt;br&gt;
HL7:  NK1-2.4 : Name.Suffix&lt;br&gt;
HL7:  NK1-30.4 : ContactPersonsName.Suffix&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKNameSuffix)&lt;br&gt;
.NamePrefix&lt;br&gt;
HL7:  NK1-2.5 : Name.Prefix&lt;br&gt;
HL7:  NK1-30.5 : ContactPersonsName.Prefix&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKNamePrefix)&lt;br&gt;
.ProfessionalSuffix&lt;br&gt;
HL7:  NK1-2.14 : Name.ProfessionalSuffix&lt;br&gt;
HL7:  NK1-30.14 : ContactPersonsName.ProfessionalSuffix&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKProfessionalSuffix)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Gender" type="Gender">
            <s:annotation>
                <s:documentation>The gender of this contact&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="BirthTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The date of birth of this contact&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PrimaryLanguage" type="Language">
            <s:annotation>
                <s:documentation>This contact's primary spoken language&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Address" type="Address">
            <s:annotation>
                <s:documentation>Address of the support contact&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
NK1-4 is parsed to the Individual Contact, and NK1-32 to the Organization&lt;br&gt;
Contact. Though both NK1-4 and -32 are repeating fields, HL7ToSDA3 will&lt;br&gt;
only use the first instance of each.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
When a match is found between an inbound SupportContact and an existing&lt;br&gt;
one, each property of Address is updated individually, rather than the&lt;br&gt;
update of Address being "all or nothing".&lt;br&gt;&lt;br&gt;
HL7:  NK1-4 : Address&lt;br&gt;
HL7:  NK1-32 : ContactPersonsAddress&lt;br&gt;&lt;br&gt;
.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields 4 and 32; subfield 2, if present, is concatenated to&lt;br&gt;
subfield 1.1 as "[1.1]; [2]".&lt;br&gt;
HL7:  NK1-4.1.1 : Address.StreetAddressStreetorMailingAddress&lt;br&gt;
HL7:  NK1-4.2 : Address.OtherDesignation&lt;br&gt;
HL7:  NK1-32.1.1 : ContactPersonsAddress.StreetAddressStreetorMailingAddress&lt;br&gt;
HL7:  NK1-32.2 : ContactPersonsAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKAddress2)&lt;br&gt;
.City&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields 4 and 32, subfield 3 is parsed as City.Code. HL7ToSDA3 does&lt;br&gt;
not set the Description.&lt;br&gt;
HL7:  NK1-4.3 : Address.City&lt;br&gt;
HL7:  NK1-32.3 : ContactPersonsAddress.City&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKCityCodeDR)&lt;br&gt;
.State&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields 4 and 32, subfield 4 is parsed as State.Code. HL7ToSDA3&lt;br&gt;
does not set the Description.&lt;br&gt;
HL7:  NK1-4.4 : Address.StateorProvince&lt;br&gt;
HL7:  NK1-32.4 : ContactPersonsAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKProvinceDR)&lt;br&gt;
.Zip&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields 4 and 32, subfield 5 is parsed as Zip.Code. HL7ToSDA3 does&lt;br&gt;
not set the Description.&lt;br&gt;
HL7:  NK1-4.5 : Address.ZiporPostalCode&lt;br&gt;
HL7:  NK1-32.5 : ContactPersonsAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKZipDR)&lt;br&gt;
.Country&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields 4 and 32, subfield 6 is parsed as Country.Code. HL7ToSDA3&lt;br&gt;
does not set the Description.&lt;br&gt;
HL7:  NK1-4.6 : Address.Country&lt;br&gt;
HL7:  NK1-32.6 : ContactPersonsAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKCountryDR)&lt;br&gt;
.County&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields 4 and 32, subfield 9 is parsed as County.Code.  HL7ToSDA3&lt;br&gt;
does not set the Description.&lt;br&gt;
HL7:  NK1-4.9 : Address.CountyParishCode&lt;br&gt;
HL7:  NK1-32.9 : Address.CountyParishCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.FromTime&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of FromTime is stored in the viewer cache.
(NOKAddrStartDate is date-only.)&lt;br&gt;
HL7:  NK1-4.13.1 : Address.EffectiveDateTime&lt;br&gt;
HL7:  NK1-32.13.1 : ContactPersonsAddress.EffectiveDateTime&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKAddrStartDate)&lt;br&gt;
.ToTime&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of ToTime is stored in the viewer cache. (NOKAddrEndDate&lt;br&gt;
is date-only.)&lt;br&gt;
HL7:  NK1-4.14.1 : Address.ExpirationDateTime&lt;br&gt;
HL7:  NK1-32.14.1 : ContactPersonsAddress.ExpirationDateTime&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKAddrEndDate)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactInfo" type="ContactInfo">
            <s:annotation>
                <s:documentation>Contact information for the SupportContact&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
NK1-5 and -6 are parsed to the Individual Contact, while NK1-31 is parsed&lt;br&gt;
to the Organization Contact. For each instance of each field, the algorithm&lt;br&gt;
to parse a phone number out of that field is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else continue to the next instance of this field.&lt;br&gt;&lt;br&gt;
-Whichever number is parsed, if subfield 9 of that instance is not null, it&lt;br&gt;
will be appended to the number, delimited by a semicolon.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
When a match is found between an inbound SupportContact and an existing&lt;br&gt;
one, each property of ContactInfo is updated individually, rather than the update&lt;br&gt;
of ContactInfo being "all or nothing".&lt;br&gt;&lt;br&gt;
HL7:  NK1-5 : PhoneNumber&lt;br&gt;
HL7:  NK1-6 : BusinessPhoneNumber&lt;br&gt;
HL7:  NK1-31 : ContactPersonsTelephoneNumber&lt;br&gt;&lt;br&gt;
.HomePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
From NK1-5, HomePhoneNumber is parsed from the first instance of the field&lt;br&gt;
with subfield 2 (Use) in ["",PRN,ORN,VHN,ASN,EMR], and subfield 3 in&lt;br&gt;
["",PH], and from which a number can be parsed using the above algorithm.&lt;br&gt;
HL7:  NK1-5 : PhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKTelH)&lt;br&gt;
.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
NK1-6 is parsed to the Individual Contact, and NK1-31 is parsed to the&lt;br&gt;
Organization Contact. For both fields, WorkPhoneNumber is parsed from the&lt;br&gt;
first instance of the field with subfield 2 in ["",WPN,ASN,EMR], and&lt;br&gt;
subfield 3 in ["",PH], and from which a number can be parsed using the&lt;br&gt;
above algorithm.&lt;br&gt;
HL7:  NK1-6 : BusinessPhoneNumber&lt;br&gt;
HL7:  NK1-31 : ContactPersonsTelephoneNumber&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKTelO)&lt;br&gt;
.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For the Individual Contact, first NK1-5 is parsed for MobilePhoneNumber,&lt;br&gt;
then if none is found there, NK1-6 is parsed. For the Organization Contact,&lt;Br&gt;
MobilePhoneNumber is parsed from NK1-31. In both cases, MobilePhoneNumber&lt;br&gt;
is parsed from the first instance with subfield 2 = "BPN" or subfield 3 in&lt;br&gt;
[CP,BP], and from which a number can be parsed using the above algorithm.&lt;br&gt;
HL7:  NK1-5 : PhoneNumber&lt;br&gt;
HL7:  NK1-6 : BusinessPhoneNumber&lt;br&gt;
HL7:  NK1-31 : ContactPersonsTelephoneNumber&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKMobPhone)&lt;br&gt;
.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For the Individual Contact, EmailAddress is parsed from the first non-null&lt;br&gt;
instance of subfield 4 in NK1-5 and -6. For the Organization Contact,&lt;br&gt;
EmailAddress is parsed from the first non-null instance of subfield 4 in&lt;br&gt;
NK1-31.&lt;br&gt;
HL7:  NK1-5.4 : PhoneNumber.EmailAddress&lt;br&gt;
HL7:  NK1-6.4 : BusinessPhoneNumber.EmailAddress&lt;br&gt;
HL7:  NK1-31.4 : ContactPersonsTelephoneNumber.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKEmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Relationship" type="Relationship">
            <s:annotation>
                <s:documentation>Personal relationship of support contact to patient (e.g. brother, daughter)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
NK1-3 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  NK1-3 : Relationship&lt;br&gt;
SDATableName=Relationship, ViewerClass=User.HS.CTRelation&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKRelationDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  NK1-3.1 : Relationship.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTRelation(CTRLTCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  NK1-3.2 : Relationship.Text&lt;br&gt;
VIEWERLIB: User.HS.CTRelation(CTRLTDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  NK1-3.3 : Relationship.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  NK1-3.7 : Relationship.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 are parsed&lt;br&gt;
into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes. The Type will be&lt;br&gt;
parsed as "A" for "Alternate".&lt;br&gt;
HL7:  NK1-3.4 : Relationship.AlternateIdentifier&lt;br&gt;
HL7:  NK1-3.5 : Relationship.AlternateText&lt;br&gt;
HL7:  NK1-3.6 : Relationship.NameofAlternateCodingSystem&lt;br&gt;
HL7:  NK1-3.8 : Relationship.AlternateCodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactType" type="ContactType">
            <s:annotation>
                <s:documentation>specific relationship role (e.g. employer, emergency contact)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
NK1-7 is only parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  NK1-7 : ContactRole&lt;br&gt;
SDATableName=ContactType, ViewerClass=User.HS.PACContactType&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKContactTypeDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  NK1-7.1 : ContactRole.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PACContactType(CONTTPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  NK1-7.2 : ContactRole.Text&lt;br&gt;
VIEWERLIB: User.HS.PACContactType(CONTTPCode)&lt;br&gt;
VIEWERLIB: User.HS.PACContactType(CONTTPPriority)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  NK1-7.3 : ContactRole.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PrimaryContact" type="Boolean">
            <s:annotation>
                <s:documentation>A boolean property indicating whether this contact is the patient's primary&lt;br&gt;
contact.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Identifiers" type="ArrayOfPatientNumber">
            <s:annotation>
                <s:documentation>A list of identifying numbers for this contact, such as insurance card&lt;br&gt;
number, various government-assigned numbers, etc.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
Once a match has been identified between an inbound and existing&lt;br&gt;
SupportContact, the Identifiers of each are compared for possible matches,&lt;br&gt;
matching on Number, NumberType, and Organization.Code. Matching on each&lt;br&gt;
property is exact. If no match is found, the inbound PatientNumber is&lt;br&gt;
inserted into the existing Identifiers list.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKUpdateUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
The Organization Contact will only be parsed from an NK1 segment if NK1-13&lt;br&gt;
is not null. Though NK1-13 is a repeating field, HL7ToSDA3 only uses the&lt;br&gt;
first instance.&lt;br&gt;&lt;br&gt;
HL7: NK1-13 : OrganizationNameNK1&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKUpdateHospitalDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 10 is not null, it will be parsed to Code. Else subfield 3 will&lt;br&gt;
be parsed to Code.&lt;br&gt;
HL7:  NK1-13.10 : OrganizationNameNK1.OrganizationIdentifier&lt;br&gt;
HL7:  NK1-13.3 : OrganizationNameNK1.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  NK1-13.1 : OrganizationNameNK1.OrganizationName&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  NK1-13.6 : OrganizationNameNK1.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
NOKUpdateDate is set to the date part of EnteredOn, and NOKUpdateTime is&lt;br&gt;
set to the time part. Additionally, NOKIDDate is set to the date part.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKUpdateDate) + User.HS.PANok(NOKUpdateTime)&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKIDDate)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
Only the date part of FromTime is stored in the Viewer Cache. (NOKDateFrom&lt;br&gt;
is date-only.)&lt;br&gt;&lt;br&gt;
HL7:  NK1-8 : StartDate&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKDateFrom)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
Only the date part of ToTime is stored in the Viewer Cache. (NOKDateTo&lt;br&gt;
is date-only.)&lt;br&gt;&lt;br&gt;
HL7:  NK1-9 : EndDate&lt;br&gt;
VIEWERLIB: User.HS.PANok(NOKDateTo)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
Once a match has been identified between an inbound and existing&lt;br&gt;
SupportContact, the CustomPairs of each are compared for possible matches,&lt;br&gt;
matching on Name and Value. Matching on each property is exact. If no match&lt;br&gt;
is found, the inbound NVPair is inserted into the existing CustomPairs&lt;br&gt;
list.&lt;br&gt;&lt;br&gt;
Viewer Cache: Even though SupportContact is not a streamlet type,&lt;br&gt;
CustomPairs are still supported, and stored with info type "NOK".&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)&lt;br&gt;&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in the Set ID field (NK1-1) will be parsed&lt;br&gt;
as ActionCode="D"&lt;br&gt;
HL7:  NK1-1 : SetIDNK1&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="SupportContactExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Relationship">
    <s:annotation>
        <s:documentation>In the Viewer Cache, both FamilyMember and Relationship CodeTableDetails&lt;br&gt;
are processed into the CTRelation table.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="RelationshipExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTRelation(CTRLTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTRelation(CTRLTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="RelationshipExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ContactType">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ContactTypeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACContactType(CONTTPCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACContactType(CONTTPDesc)&lt;br&gt;
VIEWERLIB: User.HS.PACContactType(CONTTPPriority)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ContactTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfPatientNumber">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="PatientNumber" nillable="true" type="PatientNumber"/>
    </s:sequence>
</s:complexType>
<s:complexType name="PatientNumber">
    <s:annotation>
        <s:documentation>PatientNumber appears in the SDA as the PatientNumbers and&lt;br&gt;
PriorPatientNumbers (both lists) properties of HS.SDA3.Patient, as the&lt;br&gt;
Identifiers (list) property of HS.SDA3.SupportContact, and as the&lt;br&gt;
GuarantorNumber property of HS.SDA3.Guarantor. How it is parsed from HL7&lt;br&gt;
and loaded into the Streamlet, Aggregation, and Viewer Caches is documented&lt;br&gt;
on each of these properties, where applicable.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time updated or entered.  For labs, this represents when the order was&lt;br&gt;
placed.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Number">
            <s:annotation>
                <s:documentation>&lt;p&gt;
The identifier.
&lt;/p&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="NumberType">
            <s:annotation>
                <s:documentation>&lt;p&gt;
A label indicating the identifier type.
&lt;/p&gt;&lt;p&gt;
Patient identifier examples: 
Medical record number (MRN), social security number (SSN),
national identifier, driver's license, etc.
Organization identifier examples: 
National Provider Identifier (NPI), tax ID number,
Clinical Laboratory Improvement Amendments (CLIA) Number.
&lt;/p&gt;&lt;p&gt;
MAXLEN = 50 for compatibility with HS.SDA3.PatientNumber.
&lt;/p&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="50"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="NumberTypeCodeSystem">
            <s:annotation>
                <s:documentation>The coding system for the identifier NumberType.
This property describes the coding system for the NumberType, not the Number.
This property can provide a URI that links to a description of the coding system.
Or, this property can be set to an IdentityCode value from a row in the OID registry table 
that has its Type set to "CodeSystem" and other values in the row could provide 
further details about that coding system.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PatientNumberExtension"/>
        <s:element minOccurs="0" name="Organization" type="Organization">
            <s:annotation>
                <s:documentation>The Assigning Authority for the number&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ISOAssigningAuthority">
            <s:annotation>
                <s:documentation>The difference between Organization and ISOAssigningAuthority is that&lt;br&gt;
Organization is a CodeTableDetail whose Code is intended to come from piece&lt;br&gt;
1 of an Hierarchic Designator (HD) data structure, PID-3.4 for example.&lt;br&gt;
ISOAssigningAuthority is a string that is intended to contain the entire HD&lt;br&gt;
structure, i.e. all of PID-3.4, not just PID-3.4.1 Unlike Organization,&lt;br&gt;
ISOAssigningAuthority is not functional. That is, no matching or other&lt;br&gt;
logic triggers off it.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="50"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PatientNumberExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:simpleType name="Numeric">
    <s:restriction base="s:decimal"/>
</s:simpleType>
<s:complexType name="Citizenship">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="CitizenshipExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTNation(CTNATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTNation(CTNATDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="CitizenshipExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfAddress">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Address" nillable="true" type="Address"/>
    </s:sequence>
</s:complexType>
<s:complexType name="FamilyDoctor">
    <s:annotation>
        <s:documentation>In the Viewer Cache, FamilyDoctors are matched on Code and&lt;br&gt;
SDACodingStandard only. Other properties stored in the Viewer Cache,&lt;br&gt;
including Description, will be updated if they are different in the inbound&lt;br&gt;
FamilyDoctor versus the matched PACRefDoctor.&lt;br&gt;&lt;br&gt;
Note that both ReferralDoctor and FamilyDoctor CodeTableDetails populate&lt;br&gt;
the PACRefDoctor table in the Viewer Cache.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="FamilyDoctorExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACRefDoctor(REFDCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACRefDoctor(REFDDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Name" type="Name">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
If the inbound FamilyDoctor matches a PACRefDoctor on Code and&lt;br&gt;
SDACodingStandard, then if the FamilyDoctor has a Name defined and&lt;br&gt;
FamilyName, GivenName, MiddleName, and NamePrefix are not all null, then&lt;br&gt;
they will be compared to the corresponding properties of the matched&lt;br&gt;
PACRefDoctor. If any property does not match, then the PACRefDoctor is&lt;br&gt;
determined to need an update (of all properties, not just the mismatched&lt;br&gt;
property).&lt;br&gt;
If the matched PACRefDoctor is determined to need an update, then if the&lt;br&gt;
FamilyDoctor has a Name defined, then FamilyName, GivenName, MiddleName,&lt;br&gt;
and NamePrefix are all inserted into the Viewer Cache, even if any of them&lt;br&gt;
are null, and even if they overwrite non-null values.&lt;br&gt;&lt;br&gt;
.FamilyName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDFamilyName)&lt;br&gt;
.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDForename)&lt;br&gt;
.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDMiddleName)&lt;br&gt;
.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDTitle)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Address" type="Address">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactInfo" type="ContactInfo">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="FamilyDoctorExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Occupation">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="OccupationExtension"/>
                <s:element minOccurs="0" name="JobClass">
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="300"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="OccupationExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PublicityCode">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="PublicityCodeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="PublicityCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfDocumentProvider">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="DocumentProvider" nillable="true" type="DocumentProvider"/>
    </s:sequence>
</s:complexType>
<s:complexType name="DocumentProvider">
    <s:sequence>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DocumentProviderExtension"/>
        <s:element minOccurs="0" name="Provider" type="CareProvider">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Role" type="DocumentProviderRole">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comment">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DocumentProviderExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DocumentProviderRole">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="DocumentProviderRoleExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="DocumentProviderRoleExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfDocumentOrganization">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="DocumentOrganization" nillable="true" type="DocumentOrganization"/>
    </s:sequence>
</s:complexType>
<s:complexType name="DocumentOrganization">
    <s:sequence>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DocumentOrganizationExtension"/>
        <s:element minOccurs="0" name="Organization" type="Organization">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Role" type="DocumentOrganizationRole">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DocumentOrganizationExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DocumentOrganizationRole">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="DocumentOrganizationRoleExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="DocumentOrganizationRoleExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfEncounter">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Encounter" nillable="true" type="Encounter"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Encounter">
    <s:annotation>
        <s:documentation>HS.SDA3.Encounter corresponds to the CDA Encounters section
and to /ClinicalDocument/componentOf/encompassingEncounter.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="EncounterExtension"/>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>See the annotation on the superclass property for more info on how the&lt;br&gt;
EncounterNumber property is used.&lt;br&gt;&lt;br&gt;
The method GenerateEncounterNum of the Encounter Streamlet class is used to&lt;br&gt;
generate an encounter number when none is given, both in HL7ToSDA3 and in&lt;br&gt;
the Streamlet class. They differ in the source of the values passed to the&lt;br&gt;
method, but in both cases the logic is:&lt;br&gt;
-If the encounter type is "G" or "S", generate EncounterNumber as "HSgenerated[incremental#]".&lt;br&gt;
-Else if the MRN and encounter admit date are not null, generate EncounterNumber as "[MRN]-[admit date]"&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If a message contains a PV1 segment but has no value in PV1-19.1, HL7ToSDA3&lt;br&gt;
will call GenerateEncounterNum to generate one, passing it the following&lt;br&gt;
values:&lt;br&gt;
-PV1-2 (Patient Class) as encounter type.&lt;br&gt;
-The source of the MRN value is:&lt;br&gt;
--PID-2.1 (Patient ID.ID Number), if not null.&lt;br&gt;
--Else the first PID-3.1 (Patient Identifier List.ID Number) with PID-3.5 (Identifier Type Code) = "MR", "MRN", or "PI", if there is one&lt;br&gt;
--Else the first PID-4.1 (Alternate Patient ID.ID Number) with PID-4.5 (Identifier Type Code) = "MR", "MRN", or "PI", if there is one&lt;br&gt;
-PV1-44.1 (Admit Date/Time.Time) as the admit date.&lt;br&gt;
If no EncounterNumber can be generated, a warning will be logged, no&lt;br&gt;
Encounter will be parsed to the SDA, and all streamlets in the SDA will be&lt;br&gt;
Encounter-less.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if EncounterNumber is&lt;br&gt;
null, it is defaulted to the ExternalId. Then, if EncounterNumber contains&lt;br&gt;
a pipe character ("|"), an error will be logged and the Encounter will not&lt;br&gt;
be processed. If the EncounterNumber is null at this point,&lt;br&gt;
GenerateEncounterNum will be called with the following values:&lt;br&gt;
-The SDA EncounterType as the encounter type&lt;br&gt;
-The Number of the first PatientNumber in the SDA with NumberType="MRN" as the MRN&lt;br&gt;
-The SDA FromTime as as the admit date&lt;br&gt;
If no EncounterNumber can be generated, an error will be logged and the&lt;br&gt;
Encounter will not be processed.&lt;br&gt;
In the EncounterActions method, after OnBeforeMatch is called, if the&lt;br&gt;
Streamlet (not SDA) EncounterNumber is null, an error will be logged and&lt;br&gt;
the Encounter will not be processed.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMADMNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="AdmissionType" type="AdmissionType">
            <s:annotation>
                <s:documentation>Type of admission: Accident/Newborn/Elective etc.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PV1-4 will be parsed as the AdmissionType Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
HL7:  PV1-4 : AdmissionType&lt;br&gt;
SDATableName=AdmissionType, ViewerClass=User.HS.PACInPatAdmissionType&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMInPatAdmTypeDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterType" type="s:string">
            <s:annotation>
                <s:documentation>Type of encounter&lt;br&gt;
See also the &lt;property&gt;EncounterCodedType&lt;/property&gt; property&lt;br&gt;
Supported values:&lt;br&gt;
E = Emergency&lt;br&gt;
I = Inpatient&lt;br&gt;
O = Outpatient&lt;br&gt;
C = Community&lt;br&gt;
N = Not Applicable (HL7) or New Born (Viewer Cache)&lt;br&gt;
P = Pre-admit&lt;br&gt;
G = Generated&lt;br&gt;
S = Silent&lt;br&gt;&lt;br&gt;
In the Clinical Viewer, Generated encounters do not appear on the encounter&lt;br&gt;
timeline but do appear on the Encounters chart. The data within them is&lt;br&gt;
selected unless "Deselect All" is clicked. Silent encounters do not appear&lt;br&gt;
on the encounter timeline or the Encounters chart, and the data within them&lt;br&gt;
is always selected. Also, if a patient's SDA contains data that is not&lt;br&gt;
connected to an Encounter but is "Encounter-level" in the Viewer Cache,&lt;br&gt;
HealthShare will connect that data to the patient's silent encounter in the&lt;br&gt;
Viewer Cache only. If the patient does not have a silent encounter in their&lt;br&gt;
SDA, HealthShare will create one in the Viewer Cache only.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if the EncounterType is&lt;br&gt;
"P", it will be mapped to "I". In the OnValidate method, if EncounterType&lt;br&gt;
is null, it will be defaulted to "O". Any other invalid values will &lt;br&gt;
generate an Alert and be defaulted to "O".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Any value that is not E, I, O, N, G, P, S, or C gets defaulted to "O". The&lt;br&gt;
value that appears in the Viewer does not come from the DISPLAYLIST of the&lt;br&gt;
PAADMType property, but rather the Description for the corresponding&lt;br&gt;
AdmType Standard Type Item.  See the HS documentation for guidance on&lt;br&gt;
configuring this. Note that by default there are only entries for codes&lt;br&gt;
"I", "O", and "E", and in starting in HSVIEWER 15.03, "C". See the Clinical&lt;br&gt;
Viewer documentation for instructions on adding "C" to versions prior to&lt;br&gt;
15.03. &lt;br&gt;&lt;br&gt;
HL7:  PV1-2 : PatientClass&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMType)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterCodedType" type="EncounterType">
            <s:annotation>
                <s:documentation>EncounterCodedType is used to allow SDA3 to support encounter type codes&lt;br&gt;
beyond those that are permitted for the &lt;property&gt;EncounterType&lt;/property&gt; property. However,&lt;br&gt;
EncounterCodedType is not parsed from HL7 and is not used or stored in the&lt;br&gt;
Viewer Cache. Ideally, if EncounterCodedType is used, then a mapping should&lt;br&gt;
be defined of EncounterCodedType values to EncounterType values, and&lt;br&gt;
EncounterType set whenever possible.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AdmittingClinician" type="CareProvider">
            <s:annotation>
                <s:documentation>Clinician who admitted the patient in this encounter&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though PV1-17 is a repeating field, HL7ToSDA3 will only use the first&lt;br&gt;
instance.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if AdmittingClinician is&lt;br&gt;
null, it will be defaulted to the first ConsultingClinician with a Code or&lt;br&gt;
Description, if there is one.&lt;br&gt;&lt;br&gt;
HL7:  PV1-17 : AdmittingDoctor&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMAdmDocCodeDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PV1-17.1 : AdmittingDoctor.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  PV1-17.2.1 : AdmittingDoctor.FamilyName.Surname&lt;br&gt;
HL7:  PV1-17.3 : AdmittingDoctor.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PV1-17.9 : AdmittingDoctor.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  PV1-17.2.1 : AdmittingDoctor.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  PV1-17.3 : AdmittingDoctor.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  PV1-17.4 : AdmittingDoctor.SecondandFurtherGivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  PV1-17.6 : AdmittingDoctor.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  PV1-17.7 : AdmittingDoctor.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AttendingClinicians" type="ArrayOfCareProvider">
            <s:annotation>
                <s:documentation>List of clinicians who attended to the patient during this encounter&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the first AttendingClinician in the list is included in the patient's&lt;br&gt;
record in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-7 : AttendingDoctor&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMTreatingDrDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PV1-7.1 : AttendingDoctor.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  PV1-7.2.1 : AttendingDoctor.FamilyName.Surname&lt;br&gt;
HL7:  PV1-7.3 : AttendingDoctor.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PV1-7.9 : AttendingDoctor.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  PV1-7.2.1 : AttendingDoctor.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  PV1-7.3 : AttendingDoctor.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  PV1-7.4 : AttendingDoctor.SecondandFurtherGivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  PV1-7.6 : AttendingDoctor.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  PV1-7.7 : AttendingDoctor.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConsultingClinicians" type="ArrayOfCareProvider">
            <s:annotation>
                <s:documentation>List of clinicians who consulted during this encounter&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if AdmittingClinician is&lt;br&gt;
null, it will be defaulted to the first ConsultingClinician, if there is&lt;br&gt;
one.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the first ConsultingClinician in the list is included in the patient's&lt;br&gt;
record in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-9 : ConsultingDoctor&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMInternalrefDocDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PV1-9.1 : ConsultingDoctor.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  PV1-9.2.1 : ConsultingDoctor.FamilyName.Surname&lt;br&gt;
HL7:  PV1-9.3 : ConsultingDoctor.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PV1-9.9 : ConsultingDoctor.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  PV1-9.2.1 : ConsultingDoctor.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  PV1-9.3 : ConsultingDoctor.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  PV1-9.4 : ConsultingDoctor.SecondandFurtherGivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  PV1-9.6 : ConsultingDoctor.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  PV1-9.7 : ConsultingDoctor.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReferringClinician" type="ReferralDoctor">
            <s:annotation>
                <s:documentation>Clinician who made the referral for this encounter&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though PV1-8 is a repeating field, HL7ToSDA3 will only use the first&lt;br&gt;
instance.&lt;br&gt;&lt;br&gt;
HL7:  PV1-8 : ReferringDoctor&lt;br&gt;
SDATableName=ReferralDoctor, ViewerClass=User.HS.PACRefDoctor&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMRefDocListDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PV1-8.1 : ReferringDoctor.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  PV1-8.2.1 : ReferringDoctor.FamilyName.Surname&lt;br&gt;
HL7:  PV1-8.3 : ReferringDoctor.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PV1-8.9 : ReferringDoctor.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  PV1-8.2.1 : PACRefDoctor.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDFamilyName)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  PV1-8.3 : ReferringDoctor.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDForename)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  PV1-8.4 : ReferringDoctor.SecondandFurtherGivenName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDMiddleName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  PV1-8.6 : ReferringDoctor.Prefix&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  PV1-8.7 : ReferringDoctor.Degree&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AccountNumber">
            <s:annotation>
                <s:documentation>Patient account number&lt;br&gt;&lt;br&gt;
HL7:  PID-18.1 : PatientAccountNumber.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMAdmRef)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorVisitNumber">
            <s:annotation>
                <s:documentation>If the EncounterNumber of this Encounter was changed or if another&lt;br&gt;
Encounter was merged into this one, this is the old/other EncounterNumber.&lt;br&gt;
See the chapter "Correcting Patient Records" in the book "Data Flow and&lt;br&gt;
Message Processing" in the HS documentation for more info.&lt;br&gt;&lt;br&gt;
HL7:  MRG-5 : PriorVisitNumber&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PreAdmissionNumber">
            <s:annotation>
                <s:documentation>A number given to the patient prior to being admitted but while information&lt;br&gt;
is being gathered&lt;br&gt;&lt;br&gt;
HL7:  PV1-5.1 : PreadmitNumber.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMPreAdmNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="AdmissionSource" type="AdmissionSource">
            <s:annotation>
                <s:documentation>Code for source of admission (e.g. referral, accident, walk-in)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PV1-14 will be parsed as the AdmissionSource Code. HL7ToSDA3 does not set&lt;br&gt;
the Description.&lt;br&gt;&lt;br&gt;
HL7:  PV1-14 : AdmitSource&lt;br&gt;
SDATableName=AdmissionSource, ViewerClass=User.HS.PACAdmSource&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMAdmSrcDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AssignedWard" type="s:string">
            <s:annotation>
                <s:documentation>Last Reported Ward code&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
AssignedRoom and AssignedBed require an AssignedWard to be stored in the&lt;br&gt;
Streamlet Cache. In the OnBeforeMatch method of the Streamlet class, if&lt;br&gt;
either AssignedRoom or AssignedBed are not null and AssignedWard is null,&lt;br&gt;
an alert will be logged and AssignedRoom and AssignedBed set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
AssignedWard will be processed into the Viewer Cache as a PACWard code&lt;br&gt;
table entry with both WARDCode and WARDDesc = AssignedWard. Because a ward&lt;br&gt;
"belongs to" a healthcare facility in the Viewer Cache, a valid&lt;br&gt;
HealthCareFacility on the Encounter is required to process AssignedWard.&lt;br&gt;&lt;br&gt;
HL7:  PV1-3.1 : AssignedPatientLocation.PointOfCare&lt;br&gt;
SDATableName=Ward, ViewerClass=User.HS.PACWard&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMCurrentWardDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AssignedRoom" type="s:string">
            <s:annotation>
                <s:documentation>Last Reported Room code&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
AssignedRoom and AssignedBed require an AssignedWard to be stored in the&lt;br&gt;
Streamlet Cache. In the OnBeforeMatch method of the Streamlet class, if&lt;br&gt;
either AssignedRoom or AssignedBed are not null and AssignedWard is null,&lt;br&gt;
an alert will be logged and AssignedRoom and AssignedBed set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
AssignedRoom will be processed into the Viewer Cache as a PACRoom code&lt;br&gt;
table entry with ROOMDesc=AssignedWard and ROOMCode=[a unique value&lt;br&gt;
computed internally]. Because a room "belongs to" a ward in the Viewer&lt;br&gt;
Cache, a valid AssignedWard on the Encounter is required to process&lt;br&gt;
AssignedRoom.&lt;br&gt;&lt;br&gt;
HL7:  PV1-3.2 : AssignedPatientLocation.Room&lt;br&gt;
SDATableName=Room, ViewerClass=User.HS.PACRoom&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMCurrentRoomDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AssignedBed" type="s:string">
            <s:annotation>
                <s:documentation>Last Reported Bed code&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
AssignedRoom and AssignedBed require an AssignedWard to be stored in the&lt;br&gt;
Streamlet Cache. In the OnBeforeMatch method of the Streamlet class, if&lt;br&gt;
either AssignedRoom or AssignedBed are not null and AssignedWard is null,&lt;br&gt;
an alert will be logged and AssignedRoom and AssignedBed set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
AssignedBed will be processed into the Viewer Cache as a PACBed code table&lt;br&gt;
entry with BEDCode=AssignedBed. PACBed has no description field. Because a&lt;br&gt;
bed "belongs to" a ward in the Viewer Cache, a valid AssignedWard on the&lt;br&gt;
Encounter is required to process AssignedBed. If the SDA also contains an&lt;br&gt;
AssignedRoom, the AssignedBed will be linked to that in the Viewer Cache as&lt;br&gt;
well.&lt;br&gt;&lt;br&gt;
HL7:  PV1-3.3 : AssignedPatientLocation.Bed&lt;br&gt;
SDATableName=Bed, ViewerClass=User.HS.PACBed&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMCurrentBedDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PriorWard" type="s:string">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PriorRoom" type="s:string">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PriorBed" type="s:string">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AdmitReason" type="AdmitReason">
            <s:annotation>
                <s:documentation>Code for reason for admission&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PV2-3 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  PV2-3 : AdmitReason&lt;br&gt;
SDATableName=AdmitReason, ViewerClass=User.HS.PACAdmCategory&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMAdmCategDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PV2-3.1 : AdmitReason.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PACAdmCategory(ADMCATCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PV2-3.2 : AdmitReason.Text&lt;br&gt;
VIEWERLIB: User.HS.PACAdmCategory(ADMCATDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PV2-3.3 : AdmitReason.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="HealthCareFacility" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
PV1-10 will be parsed as the HealthCareFacility Code. HL7ToSDA3 does not&lt;br&gt;
set the Description.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If the Encounter has no HealthCareFacility, one will be defaulted with Code&lt;br&gt;
and Organization.Code = SendingFacility of the SDA Container. On the&lt;br&gt;
Edge, this happens in the EncounterActions method of the Streamlet class.&lt;br&gt;
On the Access Gateway, this happens in the EPRFetchNotification method of&lt;br&gt;
HS.Gateway.Access.Manager. On the Access Gateway, if the Container&lt;br&gt;
SendingFacility is null, the Facility property of the EPRFetchNotification&lt;br&gt;
is used instead.&lt;br&gt;&lt;br&gt;
HL7:  PV1-10 : HospitalService&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMDepCodeDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MSH-4.1 will be parsed as the Organization Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DischargeLocation" type="DischargeLocation">
            <s:annotation>
                <s:documentation>Discharged-to Location&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PV1-37.1 is parsed as the DischargeLocation Code.  HL7ToSDA3 does not set&lt;br&gt;
the Description.&lt;br&gt;&lt;br&gt;
HL7:  PV1-37.1 : DischargedtoLocation.DischargeLocation&lt;br&gt;
SDATableName = DischargeLocation, ViewerClass=User.HS.PACDischargeDestination&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMMainMRADMDR)-&gt;User.HS.MRAdm(MRADMDischDestinDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VisitDescription" type="s:string">
            <s:annotation>
                <s:documentation>Description of visit&lt;br&gt;&lt;br&gt;
HL7:  PV2-12 : VisitDescription&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMRemark)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterMRN" type="s:string">
            <s:annotation>
                <s:documentation>The number part of the patient MRN under which this Encounter was&lt;br&gt;
last updated. This is needed at the Access Gateway, where Encounters from&lt;br&gt;
multiple sources (and probably multiple MRNs) can be aggregated into a&lt;br&gt;
single patient record.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the EncounterActions method of the Streamlet class, EncounterMRN is set&lt;br&gt;
to the Number of the Patient's first PatientNumber with NumberType="MRN".&lt;br&gt;
Note that this only happens on the Edge, not at the Access Gateway.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMEncounterMRN)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterMRNAA" type="s:string">
            <s:annotation>
                <s:documentation>Assigning Authority of the EncounterMRN
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Guarantors" type="ArrayOfGuarantor">
            <s:annotation>
                <s:documentation>List of guarantors for this patient.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="HealthFunds" type="ArrayOfHealthFund">
            <s:annotation>
                <s:documentation>List of health funds associated with encounter&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if one of the&lt;br&gt;
HS.SDA3.HealthFunds does not have a HealthFund CodeTableDetail, or if it&lt;br&gt;
has one but the Code and Description are null, then an alert will be logged&lt;br&gt;
and the HS.SDA3.HealthFund will be removed from the list.&lt;br&gt;&lt;br&gt;
HL7:  IN1&lt;br&gt;
VIEWERLIB: see HS.SDA3.HealthFund</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EndTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>When storing SDA as streamlets, EndTime is not intended to come from the&lt;br&gt;
data provider, but rather is calculated from other fields.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, the value of EndTime is&lt;br&gt;
calculated as:&lt;br&gt;
-If ToTime is not null, ToTime&lt;br&gt;
-Else if EncounterType="I", two double quotes (the delete instruction)&lt;br&gt;
-Else, FromTime.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
EndTime itself is not stored in the Viewer Cache, but the value of&lt;br&gt;
PAADMVisitStatus is derived from it: "D" if EndTime is not null, and "A"&lt;br&gt;
otherwise. Also, the value that appears in the Viewer does not come from&lt;br&gt;
the DISPLAYLIST of the PAADMVisitStatus property, but rather the&lt;br&gt;
Description of the corresponding AdmStatus Standard Type Item.  See the HS&lt;br&gt;
documentation for guidance on configuring this.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMVisitStatus)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SeparationMode" type="SeparationMode">
            <s:annotation>
                <s:documentation>The conditions under which the patient was discharged&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PV1-36 is parsed as the SeparationMode Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
HL7:  PV1-36 : DischargeDisposition&lt;br&gt;
SDATableName=SeparationMode, ViewerClass=None&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Specialties" type="ArrayOfCareProviderType">
            <s:annotation>
                <s:documentation>The clinical specialties under which the patient was treated during this&lt;br&gt;
Encounter&lt;br&gt;&lt;br&gt;
SDATableName=CareProviderType, ViewerClass=User.HS.CTCarPrvTp&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RecommendationsProvided" type="ArrayOfRecommendation">
            <s:annotation>
                <s:documentation>The recommendations for this patient forwarded to the specificied providers&lt;br&gt;
and organizations on discharge.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExpectedAdmitTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The time that the patient is expected to be admitted&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExpectedDischargeTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The time that the patient is expected to be discharged&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PublicityCode" type="PublicityCode">
            <s:annotation>
                <s:documentation>What level of publicity is allowed for this visit (Family only, No&lt;br&gt;
publicity, etc.)&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Priority" type="EncounterPriority">
            <s:annotation>
                <s:documentation>The priority of this visit (Emergency, Urgent, Elective, etc.)&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExpectedLOAReturnTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The patient's expected return time, if the patient takes a leave of absence&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DiagnosisRelatedGroup" type="DiagnosisRelatedGroup">
            <s:annotation>
                <s:documentation>The diagnosis-related group (DRG) for this visit.&lt;br&gt;&lt;br&gt;
HL7:  DRG-1 : DiagnosisRelatedGroup&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="TransferredFromED" type="Boolean">
            <s:annotation>
                <s:documentation>Whether this Encounter began in the Emergency Department before being&lt;br&gt;
transferred to the Inpatient Department.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
This property is set to 1 automatically when an EncounterType of "E"&lt;br&gt;
is changed to "I". This happens in the OnBeforeUpdateSDAEncounterType&lt;br&gt;
method, called before an inbound SDA updates a matching existing SDA.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EmergencyAdmitDateTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>If this Encounter began in the Emergency Department before being&lt;br&gt;
transferred to the Inpatient Department, this property reflects the&lt;br&gt;
original admit time to the Emergency Department, while the FromTime should&lt;br&gt;
be the time the patient was admitted to the Inpatient Department.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
This property is automatically set to the original FromTime of the&lt;br&gt;
Encounter when EncounterType changes from "E" to "I". This happens in the&lt;br&gt;
OnBeforeUpdateSDAEncounterType method, called before an inbound SDA updates&lt;br&gt;
a matching existing SDA.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete this Encounter and any other Streamlets linked to it via EncounterNumber&lt;br&gt;
E = Delete this Encounter only if no other Streamlets are linked to it via EncounterNumber&lt;br&gt;
C = Clear all Encounters for this Patient and any other Streamlets linked to them via EncounterNumber&lt;br&gt;
R = Replace (First delete existing Encounter, then insert given Encounter)&lt;br&gt;
Any other value = Add or Update&lt;br&gt;&lt;br&gt;
For ActionCode="R", any Streamlets linked to the original Encounter will&lt;br&gt;
also be deleted unless there are matching Streamlets in the inbound SDA.&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though EVN-5 is a repeating field, HL7ToSDA3 will only use the first&lt;br&gt;
instance.&lt;br&gt;&lt;br&gt;
HL7:  EVN-5 : OperatorID&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMUpdateUserDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  EVN-5.1 : OperatorID.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  EVN-5.2.1 : OperatorID.FamilyName.Surname&lt;br&gt;
HL7:  EVN-5.3 : OperatorID.GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  EVN-5.9 : OperatorID.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
MSH-4.1 is parsed as the EnteredAt Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMUpdateUserHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7:  PV1-44.1 : AdmitDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMUpdateDate) + User.HS.PAAdm(PAADMUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time that the encounter started&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if FromTime is null, it is&lt;br&gt;
defaulted to the current date/time.&lt;br&gt;&lt;br&gt;
HL7:  PV1-44.1 : AdmitDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMAdmDate) + User.HS.PAAdm(PAADMAdmTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time that the encounter ended&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though PV1-45 is a repeating field, HL7ToSDA3 will only use the first&lt;br&gt;
instance.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If the EventDescription of the SDA Container is "ADT_A13" (Cancel&lt;br&gt;
discharge), then in the EncounterActions method of the Streamlet class&lt;br&gt;
(called on the Edge only), ToTime will be set to the delete instruction&lt;br&gt;
(two double quotes).&lt;br&gt;&lt;br&gt;
HL7:  PV1-45.1 : DischargeDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMDischgDate) + User.HS.PAAdm(PAADMDischgTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if the EncounterNumber&lt;br&gt;
is initially null, it will be defaulted to the ExternalId.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAdm(PAADMRefApprovNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="EncounterExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AdmissionType">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AdmissionTypeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACInPatAdmissionType(IPATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACInPatAdmissionType(IPATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AdmissionTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="EncounterType">
    <s:annotation>
        <s:documentation>HS.SDA3.CodeTableDetail.EncounterType appears in the SDA3 as the&lt;br&gt;
EncounterCodedType property of &lt;class&gt;HS.SDA3.Encounter&lt;/class&gt;. This should not be&lt;br&gt;
confused with the EncounterType property, which is a %String.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="EncounterTypeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="EncounterTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfCareProvider">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="CareProvider" nillable="true" type="CareProvider"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ReferralDoctor">
    <s:annotation>
        <s:documentation>In the Viewer Cache, ReferralDoctors are matched on Code and&lt;br&gt;
SDACodingStandard only. Other properties stored in the Viewer Cache,&lt;br&gt;
including Description, will be updated if they are different in the inbound&lt;br&gt;
ReferralDoctor versus the matched PACRefDoctor.&lt;br&gt;&lt;br&gt;
Note that both ReferralDoctor and FamilyDoctor CodeTableDetails populate&lt;br&gt;
the PACRefDoctor table in the Viewer Cache.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ReferralDoctorExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACRefDoctor(REFDCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACRefDoctor(REFDDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Name" type="Name">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
If the inbound ReferralDoctor matches a PACRefDoctor on Code and&lt;br&gt;
SDACodingStandard, then if the ReferralDoctor has a Name defined and&lt;br&gt;
FamilyName, GivenName, MiddleName, and NamePrefix are not all null, then&lt;br&gt;
they will be compared to the corresponding properties of the matched&lt;br&gt;
PACRefDoctor. If any property does not match, then the PACRefDoctor is&lt;br&gt;
determined to need an update (of all properties, not just the mismatched&lt;br&gt;
property).&lt;br&gt;
If the matched PACRefDoctor is determined to need an update, then if the&lt;br&gt;
ReferralDoctor has a Name defined, then FamilyName, GivenName, MiddleName,&lt;br&gt;
and NamePrefix are all inserted into the Viewer Cache, even if any of them&lt;br&gt;
are null, and even if they overwrite non-null values.&lt;br&gt;&lt;br&gt;
.FamilyName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDFamilyName)&lt;br&gt;
.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDForename)&lt;br&gt;
.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDMiddleName)&lt;br&gt;
.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.PACRefDoctor(REFDTitle)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Address" type="Address">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactInfo" type="ContactInfo">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ReferralDoctorExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AdmissionSource">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AdmissionSourceExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAdmSource(ADSOUCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAdmSource(ADSOUDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AdmissionSourceExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AdmitReason">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AdmitReasonExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAdmCategory(ADMCATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAdmCategory(ADMCATDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AdmitReasonExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="HealthCareFacility">
    <s:annotation>
        <s:documentation>The Viewer Cache table for HealthCareFacility, CTLoc, is not constrained to&lt;br&gt;
have unique Codes or Descriptions. HealthCareFacilities are matched in the&lt;br&gt;
Viewer Cache on Code, SDACodingStandard, and Organization.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="HealthCareFacilityExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTLoc(CTLOCCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTLoc(CTLOCDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Organization" type="Organization">
            <s:annotation>
                <s:documentation>Organization to which the facility belongs&lt;br&gt;
The Code for HealthCareFacility is only unique within an Organization, so&lt;br&gt;
there can be, for example, "LAB" at two different hospitals&lt;br&gt;
(Organizations).&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the HealthCareFacility has no Organization, one is defaulted in with&lt;br&gt;
Code = [SendingFacility of the SDA Container]. This is done before&lt;br&gt;
matching, so the Organization used for matching may be defaulted.&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="LocationType">
            <s:annotation>
                <s:documentation>Type of location (e.g. Clinic, ER, Department, Ward, Other)&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:enumeration value="CLINIC"/>
                    <s:enumeration value="ER"/>
                    <s:enumeration value="DEPARTMENT"/>
                    <s:enumeration value="WARD"/>
                    <s:enumeration value="OTHER"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="HealthCareFacilityExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DischargeLocation">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DischargeLocationExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACDischargeDestination(DDESTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACDischargeDestination(DDESTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DischargeLocationExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfGuarantor">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Guarantor" nillable="true" type="Guarantor"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Guarantor">
    <s:annotation>
        <s:documentation>Guarantor appears on three places in the SDA: first, as a list property of&lt;br&gt;
HS.SDA3.Encounter. Guarantor also appears as a property &lt;br&gt;
of HS.SDA3.MemberEnrollment.  Both of these are supported and may be used.&lt;br&gt;
It also appears as a list property of HS.SDA3.Container; &lt;br&gt;
however, this property is only present for historical reasons and&lt;br&gt;
should not be used.&lt;br&gt;&lt;br&gt;
Note that while this class does contain HL7 annotations, Guarantor is not&lt;br&gt;
parsed from HL7. The annotations are left in for historical reasons. The&lt;br&gt;
HealthShare HL7 Annotations do not contain the annotations from this class.&lt;br&gt;&lt;br&gt;
Guarantor is not loaded into the Viewer Cache.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Message action code&lt;br&gt;
Case-sensitive&lt;br&gt;
Supported values include:&lt;br&gt;
D = Delete&lt;br&gt;
E = Delete if empty (Encounters only)&lt;br&gt;
I = Inactivate all&lt;br&gt;
C = Clear/Delete all&lt;br&gt;
R = Replace (Patient and Encounter only)&lt;br&gt;
Any other value = Add or Update&lt;br&gt;&lt;br&gt;
ActionCode is only supported for SDA3 classes corresponding to Streamlet&lt;br&gt;
types (Allergy, Diagnosis, etc.). Not all of the above codes are supported&lt;br&gt;
for every class. Whether ActionCode is supported and what codes are&lt;br&gt;
supported is documented in each individual subclass. For codes "C" and "I",&lt;br&gt;
all streamlets of the given type belonging to the given Patient and in the&lt;br&gt;
given Encounter (or Encounter-less if the inbound SDA object has no&lt;br&gt;
EncounterNumber) will be cleared or inactivated. Otherwise (codes "D", "E",&lt;br&gt;
"R") only the matching streamlet will be affected.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time updated or entered.  For labs, this represents when the order was&lt;br&gt;
placed.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="GuarantorExtension"/>
        <s:element minOccurs="0" name="Name" type="Name">
            <s:annotation>
                <s:documentation>Primary name for this person (e.g. legal name)&lt;br&gt;&lt;br&gt;
HL7:  GT1-3 : GuarantorName&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.FamilyName&lt;br&gt;
HL7:  GT1-3.1.1 : FamilyNameSurname&lt;br&gt;
.FamilyNamePrefix&lt;br&gt;
HL7:  GT1-3.1.2 : FamilyNameOwnSurnamePrefix&lt;br&gt;
.GivenName&lt;br&gt;
HL7:  GT1-3.2 : GivenName&lt;br&gt;
.MiddleName&lt;br&gt;
HL7:  GT1-3.3 : SecondandFurtherGivenNames&lt;br&gt;
.NameSuffix&lt;br&gt;
HL7:  GT1-3.4 : Suffix&lt;br&gt;
.NamePrefix&lt;br&gt;
HL7:  GT1-3.5 : Prefix&lt;br&gt;
.ProfessionalSuffix&lt;br&gt;
HL7:  GT1-3.14 : ProfessionalSuffix&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Address" type="Address">
            <s:annotation>
                <s:documentation>HL7:  GT1-5 : GuarantorAddress&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Street&lt;br&gt;
HL7:  GT1-5.1.1 : StreetAddressStreetorMailingAddress&lt;br&gt;
HL7:  GT1-5.2 : OtherDesignation&lt;br&gt;
.City&lt;br&gt;
HL7:  GT1-5.3 : City&lt;br&gt;
.State&lt;br&gt;
HL7:  GT1-5.4 : StateorProvince&lt;br&gt;
.Zip&lt;br&gt;
HL7:  GT1-5.5 : ZiporPostalCode&lt;br&gt;
.Country&lt;br&gt;
HL7:  GT1-5.6 : Country&lt;br&gt;
.County&lt;br&gt;
HL7:  GT1-5.9 : CountyParishCode&lt;br&gt;
.StartDate&lt;br&gt;
HL7:  GT1-5.13.1 : EffectiveDateTime&lt;br&gt;
.EndDate&lt;br&gt;
HL7:  GT1-5.14.1 : ExpirationDateTime&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactInfo" type="ContactInfo">
            <s:annotation>
                <s:documentation>Contact information for the Guarantor&lt;br&gt;&lt;br&gt;
HL7:  GT1-6 : GuarantorPhNumHome&lt;br&gt;
HL7:  GT1-7 : GuarantorPhNumBusiness&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.HomePhoneNumber&lt;br&gt;
HL7:  GT1-6 : GuarantorPhNumHome&lt;br&gt;
.WorkPhoneNumber&lt;br&gt;
HL7:  GT1-7 : GuarantorPhNumBusiness&lt;br&gt;
.MobilePhoneNumber&lt;br&gt;
HL7:  GT1-6 : GuarantorPhNumHome&lt;br&gt;
HL7:  GT1-7 : GuarantorPhNumBusiness&lt;br&gt;
.EmailAddress&lt;br&gt;
HL7:  GT1-6 : GuarantorPhNumHome&lt;br&gt;
HL7:  GT1-7 : GuarantorPhNumBusiness&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="BirthTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date and time of birth of the guarantor&lt;br&gt;&lt;br&gt;
HL7: GT1-8.1 : GuarantorDateTimeOfBirth.Time&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Gender" type="Gender">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though GT1-9 is not a coded element type of field, HL7ToSDA3 still only&lt;br&gt;
parses the first piece with respect to the Component Separator. This is&lt;br&gt;
parsed to the to the Gender Code. HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
HL7:  GT1-9 : GuarantorAdministrativeSex&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Relationship" type="Relationship">
            <s:annotation>
                <s:documentation>Relationship code of the guarantor&lt;br&gt;&lt;br&gt;
HL7:  GT1-11 : GuarantorRelationship&lt;br&gt;
SDATableName=Relationship, ViewerClass=None&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GuarantorType">
            <s:annotation>
                <s:documentation>Employer, Self, Family, Friend, etc.&lt;br&gt;&lt;br&gt;
HL7:  GT1-10 : GuarantorType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="GuarantorNumber" type="PatientNumber">
            <s:annotation>
                <s:documentation>HL7:  GT1-2  : GuarantorNumber&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Number&lt;br&gt;
HL7:  GT1-2.1 : IDNumber&lt;br&gt;
.Organization&lt;br&gt;
The Assigning Authority for the number&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
HL7:  GT1-2.4.1 : AssigningAuthorityNamespaceID&lt;br&gt;
HL7:  MSH-4 : SendingFacility&lt;br&gt;
.NumberType&lt;br&gt;
HL7:  GT1-2.5 : IdentifierTypeCode</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SSN">
            <s:annotation>
                <s:documentation>HL7:  GT1-12 : GuarantorSSN&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Effective start date for this guarantor&lt;br&gt;&lt;br&gt;
HL7:  GT1-13 : GuarantorDateBegin&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Effective end date for this guarantor&lt;br&gt;&lt;br&gt;
HL7:  GT1-14 : GuarantorDateEnd&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EmployerName" type="Name">
            <s:annotation>
                <s:documentation>The name of the guarantor's employer, if the employer is a person&lt;br&gt;&lt;br&gt;
HL7:  GT1-16 : GuarantorEmployerName&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EmployerAddress" type="Address">
            <s:annotation>
                <s:documentation>HL7:  GT1-17 : GuarantorEmployerAddress&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Street&lt;br&gt;
HL7:  GT1-17.1.1 : StreetAddressStreetorMailingAddress&lt;br&gt;
HL7:  GT1-17.2 : OtherDesignation&lt;br&gt;
.City&lt;br&gt;
HL7:  GT1-17.3 : City&lt;br&gt;
.State&lt;br&gt;
HL7:  GT1-17.4 : StateorProvince&lt;br&gt;
.Zip&lt;br&gt;
HL7:  GT1-17.5 : ZiporPostalCode&lt;br&gt;
.Country&lt;br&gt;
HL7:  GT1-17.6 : Country&lt;br&gt;
.County&lt;br&gt;
HL7:  GT1-17.9 : CountyParishCode&lt;br&gt;
.StartDate&lt;br&gt;
HL7:  GT1-17.13.1 : EffectiveDateTime&lt;br&gt;
.EndDate&lt;br&gt;
HL7:  GT1-17.14.1 : ExpirationDateTime&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EmployerOrganizationName">
            <s:annotation>
                <s:documentation>The name of the guarantor's employer, if the employer is an organization&lt;br&gt;&lt;br&gt;
HL7:  GT1-51 : GuarantorEmployerOrganizationName&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="300"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EmployerPhoneNumber">
            <s:annotation>
                <s:documentation>HL7:  GT1-18 : GuarantorEmployerPhoneNumber&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="60"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EmploymentStatusCode" type="EmploymentStatusCode">
            <s:annotation>
                <s:documentation>HL7:  GT1-20 : GuarantorEmploymentStatusCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EmployerID">
            <s:annotation>
                <s:documentation>The guarantor's employer's ID number&lt;br&gt;&lt;br&gt;
HL7:  GT1-29.1 : GuarantorEmployerID.IDNumber&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="HireEffectiveDate" type="TimeStamp">
            <s:annotation>
                <s:documentation>The date when the guarantor was hired&lt;br&gt;&lt;br&gt;
HL7:  GT1-31 : GuarantorHireEffectiveDate&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EmploymentStopDate" type="TimeStamp">
            <s:annotation>
                <s:documentation>The date when the guarantor's employment ended&lt;br&gt;&lt;br&gt;
HL7:  GT1-32 : GuarantorEmploymentStopDate&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="JobTitle" type="s:string">
            <s:annotation>
                <s:documentation>The guarantor's job title&lt;br&gt;&lt;br&gt;
HL7:  GT1-49 : GuarantorJobTitle&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Occupation" type="Occupation">
            <s:annotation>
                <s:documentation>The guarantor's occupation&lt;br&gt;&lt;br&gt;
HL7:  GT1-50 : GuarantorOccupation&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="GuarantorExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="EmploymentStatusCode">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="EmploymentStatusCodeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="EmploymentStatusCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfHealthFund">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="HealthFund" nillable="true" type="HealthFund"/>
    </s:sequence>
</s:complexType>
<s:complexType name="HealthFund">
    <s:annotation>
        <s:documentation>HS.SDA3.HealthFund corresponds to the CDA Payers section.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="HealthFundExtension"/>
        <s:element minOccurs="0" name="HealthFund" type="HealthFundCode">
            <s:annotation>
                <s:documentation>Code for health fund that provides the insurance&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If both IN1-3.1 and -4.1 are null, the IN1 segment will not be processed.&lt;br&gt;&lt;br&gt;
SDATableName=HealthFund, ViewerClass=User.HS.ARCInsuranceType&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSInsTypeDR)&lt;br&gt;&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  IN1-3.4 : InsuranceCompanyID.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Code&lt;br&gt;
HL7:  IN1-3.1 : InsuranceCompanyID.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.ARCInsuranceType(INSTCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  IN1-4.1 : InsuranceCompanyName.OrganizationName&lt;br&gt;
VIEWERLIB: User.HS.ARCInsuranceType(INSTDesc)&lt;br&gt;&lt;br&gt;
.Address&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though IN1-5 is a repeating field, HL7ToSDA3 only uses the first instance.&lt;br&gt;
Also, only a Code is parsed for the City, State, Zip, Country, and County&lt;br&gt;
properties.  HL7ToSDA3 does not set a Description for these.&lt;br&gt;
HL7:  IN1-5 : InsuranceCompanyAddress&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Street is parsed as: "[IN1-5.1.1]; [IN1-5.2]"&lt;br&gt;
HL7:  IN1-5.1.1 : InsuranceCompanyAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  IN1-5.2 : InsuranceCompanyAddress.OtherDesignation&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  IN1-5.3 : InsuranceCompanyAddress.City&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  IN1-5.4 : InsuranceCompanyAddress.StateorProvince&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  IN1-5.5 : InsuranceCompanyAddress.ZiporPostalCode&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  IN1-5.6 : InsuranceCompanyAddress.Country&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  IN1-5.9 : InsuranceCompanyAddress.CountyParishCode&lt;br&gt;
.Address.FromTime&lt;br&gt;
HL7:  IN1-5.13.1 : InsuranceCompanyAddress.EffectiveDate.Time&lt;br&gt;
.Address.ToTime&lt;br&gt;
HL7:  IN1-5.14.1 : InsuranceCompanyAddress.ExpirationDate.Time&lt;br&gt;
.ContactPerson&lt;br&gt;
HL7:  IN1-6 : InsuranceCoContactPerson&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ContactPerson.FamilyName&lt;br&gt;
HL7:  IN1-6.1.1 : FamilyName.Surname&lt;br&gt;
.ContactPerson.FamilyNamePrefix&lt;br&gt;
HL7:  IN1-6.1.2 : FamilyName.OwnSurnamePrefix&lt;br&gt;
.ContactPerson.GivenName&lt;br&gt;
HL7:  IN1-6.2 : GivenName&lt;br&gt;
.ContactPerson.MiddleName&lt;br&gt;
HL7:  IN1-6.3 : SecondandFurtherGivenNames&lt;br&gt;
.ContactPerson.NameSuffix&lt;br&gt;
HL7:  IN1-6.4 : Suffix&lt;br&gt;
.ContactPerson.NamePrefix&lt;br&gt;
HL7:  IN1-6.5 : Prefix&lt;br&gt;
.ContactPerson.ProfessionalSuffix&lt;br&gt;
HL7:  IN1-6.14 : ProfessionalSuffix&lt;br&gt;&lt;br&gt;
.ContactInfo&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
IN1-7 is a repeating field, and each instance may populate WorkPhoneNumber,&lt;br&gt;
MobilePhoneNumber, or EmailAddress, depending on the values contained&lt;br&gt;
therein. For each instance of IN1-7, the algorithm to parse a phone number&lt;br&gt;
out of that instance is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else continue to the next instance of this field.&lt;br&gt;&lt;br&gt;
-Whichever number is parsed, if subfield 9 of that instance is not null, it&lt;br&gt;
will be appended to the number, delimited by a semicolon.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;
HL7:  IN1-7 : InsuranceCoPhoneNumber&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ContactInfo.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
WorkPhoneNumber is parsed from the first instance of IN1-7 with subfield 2&lt;br&gt;
in ["",WPN,ASN,EMR], and subfield 3 in ["",PH], and from which a number can&lt;br&gt;
be parsed using the above algorithm.&lt;br&gt;
HL7:  IN1-7 : InsuranceCoPhoneNumber&lt;br&gt;
.ContactInfo.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MobilePhoneNumber is parsed from the first instance with subfield 2 = "BPN"&lt;br&gt;
or subfield 3 in [CP,BP], and from which a number can be parsed using the&lt;br&gt;
above algorithm.&lt;br&gt;
HL7:  IN1-7 : InsuranceCoPhoneNumber&lt;br&gt;
.ContactInfo.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
EmailAddress is parsed from the first non-null instance of subfield 4 in&lt;br&gt;
IN1-7.&lt;br&gt;
HL7:  IN1-7.4 : InsuranceCoPhoneNumber.EmailAddress</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="HealthFundPlan" type="HealthFundPlan">
            <s:annotation>
                <s:documentation>Code for specific insurance plan&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
HealthFundPlan will only be parsed if IN1-2.1 or .2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  IN1-2 : InsurancePlanID&lt;br&gt;
SDATableName=HealthFundPlan, ViewerClass=User.HS.ARCAuxilInsurType&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSAuxInsTypeDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  IN1-2.1 : InsurancePlanID.Identifier&lt;br&gt;
VIEWERLIB: User.HS.ARCAuxilInsurType(AUXITCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  IN1-2.2 : InsurancePlanID.Text&lt;br&gt;
VIEWERLIB: User.HS.ARCAuxilInsurType(AUXITDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  IN1-2.3 : InsurancePlanID.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupName">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though IN1-9 is a repeating field, HL7ToSDA3 only uses the first instance.&lt;br&gt;&lt;br&gt;
HL7:  IN1-9.1 : GroupName.OrganizationName&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="GroupNumber">
            <s:annotation>
                <s:documentation>HL7:  IN1-8 : GroupNumber&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="MembershipNumber">
            <s:annotation>
                <s:documentation>Membership Number or Policy Number&lt;br&gt;&lt;br&gt;
HL7:  IN1-36 : PolicyNumber&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSCardNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PlanType">
            <s:annotation>
                <s:documentation>HL7:  IN1-15 : PlanType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="InsuredName" type="Name">
            <s:annotation>
                <s:documentation>The name of the insured person&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though IN1-16 is a repeating field, HL7ToSDA3 only uses the first instance.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
INSCardholderName is a string property that is set as:&lt;br&gt;
"[NamePrefix] [GivenName] [MiddleName] [FamilyName]"&lt;br&gt;
or simply null if all those properties are null.&lt;br&gt;&lt;br&gt;
HL7:  IN1-16 : NameOfInsured&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSCardholderName)&lt;br&gt;
.FamilyName&lt;br&gt;
HL7:  IN1-16.1.1 : NameOfInsured.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSCardholderName)&lt;br&gt;
.FamilyNamePrefix&lt;br&gt;
HL7:  IN1-16.1.2 : NameOfInsured.FamilyName.OwnSurnamePrefix&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.GivenName&lt;br&gt;
HL7:  IN1-16.2 : NameOfInsured.GivenName&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSCardholderName)&lt;br&gt;
.MiddleName&lt;br&gt;
HL7:  IN1-16.3 : NameOfInsured.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSCardholderName)&lt;br&gt;
.NameSuffix&lt;br&gt;
HL7:  IN1-16.4 : NameOfInsured.Suffix&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.NamePrefix&lt;br&gt;
HL7:  IN1-16.5 : NameOfInsured.Prefix&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSCardholderName)&lt;br&gt;
.ProfessionalSuffix&lt;br&gt;
HL7:  IN1-16.14 : NameOfInsured.ProfessionalSuffix&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="InsuredAddress" type="Address">
            <s:annotation>
                <s:documentation>Address of insured person&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though IN1-19 is a repeating field, HL7ToSDA3 only uses the first instance.&lt;br&gt;
Also, only a Code is parsed for the City, State, Zip, and Country&lt;br&gt;
properties.  HL7ToSDA3 does not set a Description for these.&lt;br&gt;&lt;br&gt;
HL7:  IN1-19 : InsuredsAddress&lt;br&gt;&lt;br&gt;
.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Street is parsed as "[IN-19.1.1]; [IN1-19.2]".&lt;br&gt;
HL7:  IN1-19.1.1 : InsuredsAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  IN1-19.2 : InsuredsAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSCardholderAddress)&lt;br&gt;
.City&lt;br&gt;
HL7:  IN1-19.3 : InsuredsAddress.City&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSCardholderCityDR)&lt;br&gt;
.State&lt;br&gt;
HL7:  IN1-19.4 : InsuredsAddress.StateorProvince&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Zip&lt;br&gt;
HL7:  IN1-19.5 : InsuredsAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSCardholderZipDR)&lt;br&gt;
.Country&lt;br&gt;
HL7:  IN1-19.6 : InsuredsAddress.Country&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.County&lt;br&gt;
HL7:  IN1-19.9 : InsuredsAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.FromTime&lt;br&gt;
HL7:  IN1-19.13.1 : InsuredsAddress.EffectiveDate.Time&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ToTime&lt;br&gt;
HL7:  IN1-19.14.1 : InsuredsAddress.ExpirationDate.Time&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="InsuredContact" type="ContactInfo">
            <s:annotation>
                <s:documentation>Contact information for the Insured person&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="InsuredRelationship" type="Relationship">
            <s:annotation>
                <s:documentation>Relationship of insured person to patient&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
IN1-17 will only be parsed if IN1-17.1 or .2 are not null.&lt;br&gt;&lt;br&gt;
HL7:  IN1-17 : InsuredsRelationshipToPatient&lt;br&gt;
SDATableName=Relationship, ViewerClass=None&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  IN1-17.1 : InsuredsRelationshipToPatient.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  IN1-17.2 : InsuredsRelationshipToPatient.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  IN1-17.3 : InsuredsRelationshipToPatient.NameofCodingSystem&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Priority" type="s:string">
            <s:annotation>
                <s:documentation>If the insurance works in conjunction with other insurance plans, this
field contains priority sequence. Values are: 1, 2, 3, etc.&lt;br&gt;&lt;br&gt;
HL7:  IN1-22 : CoordofBenPriority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSUpdateUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSUpdateUserHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PAAdmInsurance(INSUpdateDate) + User.HS.PAAdmInsurance(INSUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Effective date of insurance&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of FromTime is stored in the viewer cache. (Both of the&lt;br&gt;
fields it is stored to are date-only.)&lt;br&gt;&lt;br&gt;
HL7:  IN1-12 : PlanEffectiveDate&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSDateTypeFrom)&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSDateValidFrom)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Expiration date of insurance&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of ToTime is stored in the viewer cache. (INSDateTypeTo&lt;br&gt;
is date-only.)&lt;br&gt;&lt;br&gt;
HL7:  IN1-12 : PlanExpirationDate&lt;br&gt;
VIEWERLIB: User.HS.PAAdmInsurance(INSDateTypeTo)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="TaxId" type="Identifier">
            <s:annotation>
                <s:documentation>Tax ID number for the health fund.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PayerId" type="Identifier">
            <s:annotation>
                <s:documentation>Payer ID for the health fund.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="HealthFundExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="HealthFundCode">
    <s:annotation>
        <s:documentation>In the Viewer Cache, HealthFunds are matched on Code and SDACodingStandard&lt;br&gt;
only. If a match is found on Code and SDACodingStandard and the&lt;br&gt;
Descriptions are different, the Description in the Viewer Cache is updated.&lt;br&gt;
Note that the Description must still be unique and therefore may have a&lt;br&gt;
uniqueness suffix added.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="HealthFundCodeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ARCInsuranceType(INSTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ARCInsuranceType(INSTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Address" type="Address">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactPerson" type="Name">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ContactInfo" type="ContactInfo">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="IsActive" type="Boolean">
            <s:annotation>
                <s:documentation>Whether the organization's record is still in active use.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="HealthFundCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="HealthFundPlan">
    <s:annotation>
        <s:documentation>HealthFundPlan is processed "in-line" in the Viewer Cache in&lt;br&gt;
web.SDA3.Encounter:InsertHealthFund since it needs to know about its&lt;br&gt;
"parent" HealthFund. A reference to the "parent" HealthFund (as an&lt;br&gt;
ARCInsuranceType) is stored in the AUXITInsTypeDR property.&lt;br&gt;&lt;br&gt;
In the Viewer Cache, HealthFundPlan is matched on Code, SDACodingStandard,&lt;br&gt;
and the "parent" HealthFund/ARCInsuranceType. If a match is found where the&lt;br&gt;
Description is different, it is updated. Codes and Descriptions are only&lt;br&gt;
required to be unique within a parent ARCInsuranceType. They may be reused&lt;br&gt;
with a different parent ARCInsuranceType.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="HealthFundPlanExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ARCAuxilInsurType(AUXITCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ARCAuxilInsurType(AUXITDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="HealthFundPlanExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SeparationMode">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SeparationModeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SeparationModeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfCareProviderType">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="CareProviderType" nillable="true" type="CareProviderType"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfRecommendation">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Recommendation" nillable="true" type="Recommendation"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Recommendation">
    <s:annotation>
        <s:documentation>Recommendation appears in the SDA as a list property&lt;br&gt;
(RecommendationsProvided) of HS.SDA3.Encounter.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="RecommendationExtension"/>
                <s:element minOccurs="0" name="NoteText" type="s:string">
                    <s:annotation>
                        <s:documentation>The text of the recommendation</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="RecipientPersons" type="ArrayOfCareProvider">
                    <s:annotation>
                        <s:documentation>The providers to whom the recommendation is forwarded</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="RecipientOrganizations" type="ArrayOfHealthCareFacility">
                    <s:annotation>
                        <s:documentation>The organizations to whom the recommendation is forwarded</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="RecommendationExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfHealthCareFacility">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="HealthCareFacility" nillable="true" type="HealthCareFacility"/>
    </s:sequence>
</s:complexType>
<s:complexType name="EncounterPriority">
    <s:annotation>
        <s:documentation>This type describes the priority of an Encounter, unlike HS.SDA3.CodeTableDetail.Priority,
which describes the priority of an Order.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="EncounterPriorityExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="EncounterPriorityExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DiagnosisRelatedGroup">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="DiagnosisRelatedGroupExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="DiagnosisRelatedGroupExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfAlert">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Alert" nillable="true" type="Alert"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Alert">
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AlertExtension"/>
        <s:element minOccurs="0" name="AlertType" type="AlertType">
            <s:annotation>
                <s:documentation>Type of alert - can be used for grouping&lt;br&gt;&lt;br&gt;
SDATableName=AlertType, ViewerClass=User.HS.PACAlertCategory&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMAlertCategoryDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Alert" type="AlertCode">
            <s:annotation>
                <s:documentation>Alert code (e.g. Advanced Directive, Patient Information)&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If the AdvanceDirective does not have an Alert, then in the OnValidate&lt;br&gt;
method of the Streamlet class, an error will be logged to the Ensemble&lt;br&gt;
Event Log and the streamlet will not be saved.&lt;br&gt;&lt;br&gt;
SDATableName=Alert, ViewerClass=User.HS.PACPatientAlert&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMAlertDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Comments on the alert&lt;br&gt;
CRLF-delimited string&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMMessage)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status" type="s:string">
            <s:annotation>
                <s:documentation>Alert status&lt;br&gt;
Possible values are "A" for "Active", "I" for "Inactive", and "C" for "To&lt;br&gt;
Be Confirmed".&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if the Status is&lt;br&gt;
not "A", "I", or "C" (or null or the delete instruction), it will be&lt;br&gt;
set to null and an alert logged.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The value that appears in the viewer does not come from the DISPLAYLIST&lt;br&gt;
of the ALMStatus property, but rather the Description for the corresponding&lt;br&gt;
AlertStatus Standard Type Item.  See the HS documentation for guidance on&lt;br&gt;
configuring this.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMStatus)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMCreateUser)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMLastUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PAAlertMsg(ALMCreateDate) + User.HS.PAAlertMsg(ALMCreateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Beginning of effective time range&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMOnsetDate) + User.HS.PAAlertMsg(ALMOnsetTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of effective time range&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMClosedDate) + User.HS.PAAlertMsg(ALMClosedTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PAAlertMsg(ALMExternalId)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate All (set Status="I")&lt;br&gt;
C = Clear All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AlertExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AlertType">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AlertTypeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAlertCategory(ALERTCATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAlertCategory(ALERTCATDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AlertTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AlertCode">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AlertCodeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACPatientAlert(ALERTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACPatientAlert(ALERTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AlertCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfAdvanceDirective">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="AdvanceDirective" nillable="true" type="AdvanceDirective"/>
    </s:sequence>
</s:complexType>
<s:complexType name="AdvanceDirective">
    <s:annotation>
        <s:documentation>HS.SDA3.AdvanceDirective corresponds to the CDA Advance Directives section.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AdvanceDirectiveExtension"/>
        <s:element minOccurs="0" name="AlertType" type="AlertType">
            <s:annotation>
                <s:documentation>Type of alert - can be used for grouping&lt;br&gt;&lt;br&gt;
SDATableName=AlertType, ViewerClass=User.HS.PACAlertCategory&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMAlertCategoryDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Alert" type="AlertCode">
            <s:annotation>
                <s:documentation>Alert code (e.g. Advanced Directive, Patient Information)&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If the AdvanceDirective does not have an Alert, then in the OnValidate&lt;br&gt;
method of the Streamlet class, an error will be logged to the Ensemble&lt;br&gt;
Event Log and the streamlet will not be saved.&lt;br&gt;&lt;br&gt;
SDATableName=Alert, ViewerClass=User.HS.PACPatientAlert&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMAlertDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Comments on the alert&lt;br&gt;
CRLF-delimited string&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMMessage)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status" type="s:string">
            <s:annotation>
                <s:documentation>Alert status&lt;br&gt;
Possible values are "A" for "Active", "I" for "Inactive", and "C" for "To&lt;br&gt;
Be Confirmed".&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if the Status is&lt;br&gt;
not "A", "I", or "C" (or null or the delete instruction), it will be&lt;br&gt;
set to null and an alert logged.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The value that appears in the viewer does not come from the DISPLAYLIST&lt;br&gt;
of the ALMStatus property, but rather the Description for the corresponding&lt;br&gt;
AlertStatus Standard Type Item.  See the HS documentation for guidance on&lt;br&gt;
configuring this.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMStatus)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMCreateUser)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMLastUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PAAlertMsg(ALMCreateDate) + User.HS.PAAlertMsg(ALMCreateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Beginning of effective time range&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMOnsetDate) + User.HS.PAAlertMsg(ALMOnsetTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of effective time range&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAlertMsg(ALMClosedDate) + User.HS.PAAlertMsg(ALMClosedTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PAAlertMsg(ALMExternalId)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate All (set Status="I")&lt;br&gt;
C = Clear All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AdvanceDirectiveExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfAllergy">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Allergy" nillable="true" type="Allergy"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Allergy">
    <s:annotation>
        <s:documentation>HS.SDA3.Allergy corresponds to the CDA Allergies and Other Adverse Reactions section.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AllergyExtension"/>
        <s:element minOccurs="0" name="Allergy" type="AllergyCode">
            <s:annotation>
                <s:documentation>Allergy code&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Both AL1-3 and IAM-3 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If the HS.SDA3.Allergy does not have an Allergy CodeTableDetail,&lt;br&gt;
then in the OnValidate method of the Streamlet class, an error will be&lt;br&gt;
logged in the Ensemble Event Log and the  streamlet will not be saved.&lt;br&gt;&lt;br&gt;
SDATableName=Allergy, ViewerClass=User.HS.PACAllergy&lt;br&gt;
HL7:  AL1-3 : AllergenCodeMnemonicDescription&lt;br&gt;
HL7:  IAM-3 : AllergenCodeMnemonicDescription&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGTypeDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  AL1-3.1 : AllergenCodeMnemonicDescription.Identifier&lt;br&gt;
HL7:  IAM-3.1 : AllergenCodeMnemonicDescription.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PACAllergy(ALGCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  AL1-3.2 : AllergenCodeMnemonicDescription.Text&lt;br&gt;
HL7:  IAM-3.2 : AllergenCodeMnemonicDescription.Text&lt;br&gt;
VIEWERLIB: User.HS.PACAllergy(ALGDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  AL1-3.3 : AllergenCodeMnemonicDescription.NameofCodingSystem&lt;br&gt;
HL7:  IAM-3.3 : AllergenCodeMnemonicDescription.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both AL1-3 and IAM-3, if subfield 4 or 5 is not null, then a PriorCode&lt;br&gt;
will be parsed to the SDA with Code coming from subfield 4, Description&lt;br&gt;
from 5, and CodingSystem from 6. The Type will be parsed as "A".&lt;br&gt;
HL7:  AL1-3.4 : AllergenCodeMnemonicDescription.AlternateIdentifier&lt;br&gt;
HL7:  IAM-3.4 : AllergenCodeMnemonicDescription.AlternateIdentifier&lt;br&gt;
HL7:  AL1-3.5 : AllergenCodeMnemonicDescription.AlternateText&lt;br&gt;
HL7:  IAM-3.5 : AllergenCodeMnemonicDescription.AlternateText&lt;br&gt;
HL7:  AL1-3.6 : AllergenCodeMnemonicDescription.NameofAlternateCodingSystem&lt;br&gt;
HL7:  IAM-3.6 : AllergenCodeMnemonicDescription.NameofAlternateCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  AL1-3.9 : AllergenCodeMnemonicDescription.OriginalText&lt;br&gt;
HL7:  IAM-3.9 : AllergenCodeMnemonicDescription.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AllergyCategory" type="AllergyCategory">
            <s:annotation>
                <s:documentation>The category of the allergy (e.g. Food, Medication)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The HL7 field will only be parsed if subfield 1 is not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If the Allergy contains no AllergyCategory, then in the OnValidate method&lt;br&gt;
of the Streamlet class, one will be defaulted with Code and Description =&lt;br&gt;
"Allergy".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Note that the code table for this type is MRC_AllType, whereas the table&lt;br&gt;
for Reaction is PAC_AllergyCategory.&lt;br&gt;&lt;br&gt;
HL7:  AL1-2 : AllergenTypeCode&lt;br&gt;
HL7:  IAM-2 : AllergenTypeCode&lt;br&gt;
SDATableName=AllergyCategory, ViewerClass=User.HS.MRCAllType&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGMRCAllTypeDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  AL1-2.1 : AllergenTypeCode.Identifier&lt;br&gt;
HL7:  IAM-2.1 : AllergenTypeCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.MRCAllType(MRCATCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  AL1-2.2 : AllergenTypeCode.Text&lt;br&gt;
HL7:  IAM-2.2 : AllergenTypeCode.Text&lt;br&gt;
VIEWERLIB: User.HS.MRCAllType(MRCATDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  AL1-2.3 : AllergenTypeCode.NameofCodingSystem&lt;br&gt;
HL7:  IAM-2.3 : AllergenTypeCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Clinician" type="CareProvider">
            <s:annotation>
                <s:documentation>Clinician who diagnosed/identified allergy&lt;br&gt;&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGCTPCPDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Reaction" type="Reaction">
            <s:annotation>
                <s:documentation>The reaction to the allergen&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though the HL7 fields are repeating, HL7ToSDA3 will only use the first&lt;br&gt;
instance of each. And although the HL7 field is not a coded element,&lt;br&gt;
HL7ToSDA3 will use the first piece with respect to the Component Separator&lt;br&gt;
(usually "^") as the Reaction Code.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Note that the code table for this type is PAC_AllergyCategory,&lt;br&gt;
whereas the table for AllergyCategory is MRC_AllType.&lt;br&gt;&lt;br&gt;
HL7:  AL1-5 : AllergyReaction&lt;br&gt;
HL7:  IAM-5 : AllergyReaction&lt;br&gt;
SDATableName=Reaction, ViewerClass=User.HS.PACAllergyCategory&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGCategoryDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Severity" type="Severity">
            <s:annotation>
                <s:documentation>The severity of the allergy (e.g. Mild, Severe, Life-threatening)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Both AL1-4 and IAM-4 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  AL1-4 : AllergySeverityCode&lt;br&gt;
HL7:  IAM-4 : AllergySeverityCode&lt;br&gt;
SDATableName=Severity, ViewerClass=User.HS.PACAllergySeverity&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGSeverityDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  AL1-4.1 : AllergySeverityCode.Identifier&lt;br&gt;
HL7:  IAM-4.1 : AllergySeverityCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PACAllergySeverity(ALRGSEVCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  AL1-4.2 : AllergySeverityCode.Text&lt;br&gt;
HL7:  IAM-4.2 : AllergySeverityCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PACAllergySeverity(ALRGSEVDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  AL1-4.3 : AllergySeverityCode.NameofCodingSystem&lt;br&gt;
HL7:  IAM-4.3 : AllergySeverityCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Certainty" type="Certainty">
            <s:annotation>
                <s:documentation>The certainty of the allergy (e.g. Suspected, Confirmed, Lab-tested)&lt;br&gt;&lt;br&gt;
SDATableName=Certainty, ViewerClass=User.HS.PACAllergyCertainty&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGCertaintyDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DiscoveryTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>When the allergy was discovered.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though AL1-6 is technically date-only, HL7ToSDA3 will parse a&lt;br&gt;
full date/time if one is given in this field.&lt;br&gt;&lt;br&gt;
HL7:  AL1-6 : IdentificationDate&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGDate) + User.HS.PAAllergy(ALGTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConfirmedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>When the allergy was confirmed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part is saved to the Viewer Cache. (ALGConfirmedDate is&lt;br&gt;
date-only.)&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGConfirmedDate)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>CRLF-delimited string&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGComments)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="InactiveTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>When the allergy was no longer active.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Note that while the HL7 standard describes IAM-20 as the time of any status&lt;br&gt;
change, HealthShare will always interpret this field as the time the&lt;br&gt;
allergy is declared inactive.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class,&lt;br&gt;
if InactiveTime is not null, then Status will be&lt;br&gt;
set to "I" for "Inactive".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part is saved to the Viewer Cache. (ALGInActiveDate is&lt;br&gt;
date-only.)&lt;br&gt;&lt;br&gt;
HL7:  IAM-20 : StatusedatDateTime&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGInActiveDate)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="InactiveComments" type="s:string">
            <s:annotation>
                <s:documentation>Why the allergy is considered inactive.&lt;br&gt;
CRLF-delimited string.&lt;br&gt;&lt;br&gt;
HL7:  IAM-8 : ActionReason&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGInActiveFreeText)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>When the allergy was verified&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part is saved to the Viewer Cache. (ALGVerifiedDate is&lt;br&gt;
date-only.)&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGVerifiedDate)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ATCCode" type="ATCCode">
            <s:annotation>
                <s:documentation>Drug group to which patient is allergic&lt;br&gt;&lt;br&gt;
SDATableName=ATCCode, ViewerClass=User.HS.PHCSubCat&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGPHCSCDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReasonNotCoded" type="s:string">
            <s:annotation>
                <s:documentation>Why allergy can't be coded (e.g. too imprecise).&lt;br&gt;
CRLF-delimited string.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGReasonNotCoded)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FreeTextAllergy">
            <s:annotation>
                <s:documentation>Allergy description if it can't be typed/coded&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGFreeTextAllergy)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="5000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="QualifyingDetails">
            <s:annotation>
                <s:documentation>CRLF-delimited string&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Status" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though IAM-17 is coded, HL7ToSDA3 will only parse the Identifier&lt;br&gt;
(subfield 1).&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if Status is not "A",&lt;br&gt;
"I", "R", or "C" (for "Active", "Inactive", "Resolved", and "To Be&lt;br&gt;
Confirmed", respectively) or null or the delete instruction, it will be set&lt;br&gt;
to null. Also, no matter what value is passed in for Status, if the Allergy&lt;br&gt;
has an InactiveTime, Status will be set to "I". In the OnValidate method of&lt;br&gt;
the Streamlet class, if Status is null, it will be defaulted to "A".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The value that appears in the Viewer does not come from the DISPLAYLIST of&lt;br&gt;
the ALGStatus property, but rather the Description for the corresponding&lt;br&gt;
AllergyStatus Standard Type Item.  See the HS documentation for guidance on&lt;br&gt;
configuring this.&lt;br&gt;&lt;br&gt;
HL7:  IAM-17.1 : AllergyClinicalStatusCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGStatus)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AssociatedEncounter">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
Unlike EncounterNumber, this property may be filled in or updated&lt;br&gt;
after the Allergy is initially created, and is not used for matching.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The ALGEncounter field in the Viewer Cache is used for both EncounterNumber&lt;br&gt;
and AssociatedEncounter, whichever is present.  If both are present,&lt;br&gt;
EncounterNumber is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGEncounter)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate All (set Status="I")&lt;br&gt;
C = Clear All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in the Set ID field (AL1-1 or IAM-1) will be parsed&lt;br&gt;
as ActionCode="I", and four double quotes ("""") as "C".  In either case&lt;br&gt;
the rest of the segment is ignored.&lt;br&gt;
If IAM-6.1 is "D", HL7ToSDA3 will parse this as ActionCode="D". Any other value&lt;br&gt;
is ignored.&lt;br&gt;&lt;br&gt;
HL7:  AL1-1 : SetIDAL1&lt;br&gt;
HL7:  IAM-1 : SetIDIAM&lt;br&gt;
HL7:  IAM-6.1 : AllergyActionCode.Identifier&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Only Description is parsed from IAM-14, not Code or SDACodingStandard.&lt;br&gt;&lt;br&gt;
HL7:  IAM-14 : ReportedBy&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGUpdateUserDR)&lt;br&gt;
.Description&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  IAM-14.1.1 : FamilyName.Surname&lt;br&gt;
HL7:  IAM-14.2 : GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
MSH-4.1 is parsed to the EnteredAt Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGLastUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7:  IAM-13 : ReportedDateTime&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGLastUpdateDate) + User.HS.PAAllergy(ALGLastUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The time of the onset of the allergy.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part is stored in the Viewer Cache. (ALGOnsetDate is&lt;br&gt;
date-only.)&lt;br&gt;&lt;br&gt;
HL7:  AL1-6 : IdentificationDate&lt;br&gt;
HL7: IAM-11 : OnsetDate&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGOnsetDate)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The time the allergy is no longer present&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part is saved to the Viewer Cache. (ALGExpiryDate is&lt;br&gt;
date-only.)&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGExpiryDate)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>HL7:  IAM-7.1 : AllergyUniqueIdentifier.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGExternalId)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber" type="s:string">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
The ALGEncounter field in the viewer cache is used for both EncounterNumber&lt;br&gt;
and AssociatedEncounter, whichever is present.  If both are present,&lt;br&gt;
EncounterNumber is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAAllergy(ALGEncounter)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AllergyExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AllergyCode">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AllergyCodeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAllergy(ALGCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAllergy(ALGDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AllergyCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AllergyCategory">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AllergyCategoryExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCAllType(MRCATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCAllType(MRCATDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AllergyCategoryExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Reaction">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ReactionExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAllergyCategory(ALRGCATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAllergyCategory(ALRGCATDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ReactionExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Severity">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="SeverityExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAllergySeverity(ALRGSEVCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAllergySeverity(ALRGSEVDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="SeverityExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Certainty">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="CertaintyExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAllergyCertainty(ALRGCERCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PACAllergyCertainty(ALRGCERDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="CertaintyExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ATCCode">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ATCCodeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCSubCat(PHCSCCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCSubCat(PHCSCDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ATCCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfIllnessHistory">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="IllnessHistory" nillable="true" type="IllnessHistory"/>
    </s:sequence>
</s:complexType>
<s:complexType name="IllnessHistory">
    <s:annotation>
        <s:documentation>HS.SDA3.IllnessHistory corresponds to the CDA History of Present Illness section.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="IllnessHistoryExtension"/>
        <s:element minOccurs="0" name="NoteText" type="s:string">
            <s:annotation>
                <s:documentation>Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTDesc)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Condition" type="PastHistoryCondition">
            <s:annotation>
                <s:documentation>Code for condition&lt;br&gt;&lt;br&gt;
SDATableName=PastHistoryCondition, ViewerClass=User.HS.MRCPastHistCondit&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTPastHistDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Clinician" type="CareProvider">
            <s:annotation>
                <s:documentation>Clinician involved&lt;br&gt;&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTCTCPDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time history verified&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTVerifiedDate) + User.HS.PAPastHistCondition(PHISTVerifiedTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AssociatedEncounter" type="s:string">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
Unlike EncounterNumber, this property may be filled in or updated after the&lt;br&gt;
IllnessHistory is initially created, and is not used for matching.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The PHISTEncounter field in the Viewer Cache is used for both&lt;br&gt;
EncounterNumber and AssociatedEncounter, whichever is present.  If both are&lt;br&gt;
present, EncounterNumber is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTEncounter)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
C = Clear/Delete All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTUpdateUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PAPastHistCondition(PHISTUpdateDate) + User.HS.PAPastHistCondition(PHISTUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Beginning of period covered&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of FromTime is stored in the Viewer Cache.&lt;br&gt;
(PHISTOnsetDate is date-only.)&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTOnsetDate)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of period covered&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTDate) + User.HS.PAPastHistCondition(PHISTTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PAPastHistCondition(PHISTExternalId)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
The PHISTEncounter field in the Viewer Cache is used for both&lt;br&gt;
EncounterNumber and AssociatedEncounter, whichever is present.  If both are&lt;br&gt;
present, EncounterNumber is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPastHistCondition(PHISTEncounter)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="IllnessHistoryExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PastHistoryCondition">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PastHistoryConditionExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCPastHistCondit(PASTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCPastHistCondit(PASTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PastHistoryConditionExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSocialHistory">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="SocialHistory" nillable="true" type="SocialHistory"/>
    </s:sequence>
</s:complexType>
<s:complexType name="SocialHistory">
    <s:annotation>
        <s:documentation>HS.SDA3.SocialHistory corresponds to the CDA Social History section.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="SocialHistoryExtension"/>
        <s:element minOccurs="0" name="SocialHabit" type="SocialHabit">
            <s:annotation>
                <s:documentation>Social habit code&lt;br&gt;
Ex: "Smoking"&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the SDA does not&lt;br&gt;
contain a SocialHabit, and error will be logged and the Streamlet will not&lt;br&gt;
be saved.&lt;br&gt;&lt;br&gt;
SDATableName=SocialHabit, ViewerClass=User.HS.MRCHabits&lt;br&gt;
VIEWERLIB: User.HS.PASocHist(SCHHabitsDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SocialHabitQty" type="SocialHabitQty">
            <s:annotation>
                <s:documentation>Quantity associated with social habit&lt;br&gt;
Ex: "Two packs per day"&lt;br&gt;&lt;br&gt;
SDATableName=SocialHabitQty, ViewerClass=User.HS.MRCHabitsQuantity&lt;br&gt;
VIEWERLIB: User.HS.PASocHist(SCHHabitsQtyDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SocialHabitCategory" type="SocialHabitCategory">
            <s:annotation>
                <s:documentation>Stores coded type of social habit</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SocialHabitComments" type="s:string">
            <s:annotation>
                <s:documentation>Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PASocHist(SCHDesc)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status" type="s:string">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnInactivate method of the Streamlet class, if the Status is not&lt;br&gt;
already "I", it is set to "I".&lt;br&gt;
In the OnValidate method, if the Status is null, it is defaulted to "A" for&lt;br&gt;
"Active".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
A Status of "I" is stored in the viewer cache as "Y". Any other Status is&lt;br&gt;
stored as "N".&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PASocHist(SCHInActive)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PASocHist(SCHUpdateUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PASocHist(SCHUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PASocHist(SCHUpdateDate) + User.HS.PASocHist(SCHUpdateTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Beginning of period covered&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of FromTime is stored in the Viewer Cache. (SCHOnsetDate&lt;br&gt;
is date-only.)&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PASocHist(SCHOnsetDate)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of period covered&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PASocHist(SCHDate) + User.HS.PASocHist(SCHTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PASocHist(SCHExternalId)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate All (set Status="I")&lt;br&gt;
C = Clear/Delete All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="SocialHistoryExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SocialHabit">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="SocialHabitExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCHabits(HABCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCHabits(HABDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="SocialHabitExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SocialHabitQty">
    <s:annotation>
        <s:documentation>SocialHabitQty is processed "in-line" in the Viewer Cache in&lt;br&gt;
web.SDA3.SocialHistory:UpdateSocialHistory since it needs to know about its&lt;br&gt;
"parent" SocialHabit. A reference to the "parent" SocialHabit (as an&lt;br&gt;
MRCHabits) is stored in the QTYParRef property.&lt;br&gt;&lt;br&gt;
In the Viewer Cache, SocialHabitQty is matched on Code, SDACodingStandard,&lt;br&gt;
and the "parent" SocialHabit/MRCHabits. If a match is found where the&lt;br&gt;
Description is different, it is updated. Codes and Descriptions are only&lt;br&gt;
required to be unique within a parent MRCHabits. They may be reused with&lt;br&gt;
a different parent MRCHabits.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="SocialHabitQtyExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCHabitsQuantity(QTYCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCHabitsQuantity(QTYDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="SocialHabitQtyExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SocialHabitCategory">
    <s:complexContent>
        <s:extension base="CodeTableDetail">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SocialHabitCategoryExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SocialHabitCategoryExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfFamilyHistory">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="FamilyHistory" nillable="true" type="FamilyHistory"/>
    </s:sequence>
</s:complexType>
<s:complexType name="FamilyHistory">
    <s:annotation>
        <s:documentation>HS.SDA3.FamilyHistory corresponds to the CDA Family History section.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="FamilyHistoryExtension"/>
        <s:element minOccurs="0" name="FamilyMember" type="FamilyMember">
            <s:annotation>
                <s:documentation>Family member covered&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if no FamilyMember is&lt;br&gt;
defined in the SDA, an error will be logged and the streamlet will not&lt;br&gt;
be saved.&lt;br&gt;&lt;br&gt;
SDATableName=FamilyMember, ViewerClass=User.HS.CTRelation&lt;br&gt;
VIEWERLIB: User.HS.PAFamily(FAMRelationDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Diagnosis" type="DiagnosisCode">
            <s:annotation>
                <s:documentation>Diagnosis on family member&lt;br&gt;&lt;br&gt;
SDATableName=Diagnosis, ViewerClass=User.HS.MRCICDDx&lt;br&gt;
VIEWERLIB: User.HS.PAFamily(FAMMRCICDDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="NoteText" type="s:string">
            <s:annotation>
                <s:documentation>Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAFamily(FAMDesc)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status" type="s:string">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if Status is null, it is&lt;br&gt;
defaulted to "A" for "Active".&lt;br&gt;
Deactivating the streamlet via ActionCode="I" will set Status to "I".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The stored value will be "Y" if Status is "I", and "N" otherwise.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAFamily(FAMInActive)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate All (set Status="I")&lt;br&gt;
C = Clear/Delete All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.PAFamily(FAMUpdateUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.PAFamily(FAMUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PAFamily(FAMUpdateDate) + User.HS.PAFamily(FAMUpdateTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Beginning of period covered&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of the FromTime is stored in the Viewer Vache.&lt;br&gt;
(FAMOnsetDate is date-only.)&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAFamily(FAMOnsetDate)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of period covered&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAFamily(FAMDate) + User.HS.PAFamily(FAMTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAFamily(FAMExternalId)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="FamilyHistoryExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="FamilyMember">
    <s:annotation>
        <s:documentation>In the Viewer Cache, both FamilyMember and Relationship CodeTableDetails&lt;br&gt;
are processed into the CTRelation table.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="FamilyMemberExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTRelation(CTRLTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTRelation(CTRLTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="FamilyMemberExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DiagnosisCode">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DiagnosisCodeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCICDDx(MRCIDCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCICDDx(MRCIDDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DiagnosisCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfDiagnosis">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Diagnosis" nillable="true" type="Diagnosis"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Diagnosis">
    <s:annotation>
        <s:documentation>HS.SDA3.Diagnosis corresponds to the CDA Hospital Admission Diagnosis
section and the Discharge Diagnosis section.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DiagnosisExtension"/>
        <s:element minOccurs="0" name="DiagnosingClinician" type="CareProvider">
            <s:annotation>
                <s:documentation>Clinician who made the diagnosis&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though DG1-16 is a repeating field, HL7ToSDA3 will only parse the first&lt;br&gt;
non-null instance.&lt;br&gt;&lt;br&gt;
HL7:  DG1-16 : DiagnosingClinician&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIADocCodeDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  DG1-16.1 : DiagnosingClinician.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  DG1-16.2.1 : DiagnosingClinician.FamilyName.Surname&lt;br&gt;
HL7:  DG1-16.3 : DiagnosingClinician.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  DG1-16.9 : DiagnosingClinician.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  DG1-16.2.1 : DiagnosingClinician.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  DG1-16.3 : DiagnosingClinician.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  DG1-16.4 : DiagnosingClinician.SecondandFurtherGivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  DG1-16.6 : DiagnosingClinician.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  DG1-16.5 : DiagnosingClinician.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  DG1-16.21 : DiagnosingClinician.ProfessionalSuffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Diagnosis" type="DiagnosisCode">
            <s:annotation>
                <s:documentation>The diagnosis code or description&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
DG1-3 will only be parsed if subfield 1 or 2 is not null. If they are and&lt;br&gt;
DG1-4 is not null, then it will be parsed as the Diagnosis Code. In this&lt;br&gt;
case, HL7ToSDA3 will not set the Description.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the SDA has no Diagnosis&lt;br&gt;
CodeTableDetail, an error will be logged and the Streamlet will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  DG1-3 : DiagnosisCodeDG1&lt;br&gt;
HL7:  DG1-4 : DiagnosisDescription&lt;br&gt;
SDATableName=Diagnosis, ViewerClass=User.HS.MRCICDDx&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIAICDCodeDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
DG1-4 will only be used if DG1-3.1 and .2 are null.&lt;br&gt;
HL7:  DG1-3.1 : DiagnosisCodeDG1.Identifier&lt;br&gt;
HL7:  DG1-4 : DiagnosisDescription&lt;br&gt;
VIEWERLIB: User.HS.MRCICDDx(MRCIDCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  DG1-3.2 : DiagnosisCodeDG1.Text&lt;br&gt;
VIEWERLIB: User.HS.MRCICDDx(MRCIDDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  DG1-3.3 : DiagnosisCodeDG1.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then a PriorCode will be parsed to the SDA&lt;br&gt;
with Code coming from subfield 4, Description from 5, and CodingSystem from&lt;br&gt;
6. The Type will be parsed as "A".&lt;br&gt;
HL7:  DG1-3.4 : DiagnosisCodeDG1.AlternateIdentifier&lt;br&gt;
HL7:  DG1-3.5 : DiagnosisCodeDG1.AlternateText&lt;br&gt;
HL7:  DG1-3.6 : DiagnosisCodeDG1.NameofAlternateCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  DG1-3.9 : DiagnosisCodeDG1.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DiagnosisType" type="DiagnosisType">
            <s:annotation>
                <s:documentation>The type of diagnosis (e.g. admitting, working, final, discharge)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
DG1-6 is used as the DiagnosisType Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
See the ActionScope property.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Rather than being a property of MRDiagnos directly, the MRCDiagnosType is a&lt;br&gt;
property of MRDiagType, which is a child of MRDiagnos. An MRDiagnos can only&lt;br&gt;
have one MRDiagType.&lt;br&gt;&lt;br&gt;
HL7:  DG1-6 : DiagnosisType&lt;br&gt;
SDATableName=DiagnosisType, ViewerClass=User.HS.MRCDiagnosType&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(ChildMRDiagType)-&gt;User.HS.MRDiagType(TYPMRCDiagTyp)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="LinkedDiagnosisCode" type="s:string">
            <s:annotation>
                <s:documentation>A related (e.g. secondary) diagnosis&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If another Diagnosis exists in the same Encounter (or no Encounter if this&lt;br&gt;
Diagnosis is Encounter-less) with Diagnosis.Code matching this LinkedDiagnosisCode,&lt;br&gt;
MRDIAMRDIADR will be set to a reference to that Diagnosis (as a User.HS.MRDiagnos).&lt;br&gt;
Note that the other Diagnosis must already be saved to the viewer cache for the&lt;br&gt;
link to be made.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIAMRDIADR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="LinkedExternalId">
            <s:annotation>
                <s:documentation>A related (e.g. secondary) diagnosis External ID&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIALinkedExternalId)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="IdentificationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>When the diagnosis was made&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIADateDiagnosisIdentif) + User.HS.MRDiagnos(MRDIATimeDiagnosisIdentif)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status" type="DiagnosisStatus">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
For any Diagnosis parsed from a DG1 segment, Status will not actually be&lt;br&gt;
parsed from any field of the segment, but rather the Code will always be&lt;br&gt;
parsed as "A" and the Description as "Active".&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the SDA has no Status,&lt;br&gt;
a Status with Code="A" and Description="Active" will be defaulted in.&lt;br&gt;&lt;br&gt;
SDATableName=DiagnosisStatus, ViewerClass=User.HS.MRCDiagnosStatus&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIADiagStatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OnsetTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>When the diagnosed condition began&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIAOnsetDate) + User.HS.MRDiagnos(MRDIAOnsetTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>D = Delete&lt;br&gt;
I = Inactivate All (set Status.Code="I",Description="Inactive")&lt;br&gt;
C = Clear All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in DG1-1 will be parsed as ActionCode="I", and four&lt;br&gt;
double quotes ("""") as "C".  In either case the rest of the segment is&lt;br&gt;
ignored. HL7ToSDA3 will also parse values of "A", "D", and "U" (for "Add",&lt;br&gt;
"Delete", and "Update") from DG1-21, though "D" is the only value that is&lt;br&gt;
meaningful to HealthShare. Any other non-null value will be parsed as "A".&lt;br&gt;&lt;br&gt;
HL7:  DG1-1 : SetIDDG1&lt;br&gt;
HL7:  DG1-21 : DiagnosisActionCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>"ADMISSION" = Inactivate/Clear all Diagnoses with DiagnosisType.Code="A"&lt;br&gt;
"DISCHARGE" = Inactivate/Clear all Diagnoses with DiagnosisType.Code'="A"&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionScope is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIAUserCreatedDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
MSH-4.1 is parsed as the EnteredAt Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIAUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7:  DG1-5.1 : DiagnosisDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIADate) + User.HS.MRDiagnos(MRDIATime)&lt;br&gt;
VIEWERLIB: User.HS.MRDiagnos(MRDIAUpdateDate) + User.HS.MRDiagnos(MRDIAUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRDiagnos(MRDIAExternalId)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="DiagnosisPriority" type="s:string">
            <s:annotation>
                <s:documentation>The priority of the diagnosis code&lt;br&gt;
The value 1 means that this is the primary diagnosis. Values 2-99 convey ranked secondary diagnoses.&lt;br&gt;&lt;br&gt;
HL7:  DG1-15 : DiagnosisPriority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DiagnosisExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DiagnosisType">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DiagnosisTypeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCDiagnosType(DTYPCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCDiagnosType(DTYPDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DiagnosisTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DiagnosisStatus">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DiagnosisStatusExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCDiagnosStatus(DSTATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCDiagnosStatus(DSTATDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DiagnosisStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfObservation">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Observation" nillable="true" type="Observation"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Observation">
    <s:annotation>
        <s:documentation>Note that Observations appear in three places in the SDA3 data model: &lt;br&gt;
as a list property of Container, as a list property of Vaccination &lt;br&gt;
and as a list property of SocialDeterminant.&lt;br&gt;&lt;br&gt;
Observations under the Container are stored as their own streamlets.&lt;br&gt;
Observations that are properties of a Vaccination are stored as part of the&lt;br&gt;
Vaccination streamlet. Cases where the HL7 or Streamlet processing is&lt;br&gt;
different for independent Observations versus Vaccination Observations are&lt;br&gt;
noted in these annotations. At present Vaccination Observations are not&lt;br&gt;
stored in the Viewer Cache, so any mention of the Viewer Cache here refers&lt;br&gt;
to independent Observations only. Observations that are properties of a &lt;br&gt;
Social Determinant are stored as part of the Social Determinant streamlet.&lt;br&gt;&lt;br&gt;
Also note that the way some properties are parsed from HL7 will depend on&lt;br&gt;
the value of the ObservationCompatibilityMode setting of the HL7 Inbound&lt;br&gt;
Process operation of the Edge production (referred to here as Compatibility&lt;br&gt;
Mode on or off).&lt;br&gt;
HS.SDA3.Observation corresponds to the CDA Vital Signs section.  An Observation&lt;br&gt;
is exported to the Vital Signs section only when the ObservationCode indicates&lt;br&gt;
a valid LOINC Vital Sign code.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ObservationExtension"/>
        <s:element minOccurs="0" name="ObservationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time of the observation&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Observation Streamlet class, if&lt;br&gt;
ObservationTime is null, it is defaulted to EnteredOn, then to the current&lt;br&gt;
date/time.&lt;br&gt;
In the OnBeforeMatch method of the Vaccination Streamlet class, if&lt;br&gt;
ObservationTime is null, it is defaulted to the last non-null&lt;br&gt;
ObservationTime in the list (that was originally non-null, not defaulted),&lt;br&gt;
then to the EnteredOn of the current Observation, then to the current&lt;br&gt;
date/time.&lt;br&gt;&lt;br&gt;
HL7:  OBX-14.1 : DateTimeoftheObservation.Time&lt;br&gt;
VIEWERLIB: User.HS.MRObservationEntry(OBSENTRYDate) + User.HS.MRObservationEntry(OBSENTRYTime)&lt;br&gt;
VIEWERLIB: User.HS.MRObservations(OBSDate) + User.HS.MRObservations(OBSTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationCode" type="ObservationCode">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnValidate method of the Observation Streamlet class, if the&lt;br&gt;
Observation has no ObservationCode, an error will be logged and the&lt;br&gt;
Streamlet will not be saved.&lt;br&gt;
In the OnValidate method of the Vaccination Streamlet class, if any of the&lt;br&gt;
Observations in VXUObservations has no ObservationCode, an error will be&lt;br&gt;
logged and the Vaccination will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  OBX-3  : ObservationIdentifier&lt;br&gt;
SDATableName=Observation, ViewerClass=User.HS.MRCObservationItem&lt;br&gt;
VIEWERLIB: User.HS.MRObservations(OBSItemDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBX-3.1 : ObservationIdentifier.Identifier&lt;br&gt;
VIEWERLIB: User.HS.MRCObservationItem(ITMCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBX-3.2 : ObservationIdentifier.Text&lt;br&gt;
VIEWERLIB: User.HS.MRCObservationItem(ITMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-3.3 : ObservationIdentifier.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ObservationValueUnits&lt;br&gt;
Streamlet cache:&lt;br&gt;
Note that units are not used when matching Observation Streamlets, so two&lt;br&gt;
SDA3 Observations with the same ObservationTime and Observation.Code and&lt;br&gt;
SDACodingStandard, and different ObservationValueUnits *will* match, and&lt;br&gt;
the existing value for ObservationValueUnits will be overridden.&lt;br&gt;
Viewer cache:&lt;br&gt;
Note that units *are* used for code table matching in the Viewer Cache, so&lt;br&gt;
two CodeTableDetail Observations with the same Code, Description, and&lt;br&gt;
SDACodingStandard but different ObservationValueUnits *will not* match.&lt;br&gt;
HL7:  OBX-6  : Units&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.MRCObservationItem(ITMCTUOMDR)&lt;br&gt;
.ObservationValueUnits.Code&lt;br&gt;
HL7:  OBX-6.1 : Units.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMCode)&lt;br&gt;
.ObservationValueUnits.Description&lt;br&gt;
HL7:  OBX-6.2 : Units.Text&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMDesc)&lt;br&gt;
.ObservationValueUnits.SDACodingStandard&lt;br&gt;
HL7:  OBX-6.3 : Units.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationValue">
            <s:annotation>
                <s:documentation>Free-text value of the observation&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If Compatibility Mode is on and the OBX segment is for an independent (not&lt;br&gt;
Vaccination) Observation, then ObservationValue is parsed from each&lt;br&gt;
instance of OBX-5.1 (OBX-5 is repeating) concatenated together with ", ".&lt;br&gt;
If Compatibility Mode is off or if the OBX segment is for a Vaccination&lt;br&gt;
Observation, then the behavior depends on the value of OBX-2:&lt;br&gt;
-If OBX-2 is CE, CWE, or CNE, ObservationValue is populated by OBX-5.2&lt;br&gt;
 (ObservationValue.Text) or OBX-5.9 (ObservationValue.OriginalText) if that&lt;br&gt;
 is null.&lt;br&gt;
-If OBX-2 is TS or DT, then OBX-5 should contain an HL7 timestamp, and&lt;br&gt;
 ObservationValue will be parsed as that time in YYYY-MM-DD hh:mm:ssZ&lt;br&gt;
 format.&lt;br&gt;
-If OBX-2 is SN, then ObservationValue will be parsed as subfields 1&lt;br&gt;
 through 4 of OBX-5 all concatenated together.
-If OBX-2 is none of these values, then ObservationValue is parsed from&lt;br&gt;
each instance of OBX-5.1 (OBX-5 is repeating) concatenated together with&lt;br&gt;
", ".&lt;br&gt;&lt;br&gt;
HL7:  OBX-5  : ObservationValue&lt;br&gt;
VIEWERLIB: User.HS.MRObservations(OBSValue)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="999"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ObservationValueType" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
The Value Type affects how ObservationValue is parsed and whether&lt;br&gt;
ObservationCodedValue or ObservationValueTime will be parsed as well. See&lt;br&gt;
the annotations on those properties for more info.&lt;br&gt;&lt;br&gt;
HL7:  OBX-2 : ValueType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationValueTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
If Compatibility Mode is off or the OBX is for a Vaccination Observation,&lt;br&gt;
and if OBX-2 (Value Type) is TS or DT, the ObservationValueTime is parsed&lt;br&gt;
as OBX-5.1, converted to XML timestamp format. Otherwise HL7ToSDA3 does&lt;br&gt;
not set this.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5.1 : ObservationValue&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationCodedValue" type="ObservationValueCode">
            <s:annotation>
                <s:documentation>Coded value of observation&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ObservationCodedValue will only be parsed if Compatibility Mode is off or&lt;br&gt;
the OBX is for a Vaccination Observation, and OBX-2 (Value Type) is CE,&lt;br&gt;
CWE, or CNE&lt;br&gt;&lt;br&gt;
HL7:  OBX-5 : ObservationValue&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBX-5.1 : ObservationValue&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBX-5.2 : ObservationValue&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-5.3 : ObservationValue&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBX-5.7 : ObservationValue&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  OBX-5.9 : ObservationValue&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to the above condition for parsing ObservationCodedValue, if&lt;br&gt;
OBX-5.4 or .5 are not null, then OBX-5.4, .5, .6, and .8 will be parsed&lt;br&gt;
into a PriorCode as Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively.&lt;br&gt;
HL7:  OBX-5.4 : ObservationValue&lt;br&gt;
HL7:  OBX-5.5 : ObservationValue&lt;br&gt;
HL7:  OBX-5.6 : ObservationValue&lt;br&gt;
HL7:  OBX-5.8 : ObservationValue</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments">
            <s:annotation>
                <s:documentation>Comments on the observation&lt;br&gt;
The MAXLEN comes from the Trak property.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.MRObservations(OBSShortDesc)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="999"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Clinician" type="CareProvider">
            <s:annotation>
                <s:documentation>Clinician who made the observation&lt;br&gt;&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.MRObservations(OBSCTCPDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupId" type="s:string">
            <s:annotation>
                <s:documentation>If this observation was taken as part of a group, this is the
identifier of that group.&lt;br&gt;
The SDA2-to-SDA3 transform populates this field with the SDA2
ExternalId property.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
GroupId will only be parsed for Vaccination Observations.&lt;br&gt;&lt;br&gt;
HL7:  OBX-4 : ObservationSubId&lt;br&gt;
VIEWERLIB: User.HS.MRObservations(OBSExternalId)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationMethods" type="ArrayOfObservationMethod">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
OBX-17 is a repeating field. Each non-null instance will be parsed as one&lt;br&gt;
ObservationMethod in this list.&lt;br&gt;&lt;br&gt;
HL7:  OBX-17 : ObservationMethod&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBX-17.1 : ObservationMethod.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBX-17.2 : ObservationMethod.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-17.3 : ObservationMethod.NameofCodingSystem&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBX-17.7 : ObservationMethod.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If OBX-17.4 or .5 are not null, then OBX-17.4, .5, .6, and .8 will be&lt;br&gt;
parsed to a PriorCode as Code, Description, CodeSystem, and&lt;br&gt;
CodeSystemVersionId, respectively.&lt;br&gt;
HL7:  OBX-17.4 : ObservationMethod.AlternateIdentifier&lt;br&gt;
HL7:  OBX-17.5 : ObservationMethod.AlternateText&lt;br&gt;
HL7:  OBX-17.6 : ObservationMethod.AlternateNameofCodingSystem&lt;br&gt;
HL7:  OBX-17.7 : ObservationMethod.AlternateCodingSystemVersion</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
C = Clear/Delete All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.MRObservations(OBSUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.MRObservations(OBSUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRObservations(OBSUpdateDate) + User.HS.MRObservations(OBSUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationGroup" type="s:string">
            <s:annotation>
                <s:documentation>Id of the observation group this observation belongs to.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationId" type="s:string">
            <s:annotation>
                <s:documentation>Id of a streamlet containing this obsrvation, used only for memebers of a group</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ObservationExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ObservationCode">
    <s:annotation>
        <s:documentation>In the Viewer Cache, Observation CodeTableDetails are matched to&lt;br&gt;
MRCObservationItems on Code, Description, SDACodingStandard, and&lt;br&gt;
ObservationValueUnits (which is itself subject to code table matching).</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ObservationCodeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCObservationItem(ITMCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCObservationItem(ITMDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ObservationValueUnits" type="UoM">
            <s:annotation>
                <s:documentation>SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.MRCObservationItem(ITMCTUOMDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ObservationCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="UoM">
    <s:annotation>
        <s:documentation>Unit of measure&lt;br&gt;
UoM has several uses, such as the units of the amount of a medication&lt;br&gt;
prescribed, and the units of an observation value.&lt;br&gt;
For every other type of CodeTableDetail, a Code or Description that&lt;br&gt;
consists only of punctuation will not be saved to the Streamlet Cache, and&lt;br&gt;
will not be exported via ToQuickXML. For UoM only, there is one exception&lt;br&gt;
to this: Code and/or Description = "%" will be saved to the Streamlet Cache&lt;br&gt;
and will be exported via ToQuickXML.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="UoMExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTUOM(CTUOMCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTUOM(CTUOMDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="UoMExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ObservationValueCode">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ObservationValueCodeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ObservationValueCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfObservationMethod">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="ObservationMethod" nillable="true" type="ObservationMethod"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ObservationMethod">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ObservationMethodExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ObservationMethodExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfObservationGroup">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="ObservationGroup" nillable="true" type="ObservationGroup"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ObservationGroup">
    <s:annotation>
        <s:documentation>Observation groups are not created from inbound data. &lt;br&gt;
They can only be automatically created from Observations. &lt;br&gt;
ObservationGroup may appear along with Observation: &lt;br&gt;
currently only Blood Pressure observation is grouped. &lt;br&gt;
If an observation has the non empty ObservationGroup property then it is duplicated in the corresponding group&lt;br&gt;&lt;br&gt;</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Message action code&lt;br&gt;
Case-sensitive&lt;br&gt;
Supported values include:&lt;br&gt;
D = Delete&lt;br&gt;
E = Delete if empty (Encounters only)&lt;br&gt;
I = Inactivate all&lt;br&gt;
C = Clear/Delete all&lt;br&gt;
R = Replace (Patient and Encounter only)&lt;br&gt;
Any other value = Add or Update&lt;br&gt;&lt;br&gt;
ActionCode is only supported for SDA3 classes corresponding to Streamlet&lt;br&gt;
types (Allergy, Diagnosis, etc.). Not all of the above codes are supported&lt;br&gt;
for every class. Whether ActionCode is supported and what codes are&lt;br&gt;
supported is documented in each individual subclass. For codes "C" and "I",&lt;br&gt;
all streamlets of the given type belonging to the given Patient and in the&lt;br&gt;
given Encounter (or Encounter-less if the inbound SDA object has no&lt;br&gt;
EncounterNumber) will be cleared or inactivated. Otherwise (codes "D", "E",&lt;br&gt;
"R") only the matching streamlet will be affected.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Optional ActionCode qualifier&lt;br&gt;
For selected SDA classes, this qualifies ActionCodes "I" (if it is&lt;br&gt;
supported) and "C" by giving them a scope. Ex: for Problems, ActionCode="C"&lt;br&gt;
and ActionScope="PAST" will only delete past problems. (The meaning of&lt;br&gt;
"past" is explained in HS.SDA3.Problem.) Whether ActionScope is supported&lt;br&gt;
and what values are supported is documented in each individual subclass.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time updated or entered.  For labs, this represents when the order was&lt;br&gt;
placed.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ObservationGroupExtension"/>
        <s:element minOccurs="0" name="Observations" type="ArrayOfObservation"/>
        <s:element minOccurs="0" name="ObservationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Common time for observation members</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationGroupCode" type="ObservationCode"/>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ObservationGroupExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfProblem">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Problem" nillable="true" type="Problem"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Problem">
    <s:annotation>
        <s:documentation>HS.SDA3.Problem data corresponds to any of three different CDA sections:&lt;br&gt;
Problem List, History of Past Illness, Functional Status. Refer to the&lt;br&gt;
Section-Modules export XSLs for any of those sections for more details.&lt;br&gt;&lt;br&gt;
In the default Clinical Viewer layout, Problems are displayed on the&lt;br&gt;
Conditions chart in the "Present Illness" and "Past Illness" profiles. The&lt;br&gt;
logic to determine whether a Problem is past or present is described in the&lt;br&gt;
annotation on the &lt;property&gt;ActionScope&lt;/property&gt; property and uses the &lt;property&gt;ToTime&lt;/property&gt; and &lt;property&gt;Status&lt;/property&gt; values.&lt;br&gt;
This is implemented via row filters on these profiles that invoke&lt;br&gt;
web.SDA3.Problem::IsProblemPresent.  Users wishing to customize the filter&lt;br&gt;
logic may copy this method to their own class, change it to their liking,&lt;br&gt;
and configure the filters for the profiles to use this method instead.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ProblemExtension"/>
        <s:element minOccurs="0" name="ProblemDetails" type="s:string">
            <s:annotation>
                <s:documentation>Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the SDA does not have a&lt;br&gt;
Problem CodeTableDetail and ProblemDetails is null, an error will be logged&lt;br&gt;
and the Streamlet will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIDesc)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Problem" type="BodyPart">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
PRB-3 will only be parsed if subfield 1 (Identifier) or 2 (Text) is not&lt;br&gt;
null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the SDA does not have a&lt;br&gt;
Problem CodeTableDetail and ProblemDetails is null, an error will be logged&lt;br&gt;
and the Streamlet will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  PRB-3 : ProblemID&lt;br&gt;
SDATableName=BodyPart, ViewerClass=User.HS.MRCBodyParts&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIBodyPartsDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PRB-3 : ProblemID.Identifier&lt;br&gt;
VIEWERLIB: User.HS.MRCBodyParts(BODPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PRB-3 : ProblemID.Text&lt;br&gt;
VIEWERLIB: User.HS.MRCBodyParts(BODPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PRB-3 : ProblemID.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Clinician" type="CareProvider">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Clinician is parsed from the first ROL segment following the PRB segment&lt;br&gt;
with ROL-3.1 (Role.Identifier) = AD, AT, CP, FHCP, PP, RP, or RT (HL7 code&lt;br&gt;
table 2.5:443, Provider Role).&lt;br&gt;&lt;br&gt;
HL7:  ROL&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESICTCPDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ROL-1.1 is non-null, use that as Code. Else, if the first instance of&lt;br&gt;
ROL-4.1 is non-null, use that as Code.&lt;br&gt;
HL7:  ROL-1.1 : RoleInstanceID.EntityIdentifier&lt;br&gt;
HL7:  ROL-4.1 : RolePerson.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Description is parsed from the first instance of ROL-4 (Role Person),&lt;br&gt;
subfields 2.1 (FamilyName.Surname) and 3 (GivenName), formatted as:&lt;br&gt;
"[FamilyName.Surname], [GivenName]".&lt;br&gt;
HL7:  ROL-4.2.1 : RolePerson.FamilyName.Surname&lt;br&gt;
HL7:  ROL-4.3 : RolePerson.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ROL-1.1 is non-null, use ROL-1.2 as SDACodingStandard. Else, if the&lt;br&gt;
first instance of ROL-4.1 is non-null, use that instance of ROL-4.9 as&lt;br&gt;
SDACodingStandard.&lt;br&gt;
HL7:  ROL-1.2 : RoleInstanceID.NamespaceID&lt;br&gt;
HL7:  ROL-4.9 : RolePerson.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Only the first instance of ROL-4 is used.&lt;br&gt;
HL7:  ROL-4 : RolePerson&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ROL-4.2.1 : RolePerson.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.FamilyNamePrefix&lt;br&gt;
HL7:  ROL-4.2.2 : RolePerson.FamilyName.OwnSurnamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextOne)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ROL-4.3 : RolePerson.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ROL-4.4 : RolePerson.SecondandFurtherGivenNamesorInitialsThereof&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  ROL-4.5 : RolePerson.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ROL-4.6 : RolePerson.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  ROL-4.7 : RolePerson.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;&lt;br&gt;
.Address&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Only the first instance of ROL-11 is used.&lt;br&gt;
HL7:  ROL-11 : OfficeHomeAddressBirthplace&lt;br&gt;
.Adress.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ROL-11.2, if present, is concatenated to ROL-11.1 as:&lt;br&gt;
"[ROL-11.1]; [ROL-11.2]"&lt;br&gt;
HL7:  ROL-11.1 : OfficeHomeAddressBirthplace.StreetAddress&lt;br&gt;
HL7:  ROL-11.2 : OfficeHomeAddressBirthplace.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPStName)&lt;br&gt;
.Address.City&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ROL-11.3 is parsed to City.Code. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  ROL-11.3 : OfficeHomeAddressBirthplace.City&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCityDR)&lt;br&gt;
.Address.State&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ROL-11.4 is parsed to State.Code. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  ROL-11.4 : OfficeHomeAddressBirthplace.StateorProvince&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ROL-11.5 is parsed to Zip.Code. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  ROL-11.5 : OfficeHomeAddressBirthplace.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ROL-11.6 is parsed to Country.Code. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  ROL-11.6 : OfficeHomeAddressBirthplace.Country&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.FromTime&lt;br&gt;
HL7:  ROL-11.13 : OfficeHomeAddressBirthplace.EffectiveDate&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.ToTime&lt;br&gt;
HL7:  ROL-11.14 : OfficeHomeAddressBirthplace.ExpirationDate&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.ContactInfo&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ROL-12 is a repeating field, and each instance may populate&lt;br&gt;
HomePhoneNumber, WorkPhoneNumber, MobilePhoneNumber, or EmailAddress,&lt;br&gt;
depending on the values contained therein. For each instance of ROL-12, the&lt;br&gt;
algorithm to parse a phone number out of that instance is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else continue to the next instance of ROL-12.&lt;br&gt;&lt;br&gt;
-Whichever number is parsed, if subfield 9 of that instance is not null, it&lt;br&gt;
will be appended to the number, delimited by a semicolon.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;
HL7:  ROL-12 : Phone&lt;br&gt;
.ContactInfo.HomePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
HomePhoneNumber is parsed from the first instance of ROL-12 with subfield 2&lt;br&gt;
(Use) in [PRN,ORN,VHN,EMR], and subfield 3 in ["",PH], and from which a&lt;br&gt;
number can be parsed using the above algorithm.&lt;br&gt;
HL7:  ROL-12 : Phone&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTelH)&lt;br&gt;
.ContactInfo.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
WorkPhoneNumber is parsed from the first instance of ROL-12 with subfield 2&lt;br&gt;
in ["",WPN,ASN], and subfield 3 in ["",PH], and from which a number can be&lt;br&gt;
parsed using the above algorithm.&lt;br&gt;
HL7:  ROL-12 : Phone&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTelO)&lt;br&gt;
.ContactInfo.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MobilePhoneNumber is parsed from the first instance of ROL-12 with subfield&lt;br&gt;
2 = "BPN" or subfield 3 in [CP,BP], and from which a number can be parsed&lt;br&gt;
using the above algorithm.&lt;br&gt;
HL7:  ROL-12 : Phone&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPMobilePhone)&lt;br&gt;
.ContactInfo.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
EmailAddress is parsed from the first non-null instance of subfield 4 in&lt;br&gt;
ROL-12.&lt;br&gt;
HL7:  ROL-12.4 : Phone.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPEmail)&lt;br&gt;&lt;br&gt;
.CareProviderType&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
CareProviderType will only be parsed from ROL-9 if piece 1 or 2 is not&lt;br&gt;
null.&lt;br&gt;
HL7:  ROL-9 : ProviderType&lt;br&gt;
SDATableName=CareProviderType, ViewerClass=User.HS.CTCarPrvTp&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCarPrvTpDR)&lt;br&gt;
.CareProviderType.Code&lt;br&gt;
HL7:  ROL-9.1 : ProviderType.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTCarPrvTp(CTCPTCode)&lt;br&gt;
.CareProviderType.Description&lt;br&gt;
HL7:  ROL-9.2 : ProviderType.Text&lt;br&gt;
VIEWERLIB: User.HS.CTCarPrvTp(CTCPTDesc)&lt;br&gt;
.CareProviderType.SDACodingStandard&lt;br&gt;
HL7:  ROL-9.3 : ProviderType.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CauseofDeath">
            <s:annotation>
                <s:documentation>Whether this Problem contributed as a Cause of Death&lt;br&gt;
Supported values: Y, N&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESICauseOfDeath)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                    <s:enumeration value="Y"/>
                    <s:enumeration value="N"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Status" type="DiagnosisStatus">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
If PRB-14.1 or .2 is not null, then Status is derived from PRB-14. The&lt;br&gt;
actual values parsed to the SDA may not exactly match what is in the HL7.&lt;br&gt;
The logic is:&lt;br&gt;
-If PRB-14.1 matches one of the SNOMED codes and PRB-14.3 contains "SNOMED"&lt;br&gt;
(case-insensitive), use the corresponding SNOMED description.&lt;br&gt;
-Else if PRB-14.2 matches one of the SNOMED descriptions (case- and&lt;br&gt;
whitespace-insensitive), use the corresponding SNOMED code.&lt;br&gt;
-Else if there is a value in PRB-9 (Actual Problem Resolution Date/Time),&lt;br&gt;
use Code="413322009", Description="Resolved".&lt;br&gt;
-Else default to Code="55561003", Description="Active".&lt;br&gt;
In each case, the SDACodingStandard is set to "SNOMED CT".&lt;br&gt;
The SNOMED Codes and Descriptions for Problem Status are:&lt;br&gt;
55561003 - Active&lt;br&gt;
73425007 - Inactive&lt;br&gt;
90734009 - Chronic&lt;br&gt;
7087005 - Intermittent&lt;br&gt;
255227004 - Recurrent&lt;br&gt;
415684004 - Suspected&lt;br&gt;
410516002 - Ruled out&lt;br&gt;
413322009 - Resolved&lt;br&gt;&lt;br&gt;
HL7:  PRB-9 : ActualProblemResolutionDateTime&lt;br&gt;
HL7:  PRB-14 : ProblemLifeCycleStatus&lt;br&gt;
SDATableName=DiagnosisStatus, ViewerClass=User.HS.MRCDiagnosStatus&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIDiagnosStatusDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Category" type="ProblemCategory">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
PRB-10 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  PRB-10 : ProblemClassification&lt;br&gt;
SDATableName=ProblemCategory, ViewerClass=User.HS.MRCPresIllCategory&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESICategoryDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PRB-10.1 : ProblemClassification.Identifier&lt;br&gt;
VIEWERLIB: User.HS.MRCPresIllCategory(PRESICCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PRB-10.2 : ProblemClassification.Text&lt;br&gt;
VIEWERLIB: User.HS.MRCPresIllCategory(PRESICDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PRB-10.3 : ProblemClassification.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIComments)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
C = Clear/Delete All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used. Also see the annotation on the ActionScope property for&lt;br&gt;
information on how ActionScope="C" can be qualified.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For a PPR_PC3 message (Problem Delete), ActionCode is always parsed as "D".&lt;br&gt;
Otherwise PRB-1 is used if not null.&lt;br&gt;&lt;br&gt;
HL7:  PRB-1 : ActionCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Optional scope used to qualify ActionCode="C"&lt;br&gt;
Supported values are:&lt;br&gt;
PRESENT (case-insensitive) = Clear only Present Problems&lt;br&gt;
PAST (case-insensitive) = Clear only Past Problem&lt;br&gt;
If ActionScope is null or omitted, all Problems for the Encounter will be&lt;br&gt;
deleted.&lt;br&gt;
For any other value of ActionScope (ie unrecognized value), nothing will be&lt;br&gt;
deleted.&lt;br&gt;
The logic to determine whether a Problem is past or present is:&lt;br&gt;
-If the Problem has a ToTime in the past, it's past.&lt;br&gt;
-Else if the Problem has Status.Code="I", it's past.&lt;br&gt;
-Else if Status.SDACodingStandard contains (not necessarily equals)&lt;br&gt;
"SNOMED", case-insensitive, and  Status.Code is one of 73425007, 410516002,&lt;br&gt;
or 413322009 (Inactive, Ruled Out, Resolved), it's past.&lt;br&gt;
-Else the Problem is present.&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionScope is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
EnteredBy is parsed from the first ROL segment following the PRB segment&lt;br&gt;
with ROL-3.1 (Role.Identifier) = "TR" for "Transcriptionist" (from HL7 code&lt;br&gt;
table 2.6:443)&lt;br&gt;&lt;br&gt;
HL7:  ROL&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIUpdateUserDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ROL-1.1 will be used if not null, else the first instance of ROL-4.1 will&lt;br&gt;
be used if not null.&lt;br&gt;
HL7:  ROL-1.1 : RoleInstanceID.EntityIdentifier&lt;br&gt;
HL7:  ROL-4.1 : RolePerson.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Description is parsed from the first instance of ROL-4 (Role Person),&lt;br&gt;
subfields 2.1 (FamilyName.Surname) and 3 (GivenName), formatted as:&lt;br&gt;
"[FamilyName.Surname], [GivenName]".&lt;br&gt;
HL7:  ROL-4.2.1 : RolePerson.FamilyName.Surname&lt;br&gt;
HL7:  ROL-4.3 : RolePerson.GivenName&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ROL-1.1 is non-null, use ROL-1.2 as SDACodingStandard. Else, if the&lt;br&gt;
first instance of ROL-4.1 is non-null, use that instance of ROL-4.9 as&lt;br&gt;
SDACodingStandard.&lt;br&gt;
HL7:  ROL-1.2 : RoleInstanceID.NamespaceID&lt;br&gt;
HL7:  ROL-4.9 : RolePerson.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
MSH-4.1 is parsed as the EnteredAt Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
PRB-15 is used if present, else PRB-2 is used if present.&lt;br&gt;&lt;br&gt;
HL7:  PRB-15 : ProblemLifeCycleStatusDateTime&lt;br&gt;
HL7:  PRB-2 : ActionDateTime&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIDate) + VIEWERLIB: User.HS.MRPresentIllness(PRESITime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
PRB-16 is used if present, else PRB-7 is used if present.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of FromTime is stored in the Viewer Cache.&lt;br&gt;
(PRESIDateOnset is date-only.)&lt;br&gt;&lt;br&gt;
HL7:  PRB-16 : ProblemDateofOnset&lt;br&gt;
HL7:  PRB-7 : ProblemEstablishedDateTime&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIDateOnset)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
PRB-9 is used if present, else PRB-8 is used if present.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Only the date part of ToTime is stored in the Viewer Cache. (PRESIEndDate&lt;br&gt;
is date-only.)&lt;br&gt;&lt;br&gt;
HL7:  PRB-9 : ActualProblemResolutionDateTime&lt;br&gt;
HL7:  PRB-8 : AnticipatedProblemResolutionDateTime&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIEndDate)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>HL7:  PRB-4 : ProblemInstanceID&lt;br&gt;
VIEWERLIB: User.HS.MRPresentIllness(PRESIExternalId)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ProblemExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="BodyPart">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="BodyPartExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodyParts(BODPCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodyParts(BODPDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="BodyPartExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ProblemCategory">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ProblemCategoryExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCPresIllCategory(PRESICCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCPresIllCategory(PRESICDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ProblemCategoryExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfPhysicalExam">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="PhysicalExam" nillable="true" type="PhysicalExam"/>
    </s:sequence>
</s:complexType>
<s:complexType name="PhysicalExam">
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PhysicalExamExtension"/>
        <s:element minOccurs="0" name="PhysExamTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time of exam&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRPhysExamination(PHYSDate) + User.HS.MRPhysExamination(PHYSTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PhysExamCode" type="PhysExam">
            <s:annotation>
                <s:documentation>Code for part of exam&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the PhysicalExam has no&lt;br&gt;
PhysExamCode, then an error will be logged and the Streamlet will not be&lt;br&gt;
saved.&lt;br&gt;&lt;br&gt;
SDATableName=PhysExam, ViewerClass=User.HS.MRCBodyArea&lt;br&gt;
VIEWERLIB: User.HS.MRPhysExamination(PHYSBodyAreaDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PhysExamObs" type="PhysExamObs">
            <s:annotation>
                <s:documentation>Code for observation&lt;br&gt;&lt;br&gt;
SDATableName=PhysExamObs, ViewerClass=User.HS.MRCBodyAreaProblems&lt;br&gt;
VIEWERLIB: User.HS.MRPhysExamination(PHYSMRCBodyAreProbDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PhysExamObsQualifier" type="PhysExamObsQualifier">
            <s:annotation>
                <s:documentation>Code for observation qualifier&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if the PhysicalExam has&lt;br&gt;
a PhysExamObsQualifier but no PhysExamObs, an alert will be logged and the&lt;br&gt;
PhysExamObsQualifier will be removed from the SDA.&lt;br&gt;&lt;br&gt;
SDATableName=PhysExamObsQualifier, ViewerClass=User.HS.MRCBodyAreaProblemsSubp&lt;br&gt;
VIEWERLIB: User.HS.MRPhysExamination(PHYSMRCBodyAreaProbSubDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PhysExamObsValue" type="PhysExamObsValue">
            <s:annotation>
                <s:documentation>Code for observation value&lt;br&gt;&lt;br&gt;
SDATableName=PhysExamObsValue, ViewerClass=User.HS.MRCBodySystemProbStatus&lt;br&gt;
VIEWERLIB: User.HS.MRPhysExamination(PHYSBodyProbStatDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="NoteText" type="s:string">
            <s:annotation>
                <s:documentation>Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRPhysExamination(PHYSDesc)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
C = Clear/Delete All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.MRPhysExamination(PHYSUpdateUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.MRPhysExamination(PHYSUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRPhysExamination(PHYSUpdateDate) + User.HS.MRPhysExamination(PHYSUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PhysicalExamExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PhysExam">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PhysExamExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodyArea(BODARCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodyArea(BODARDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PhysExamExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PhysExamObs">
    <s:annotation>
        <s:documentation>PhysExamObs is processed "in-line" in the Viewer Cache in&lt;br&gt;
web.SDA3.PhysicalExam:UpdatePhysicalExam since it needs to know about its&lt;br&gt;
"parent" PhysExam. PhysExam is not a parent of PhysExamObs in the SDA,&lt;br&gt;
but in the Viewer Cache, MRCBodyArea is the parent of MRCBodyAreaProblems&lt;br&gt;
(relationship PROBParRef). PhysExamObs Codes and Descriptions in the Viewer&lt;br&gt;
Cache are only required to be unique within the parent PhysExam. Codes and&lt;br&gt;
Descriptions may be reused with different parent PhysExams.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PhysExamObsExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodyAreaProblems(PROBCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodyAreaProblems(PROBDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PhysExamObsExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PhysExamObsQualifier">
    <s:annotation>
        <s:documentation>PhysExamObsQualifier is processed "in-line" in the Viewer Cache in&lt;br&gt;
web.SDA3.PhysicalExam:UpdatePhysicalExam since it needs to know about its&lt;br&gt;
"parent" PhysExamObs. PhysExamObs is not a parent of PhysExamObsQualifier&lt;br&gt;
in the SDA, but in the Viewer Cache, MRCBodyAreaProblems is the parent of&lt;br&gt;
MRCBodyAreaProblemsSubp (relationship SUBPParRef). PhysExamObsQualifier&lt;br&gt;
Codes and Descriptions in the Viewer Cache are only required to be unique&lt;br&gt;
within the parent PhysExamObs. Codes and Descriptions may be reused with&lt;br&gt;
a different parent PhysExamsObs.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PhysExamObsQualifierExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodyAreaProblemsSubp(SUBPCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodyAreaProblemsSubp(SUBPDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PhysExamObsQualifierExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PhysExamObsValue">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PhysExamObsValueExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodySystemProbStatus(STATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCBodySystemProbStatus(STATDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PhysExamObsValueExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfProcedure">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Procedure" nillable="true" type="Procedure"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Procedure">
    <s:annotation>
        <s:documentation>HS.SDA3.Procedure corresponds to the CDA Procedures section, also known
as Procedures and Interventions, or History of Procedures.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ProcedureExtension"/>
        <s:element minOccurs="0" name="Procedure" type="ProcedureCode">
            <s:annotation>
                <s:documentation>Procedure code&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PR1-3 will be used if subfield 1 or 2 is not null. Else, PR1-4 will be&lt;br&gt;
used. In this case, PR1-4 will be parsed to the Procedure Code. HL7ToSDA3&lt;br&gt;
will not set the Description.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet cache, if the SDA contains no&lt;br&gt;
Procedure, an error will be logged and the Streamlet will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  PR1-3 : ProcedureCode&lt;br&gt;
HL7:  PR1-4 : ProcedureDescription&lt;br&gt;
SDATableName=Procedure, ViewerClass=User.HS.ORCOperation&lt;br&gt;
VIEWERLIB: User.HS.MRProcedures(PROCOperationDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PR1-3.1 : ProcedureCode.Identifier&lt;br&gt;
HL7:  PR1-4 : ProcedureDescription&lt;br&gt;
VIEWERLIB: User.HS.ORCOperation(OPERCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  PR1-3.2 : ProcedureCode.Text&lt;br&gt;
VIEWERLIB: User.HS.ORCOperation(OPERDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PR1-3.3 : ProcedureCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to subfield 1 or 2 not being null, if subfield 4 or 5 of PR1-3&lt;br&gt;
is not null, then then subfields 4, 5, and 6 will be parsed to the Code,&lt;br&gt;
Description, and CodeSystem of a PriorCode in the SDA. The Type will be&lt;br&gt;
parsed as "A".&lt;br&gt;
HL7:  PR1-3.4 : ProcedureCode.AlternateIdentifier&lt;br&gt;
HL7:  PR1-3.5 : ProcedureCode.AlternateText&lt;br&gt;
HL7:  PR1-3.6 : ProcedureCode.NameofAlternateCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Subfield 9 of PR1-3 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;
HL7:  PR1-3.9 : ProcedureCode.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Clinician" type="CareProvider">
            <s:annotation>
                <s:documentation>Clinician who performed procedure&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though PR1-11 is a repeating field, only the first instance is used.&lt;br&gt;&lt;br&gt;
HL7:  PR1-11 : Surgeon&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.MRProcedures(PROCCTCPDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  PR1-11.1 : Surgeon.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Description is parsed from the first instance of PR1-11, subfields 2.1&lt;br&gt;
(FamilyName.Surname) and 3 (GivenName), formatted as:&lt;br&gt;
"[FamilyName.Surname], [GivenName]".&lt;br&gt;
HL7:  PR1-11.2.1 : Surgeon.FamilyName.Surname&lt;br&gt;
HL7:  PR1-11.3 : Surgeon.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  PR1-11.9 : Surgeon.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  PR1-11.2.1 : Surgeon.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  PR1-11.3 : Surgeon.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  PR1-11.4 : Surgeon.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  PR1-11.6 : Surgeon.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  PR1-11.5 : Surgeon.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  PR1-11.21 : Surgeon.ProfessionalSuffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Devices" type="ArrayOfDevice">
            <s:annotation>
                <s:documentation>Devices that were implanted or attached as part of this procedure.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ProcedureTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time of the procedure&lt;br&gt;&lt;br&gt;
HL7:  PR1-5.1 : ProcedureDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.MRProcedures(PROCProcDate) + User.HS.MRProcedures(PROCTimeStart)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.MRProcedures(PROCUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
MSH-4.1 is parsed to the EnteredAt Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.MRProcedures(PROCUpdateHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRProcedures(PROCDate) + User.HS.MRProcedures(PROCTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>HL7:  PR1-19.1 : ProcedureIdentifier.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.MRProcedures(PROCExternalId)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
C = Clear/Delete All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7:  PR1-20 : ProcedureActionCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ProcedurePriority" type="s:string">
            <s:annotation>
                <s:documentation>The priority of the procedure&lt;br&gt;
The value 1 means that this is the primary procedure. Values 2-99 convey ranked secondary procedures.&lt;br&gt;&lt;br&gt;
HL7:  PR1-14 : ProcedurePriority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ProcedureExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ProcedureCode">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ProcedureCodeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ORCOperation(OPERCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ORCOperation(OPERDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ProcedureCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfDevice">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Device" nillable="true" type="Device"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Device">
    <s:annotation>
        <s:documentation>Class to represent device for MU3 UDI requirements</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="DeviceExtension"/>
                <s:element minOccurs="0" name="Device" type="DeviceCode">
                    <s:annotation>
                        <s:documentation>Coded value for device type (e.g. implantable pacemaker)</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="UDIRoot" type="s:string">
                    <s:annotation>
                        <s:documentation>Root of Unique Device Identifier, typically FDA OID</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="UDIExtension" type="s:string">
                    <s:annotation>
                        <s:documentation>Extension of Unique Device Identifier, a globally unique string that identifies device</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="UDIAssigningAuthority" type="s:string">
                    <s:annotation>
                        <s:documentation>Assigning Authority for Unique Device Identifier, typically FDA</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="DeviceExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DeviceCode">
    <s:annotation>
        <s:documentation>Medical device to satistisfy MU3 UDI requirements</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableDetail">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="DeviceCodeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="DeviceCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfDocument">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Document" nillable="true" type="Document"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Document">
    <s:annotation>
        <s:documentation>The logic defining how the &lt;property&gt;DocumentURL&lt;/property&gt;,
&lt;property&gt;NoteText&lt;/property&gt;, &lt;property&gt;FileType&lt;/property&gt;, and
&lt;property&gt;Stream&lt;/property&gt; properties are parsed from an HL7 MDM^T02
message in HL7ToSDA3 is as follows:
&lt;ol&gt;
&lt;li&gt;If OBX-2 (Value Type) of the first OBX is "RP" (for "Reference
    Pointer"), then OBX-5.1 (Observation Value.Pointer) of that segment is
    parsed as &lt;property&gt;DocumentURL&lt;/property&gt;. If this segment is followed
    by anything other than an OBX (ie NTE) the remaining segments will not
    be parsed. If this segment is followed by additional OBXs (possibly
    with NTEs mixed in), then all the remaining OBX-5 and NTE-3 values will
    be parsed as &lt;property&gt;NoteText&lt;/property&gt;, with each segment being
    parsed as a new line.&lt;/li&gt;
&lt;li&gt;Else, if OBX-2 of the first OBX is "ED" (for "Encapsulated
    Data") then OBX-5.3 (Observation Value.Data Subtype) of that segment
    will be parsed as &lt;property&gt;FileType&lt;/property&gt;. All OBX-5.5 (.Data)
    and NTE-3 values will be parsed (with each segment being parsed as a
    new line) as the &lt;property&gt;Stream&lt;/property&gt; property, after being
    Base64-encoded if they are not already. HL7ToSDA3 will look at OBX-5.4
    (.Encoding) of the first OBX to determine if the data is already
    Base64-encoded. (OBX-5.4="BASE64" (case-insensitive) -&gt; data is already
    encoded; else -&gt; data is not encoded)&lt;/li&gt;
&lt;li&gt;Else, if the first characters of the first OBX-5.1 are "{\rtf",
    &lt;property&gt;FileType&lt;/property&gt; is set to "RTF", and all of the OBX-5 and NTE-3 values are
    parsed (with each segment being a new line) as the &lt;property&gt;Stream&lt;/property&gt; property,
    after being Base64-encoded.&lt;/li&gt;
&lt;li&gt;Else each OBX-5 and NTE-3 value is parsed as plaintext (with each
    segment being parsed as a new line) into the &lt;property&gt;NoteText&lt;/property&gt; property.&lt;/li&gt;
&lt;/ol&gt;</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DocumentExtension"/>
        <s:element minOccurs="0" name="DocumentTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>This contains the date of the activity that the document is reporting.&lt;br&gt;
For example, with a Discharge Summary this should be the date/time of the&lt;br&gt;
discharge, while TranscriptionTime would be the date/time the summary was&lt;br&gt;
put together, and AuthorizationTime the date/time when the doctor signed&lt;br&gt;
the summary.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If null, this will be defaulted to TranscriptionTime, then&lt;br&gt;
AuthorizationTime, then EnteredOn, and finally to the current time if all&lt;br&gt;
of those are null.&lt;br&gt;&lt;br&gt;
HL7:  TXA-4.1 : ActivityDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTActivityDate) + User.HS.MRNursingNotes(NOTActivityTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="NoteText" type="s:string">
            <s:annotation>
                <s:documentation>This property is used when the Note is either plain or marked up text e.g&lt;br&gt;
TX, FT, HTML.  CRLF-delimited.&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
See class annotation.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the Document does not&lt;br&gt;
have a DocumentURL, NoteText, or Stream and FileType, then an error will be&lt;br&gt;
logged and the Streamlet will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5 : ObservationValue&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTNotes)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DocumentType" type="DocumentType">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
TXA-2 is parsed to DocumentType.Code. If TXA-2 is "DS", Description is&lt;br&gt;
parsed as "DischargeSummary" so that the Document will appear on the&lt;br&gt;
Discharge Summaries chart in the default Clinical Viewer layout. Otherwise&lt;br&gt;
HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the Document has a DocumentType, and &lt;br&gt;
DocumentType.Code is not an OID, set InfoSubType to DocumentType.Code, converted to &lt;br&gt;
uppercase.  If DocumentType.Code is an OID and DocumentType.Description is present, &lt;br&gt;
set InfoSubType to DocumentType.Description, converted to uppercase.&lt;br&gt;&lt;br&gt;
HL7:  TXA-2 : DocumentType&lt;br&gt;
SDATableName=DocumentType, ViewerClass=User.HS.MRCClinNotesType&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTClinNotesTypeDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Clinician" type="CareProvider">
            <s:annotation>
                <s:documentation>The name of the clinician who performed the activity and originated the&lt;br&gt;
Note. This may not be the same as the EnteredBy if the Note was&lt;br&gt;
transcribed.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though TXA-5 is a repeating field, HL7ToSDA3 will only parse the first instance.&lt;br&gt;&lt;br&gt;
HL7:  TXA-5 : PrimaryActivityProviderCodeName&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTNurseIdDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  TXA-5.1 : IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  TXA-5.2.1 : PrimaryActivityProviderCodeName.FamilyName.Surname&lt;br&gt;
HL7:  TXA-5.3 : PrimaryActivityProviderCodeName.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  TXA-5.9 : PrimaryActivityProviderCodeName.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  TXA-5.2.1 : PrimaryActivityProviderCodeName.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  TXA-5.3 : PrimaryActivityProviderCodeName.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  TXA-5.4 : PrimaryActivityProviderCodeName.SecondandFurtherGivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  TXA-5.6 : PrimaryActivityProviderCodeName.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  TXA-5.5 : PrimaryActivityProviderCodeName.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  TXA-5.21 : PrimaryActivityProviderCodeName.ProfessionalSuffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="TranscriptionTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The time that the document was transcribed&lt;br&gt;&lt;br&gt;
HL7:  TXA-7.1 : TranscriptionDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTCreateDate) + User.HS.MRNursingNotes(NOTCreateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AuthorizationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The time that the document was authorised.&lt;br&gt;&lt;br&gt;
HL7:  TXA-22.15 : AuthenticationPersonTimeStamp.DateTimeActionPerformed&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTDateAuth) + User.HS.MRNursingNotes(NOTTimeAuth)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DocumentName">
            <s:annotation>
                <s:documentation>The name of the document.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if DocumentName is null,&lt;br&gt;
it will be defaulted to DocumentURL, then to FileType.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If not null, the DocumentName is what will appear in the Clinical Viewer&lt;br&gt;
in the Document column, that the user may click to see the document.&lt;br&gt;
Otherwise, the first few characters of the NoteText will appear in this&lt;br&gt;
column.&lt;br&gt;&lt;br&gt;
HL7:  TXA-16 : UniqueDocumentFileName&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTDocumentName)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FileType" type="s:string">
            <s:annotation>
                <s:documentation>The type of data e.g PDF, DOC, RTF, TXT&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
See class annotation.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the Document does not&lt;br&gt;
have a DocumentURL, NoteText, or Stream and FileType, then an error will be&lt;br&gt;
logged and the streamlet will not be saved. Also, if the DocumentName is&lt;br&gt;
null, it will be defaulted to the DocumentURL, then to the FileType.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The list of FileTypes that the Clinical Viewer supports for Documents is&lt;br&gt;
contained in the ValidTypes parameter of the websys.Document class.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5.3 : ObservationValue.EDDataSubType&lt;br&gt;
VIEWERLIB:  User.HS.MRNursingNotes(NOTDocumentDR)-&gt;websys.Document(docType)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Stream" type="s:base64Binary">
            <s:annotation>
                <s:documentation>This property is used when the Note is binary data, e.g DOC, PDF, JPG&lt;br&gt;&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
Note that because of the type of this property (%GlobalBinaryStream),&lt;br&gt;
character data written to it must be single-width, ie, no double-wide&lt;br&gt;
Unicode characters. On export, the content will be Base64 encoded, and on&lt;br&gt;
import, Base64 decoded.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
See class annotation.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the Document does not&lt;br&gt;
have a DocumentURL, NoteText, or Stream and FileType, then an error will be&lt;br&gt;
logged and the Streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The list of FileTypes that the Clinical Viewer supports for Documents is&lt;br&gt;
contained in the ValidTypes parameter of the websys.Document class.&lt;br&gt;
Note that the DataId property of websys.Document is not a designative&lt;br&gt;
reference (so the COS syntax document.DataId.docData will not work) but&lt;br&gt;
rather a string field containing the ID of the linked websys.Documentxxx&lt;br&gt;
(where "xxx" is the FileType).&lt;br&gt;
If the value of the Configuration Registry key&lt;br&gt;
"\Viewer\SDA3DocumentStreamEncoded" is "1", then the content of Stream will&lt;br&gt;
be converted from UTF-8 output format (ie, $ZCVT(,"I","UTF8")) before being&lt;br&gt;
inserted into the Viewer Cache. This is useful in cases where the original&lt;br&gt;
document data contained double-wide Unicode characters that had to be&lt;br&gt;
converted to UTF-8 output format before being written to the stream, since&lt;br&gt;
it cannot contain double-wide characters.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5.5 : ObservationValue.EDData&lt;br&gt;
HL7:  NTE-3 : Comments&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTDocumentDR)-&gt;websys.Document(DataId)-&gt;websys.Documentxxx(docData)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DocumentURL">
            <s:annotation>
                <s:documentation>The full URL where the document can be accessed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
See class annotation.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the Document does not&lt;br&gt;
have a DocumentURL, NoteText, or Stream and FileType, then an error will be&lt;br&gt;
logged and the streamlet will not be saved. Also, if the DocumentName is&lt;br&gt;
null, it will be defaulted to the DocumentURL, then to the FileType.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5.1 : ObservationValue.Pointer&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTDocumentURL)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="DocumentNumber">
            <s:annotation>
                <s:documentation>Used as an external reference ID.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if DocumentNumber is&lt;br&gt;
null, it will be defaulted to the ExternalId.&lt;br&gt;&lt;br&gt;
HL7:  TXA-12.1 : UniqueDocumentNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTExternalRef)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Facilities" type="ArrayOfOrganization">
            <s:annotation>
                <s:documentation>List of facilities that have contributed to this document&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(ChildMRNursingNotesHosp)-&gt;User.HS.MRNursingNotesHosp(NOTHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status" type="DocumentStatus">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
TXA-19 is parsed as the Status Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the Document has no&lt;br&gt;
Status, one will be defaulted with Code="AV" and Description="Available for&lt;br&gt;
patient care".&lt;br&gt;&lt;br&gt;
HL7:  TXA-19 : DocumentAvailabilityStatus&lt;br&gt;
SDATableName=DocumentStatus, ViewerClass=User.HS.MRCNursingNotesStatus&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTStatusDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DocumentCompletionStatus" type="DocumentCompletionStatus">
            <s:annotation>
                <s:documentation>This is the status of the creation of the Note, such as Incomplete, In Progress,&lt;br&gt;
or Authenticated.
HL7ToSDA3:&lt;br&gt;
TXA-17 is parsed as the Document Completion Status.  HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
HL7:  TXA-17 : DocumentCompletionStatus&lt;br&gt;
SDATableName=DocumentCompletionStatus&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The time that any action or treatment was instigated.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTActionTakenDate) + User.HS.MRNursingNotes(NOTActionTakenTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>D = Delete&lt;br&gt;
I = Inactivate All (set Status.Code="UN", Description="Unavailable for patient care")&lt;br&gt;
C = Clear All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in TXA-1 is parsed as ActionCode="I", and four&lt;br&gt;
double quotes ("""") as ActionCode="C". In either case no further parsing&lt;br&gt;
is done on the TXA segment. If the HL7 message is an MDM_T11 (Document&lt;br&gt;
cancel notification), ActionCode will be parsed as "D".&lt;br&gt;&lt;br&gt;
HL7:  TXA-1 : SetIDTXA&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>This is the person who entered the Note, perhaps from a dictation.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though TXA-9 is a repeating field, HL7ToSDA3 will only use the first&lt;br&gt;
instance.&lt;br&gt;&lt;br&gt;
HL7:  TXA-9 : OriginatorCodeName&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTUserDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  TXA-9.1 : OriginatorCodeName.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  TXA-9.2.1 : OriginatorCodeName.FamilyName.Surname&lt;br&gt;
HL7:  TXA-9.3 : GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  TXA-9.9 : OriginatorCodeName.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
MSH-4.1 is parsed as the EnteredAt Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if EnteredOn is null, it&lt;br&gt;
will be defaulted to the current date/time.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTDate) + User.HS.MRNursingNotes(NOTTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if DocumentNumber is&lt;br&gt;
null, it will be defaulted to ExternalId.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.MRNursingNotes(NOTExternalId)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DocumentExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DocumentType">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DocumentTypeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCClinNotesType(CNTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCClinNotesType(CNTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DocumentTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfOrganization">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Organization" nillable="true" type="Organization"/>
    </s:sequence>
</s:complexType>
<s:complexType name="DocumentStatus">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DocumentStatusExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCNursingNotesStatus(NNSCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.MRCNursingNotesStatus(NNSDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DocumentStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DocumentCompletionStatus">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DocumentCompletionStatusExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DocumentCompletionStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfLabOrder">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="LabOrder" nillable="true" type="LabOrder"/>
    </s:sequence>
</s:complexType>
<s:complexType name="LabOrder">
    <s:sequence>
        <s:element minOccurs="0" name="PlacerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the PlacerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId. If the PlacerId, FillerId, ExternalId, and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the LabOrder&lt;br&gt;
will not be processed. If the LabOrder has no OrderItem and does not match&lt;br&gt;
exactly 1 other LabOrder in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId, which itself may have been&lt;br&gt;
defaulted to the Result ExternalId. If PlacerId, FillerId, ExternalId and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the Order will&lt;br&gt;
not be processed. If the Order has no OrderItem and does not match exactly&lt;br&gt;
1 other Order of the same type in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the Order will not be processed.&lt;br&gt;
-MED,VXU:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId. If the Order has no OrderItem&lt;br&gt;
or DrugProduct and does not match exactly 1 other Order of the same type in&lt;br&gt;
the same Encounter on PlacerId (ALPHAUP collated), an error will be logged&lt;br&gt;
and the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPlacerNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-2 will be used if a value can be parsed from it, else ORC-2 will be&lt;br&gt;
used. In either case, PlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the FillerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId, then to PlacerId, which itself&lt;br&gt;
may have been defaulted to ExternalId. If FillerId, PlacerId, ExternalId,&lt;br&gt;
and Result.ExternalId are all null, an error will be logged and the&lt;br&gt;
LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId. If FillerId, PlacerId,&lt;br&gt;
ExternalId, and Result.ExternalId are all null, an error will be logged and&lt;br&gt;
the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId. Also for LabOrders only, the stored&lt;br&gt;
value for FillerId in the Viewer Cache is required to be unique. If an&lt;br&gt;
inbound LabOrder.FillerId matches one already in the Viewer Cache (if the&lt;br&gt;
same patient record has been loaded multiple times, for example), the&lt;br&gt;
inbound value is made unique by appending "x[OEORDId]" to it, where&lt;br&gt;
"[OEORDId]" is the ID of the parent OEOrder to the OEOrdItem that the&lt;br&gt;
LabOrder is stored as.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIFillerNo)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabEpisodeNo)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3 will be used if a value can be parsed from it, else ORC-3 will be&lt;br&gt;
used. In either case, FillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OrderItem" type="Order">
            <s:annotation>
                <s:documentation>What was ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-4 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Medications and Vaccinations, in the OnBeforeMatch method of the&lt;br&gt;
Streamlet class, if the Order has no OrderItem but does have a DrugProduct,&lt;br&gt;
then an OrderItem will be defaulted in with Code, Description, and&lt;br&gt;
SDACodingStandard copied from the DrugProduct. For all types of Orders (and&lt;br&gt;
for Medications and Vaccinations, following this defaulting), if the Order&lt;br&gt;
has no OrderItem and does not match exactly 1 other Order of the same type&lt;br&gt;
in the same Encounter on PlacerId (ALPHAUP collated), an error will be&lt;br&gt;
logged and the Order will not be processed. In the OnValidate method, if&lt;br&gt;
the Order does not have an OrderItem (if it was deleted in an update, for&lt;br&gt;
example), an error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7: OBR-4 : UniversalServiceIdentifier&lt;br&gt;
SDATableName=Order, ViewerClass=User.HS.ARCItmMast&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItmMastDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
Viewer cache:&lt;br&gt;
TRName is for text results only.&lt;br&gt;
HL7:  OBR-4.1 : UniversalServiceIdentifier.Identifier&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMCode)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRName)&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-4.2 : UniversalServiceIdentifier.Text&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-4.3 : UniversalServiceIdentifier.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-4.7 : UniversalServiceIdentifier.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to subfield 1 or 2 not being null, if subfield 4 or 5 is not&lt;br&gt;
null, then subfields 4, 5, 6, and 8 will be parsed into the Code,&lt;br&gt;
Description, CodeSystem, and CodeSystemVersionId, respectively, of a&lt;br&gt;
PriorCode in the list of PriorCodes. In this case, the PriorCode Type is&lt;br&gt;
set to "A".&lt;br&gt;
HL7:  OBR-4.4 : UniversalServiceIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-4.5 : UniversalServiceIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-4.6 : UniversalServiceIdentifier.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-4.8 : UniversalServiceIdentifier.AlternateCodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  OBR-4.9 : UniversalServiceIdentifier.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderCategory" type="OrderCategory">
            <s:annotation>
                <s:documentation>Can be used to group orders in the Clinical Viewer.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-24 is parsed to the OrderCategory Code. HL7ToSDA3 does not set the&lt;br&gt;
Description. The parsed value is converted to uppercase in the SDA.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For all Order types, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order has an OrderCategory, then the InfoSubType of the streamlet is&lt;br&gt;
set to the OrderCategory Code, converted to uppercase.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The OrderCategory is stored as a property of the ARCItmMast (OrderItem),&lt;br&gt;
which is itself a property of the OEOrderItem (Order).&lt;br&gt;&lt;br&gt;
HL7:  OBR-24 : DiagnosticServSectID&lt;br&gt;
SDATableName=OrderCategory, ViewerClass=User.HS.ARCItemCat&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMItemCatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderQuantity" type="s:string">
            <s:annotation>
                <s:documentation>Number of items ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderQuantity is parsed from (in order of precendence) TQ1-2.1, RXE-1.1.1,&lt;br&gt;
OBR-27.1.1, or ORC-7.1.1. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Quantity in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  OBR-27.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  RXE-1.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  TQ1-2.1   : Quantity.Quantity&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>Who placed the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderedBy is parsed from (in order of precendence) OBR-16, RXO-14, RXE-13,&lt;br&gt;
or ORC-12 and -24. Though each of these fields is repeating, for each one&lt;br&gt;
except ORC-24, HL7ToSDA3 will only parse the first non-null instance. For&lt;br&gt;
ORC-24, the instance corresponding to the first non-null instance of ORC-12&lt;br&gt;
will be parsed. ORC-12 and -24 are used in combination to set the&lt;br&gt;
provider's Name and Address in the SDA. Every other field only sets the&lt;br&gt;
Name. For Adress.City, .State, .Zip, .Country, and .County as well as NameTypeCode&lt;br&gt;
and IdentifierTypeCode, only the Code is parsed. HL7ToSDA3 does not set the&lt;br&gt;
Description. Note that an RDE_O11 message technically can contain both an&lt;br&gt;
RXO segment and an RXE, however HL7ToSDA3 does not parse the RXO segment&lt;br&gt;
from an RDE message.&lt;br&gt;&lt;br&gt;
HL7:  ORC-12 : OrderingProvider&lt;br&gt;
HL7:  ORC-24 : OrderingProviderAddress&lt;br&gt;
HL7:  RXE-13 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  RXO-14 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  OBR-16 : OrderingProvider&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDoctorDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-12.1 : OrderingProvider.IDNumber&lt;br&gt;
HL7:  RXE-13.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  RXO-14.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  OBR-16.1 : OrderingProvider.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-12.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
HL7:  RXE-13.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  RXO-14.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  OBR-16.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-12.4 : OrderingProvider.MiddleName&lt;br&gt;
HL7:  RXE-13.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  RXO-14.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  OBR-16.4 : OrderingProvider.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-12.6 : OrderingProvider.NamePrefix&lt;br&gt;
HL7:  RXE-13.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  RXO-14.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  OBR-16.6 : OrderingProvider.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-24.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-24.1.1.&lt;br&gt;
HL7:  ORC-24.1.1 : OrderingProviderAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-24.2 : OrderingProviderAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPStName)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-24.3 : OrderingProviderAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCityDR)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-24.4 : OrderingProviderAddress.StateorProvince&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-24.5 : OrderingProviderAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-24.6 : OrderingProviderAddress.Country&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-24.9 : OrderingProviderAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.NameTypeCode&lt;br&gt;
HL7:  OBR-16.10 : OrderingProvider.NameTypeCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.IdentifierTypeCode&lt;br&gt;
HL7:  OBR-16.13 : OrderingProvider.IdentifierTypeCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteringOrganization" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Entering Facility (Location)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-13 is only parsed if subfield 1 is not null. Only the Code is parsed.&lt;br&gt;
HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
HL7:  ORC-13.1 : EnterersLocation.PointofCare&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIOrdDeptDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Only the Code is parsed. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>VerifiedBy (CareProvider)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-32 will be used if present, else the first non-null instance of ORC-11&lt;br&gt;
will be used, if there is one.&lt;br&gt;&lt;br&gt;
HL7:  ORC-11 : VerifiedBy&lt;br&gt; 
HL7:  OBR-32 : PrincipalResultInterpreter&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthoriseClinicianDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-11.1 : VerifiedBy.IDNumber&lt;br&gt;
HL7:  OBR-32.1.1 : PrincipalResultInterpreter.Name.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields, the given and family names are concatenated together as&lt;br&gt;
"[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-11.9 : VerifiedBy.AssigningAuthority&lt;br&gt;
HL7:  OBR-32.1.9 : PrincipalResultInterpreter.Name.AssigningAuthorityNamespaceID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-11.4 : VerifiedBy.SecondandFurtherGivenNames&lt;br&gt;
HL7:  OBR-32.1.4 : PrincipalResultInterpreter.Name.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-11.6 : VerifiedBy.Prefix&lt;br&gt;
HL7:  OBR-32.1.6 : PrincipalResultInterpreter.Name.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  ORC-11.7 : VerifiedBy.Degree&lt;br&gt;
HL7:  OBR-32.1.5 : PrincipalResultInterpreter.Name.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  OBR-32.1.7 : PrincipalResultInterpreter.Name.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CallbackNumber">
            <s:annotation>
                <s:documentation>Callback number (who to contact with questions, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-17 is used if any regular (business), mobile, or fax numbers or e-mail&lt;br&gt;
addresses can be parsed from it, else ORC-14 is used. In either case, the&lt;br&gt;
format of CallbackNumber is: "[List of business #s], Mobile: [List of&lt;br&gt;
mobile #s], Fax: [List of fax #s], email: [List of e-mail addresses]". Each&lt;br&gt;
list is comma-delimited. Each tag (Mobile, Fax, email) will only be used if&lt;br&gt;
there are elements of that type. For each field, every instance will be&lt;br&gt;
parsed, if that field is used. Up to three numbers can be parsed from each&lt;br&gt;
instance of a field:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, a number is parsed from them&lt;br&gt;
as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-If subfield 12 is not null, it is parsed.&lt;br&gt;
-If subfield 1 is not null, it is parsed.&lt;br&gt;
-Additionally, if subfield 9 is not null, the first number parsed from that&lt;br&gt;
instance will have it appended to the end after a semicolon separator.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;
The logic to determine the type of the number is:&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 is in ["",PH], the&lt;br&gt;
number is a regular (business) number.&lt;br&gt;
-If subfield 2 = "BPN" and subfield 3 is in [CP,BP], the number is a mobile&lt;br&gt;
number.&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 = "FX", the number is&lt;br&gt;
a fax number.&lt;br&gt;
Finally, each non-null instance of subfield 4 is parsed as an e-mail&lt;br&gt;
address.&lt;br&gt;&lt;br&gt;
HL7:  OBR-17 : OrderCallbackPhoneNumber&lt;br&gt;
HL7:  ORC-14 : CallBackPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINotify)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Specimen">
            <s:annotation>
                <s:documentation>Specimen code or description as a string&lt;br&gt;
Not to be confused with the Specimens property of LabOrder, RadOrder, and&lt;br&gt;
OtherOrder, which is of type List of HS.SDA3.Specimen.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-15.1.2 will be used if not null, else OBR-15.1.1 will be used.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Specimen is inserted into the Viewer Cache as a CTSpecimen with SPECCode&lt;br&gt;
and SPECDesc=[Specimen]. The CTSpecimen is the linked to the ARCItmMast&lt;br&gt;
(OrderItem) via an ARCItemSpecimen. Specimen is also inserted as an&lt;br&gt;
OEOrdSpecimen (with SPECCode=[Specimen]) that is linked to the OEOrdItem&lt;br&gt;
(Order). Note that backslash ("\") is a reserved character for the&lt;br&gt;
CTSpecimen table, so Specimen should not contain a backslash.&lt;br&gt;&lt;br&gt;
HL7: OBR-15 : SpecimenSource&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.CTSpecimen&lt;br&gt;
VIEWERLIB: User.HS.OEOrdSpecimen(SPECCode)&lt;br&gt;
VIEWERLIB: User.HS.CTSpecimen(SPECCode) + User.HS.CTSpecimen(SPECDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="SpecimenCollectedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the specimen was collected&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-7.1 and SPM-17.1 represent the same value and therefore should contain&lt;br&gt;
the same value if both are present, however HealthShare does not enforce&lt;br&gt;
this. SPM-17.1 is parsed to Specimen.FromTime.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIEpisArriveDate and OEORIEpisArriveTime are only set for Lab, Rad, and&lt;br&gt;
Other Orders, not Medications or Vaccinations. SPECDate and SPECTime are&lt;br&gt;
only set if the Order contains a Specimen (the string property, not an&lt;br&gt;
HS.SDA3.Specimen). The properties of lab.HS.EPVisitNumber and&lt;br&gt;
EPVisitTestSet are set for atomic results only. Note that while&lt;br&gt;
VISTSTimeOfCollection is a %Time, EPVISTimeOfCollection is not. It is a&lt;br&gt;
%String value containing the time as a number of minutes since midnight.&lt;br&gt;&lt;br&gt;
HL7:  OBR-7.1 : ObservationDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEpisArriveDate) + User.HS.OEOrdItem(OEORIEpisArriveTime)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdSpecimen(SPECDate) + User.HS.OEOrdSpecimen(SPECTime)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitNumber(EPVISDateOfCollection) + lab.HS.EPVisitNumber(EPVISTimeOfCollection)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSet(VISTSDateOfCollection) + lab.HS.EPVisitTestSet(VISTSDateOfCollection)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenReceivedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the specimen was received&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORILabReceiveDate and OEORILabReceiveTime are only set for Lab, Rad, and&lt;br&gt;
Other Orders, not Medications or Vaccinations. The properties of&lt;br&gt;
lab.HS.EPVisitNumber are set for atomic results only. Note that&lt;br&gt;
EPVISTimeOfReceiving is not a %Time but rather a %String value containing&lt;br&gt;
the time as a number of minutes since midnight.&lt;br&gt;&lt;br&gt;
HL7: OBR-14.1 : SpecimenReceivedDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabReceiveDate) + User.HS.OEOrdItem(OEORILabReceiveTime)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitNumber(EPVISDateOfReceiving) + lab.HS.EPVisitNumber(EPVISTimeOfReceiving)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReassessmentTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>If the Order is not final, this is the date/time when it should be reviewed&lt;br&gt;
and perhaps finalized.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIReassessmentDate) + User.HS.OEOrdItem(OEORIReassessmentTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Frequency" type="Frequency">
            <s:annotation>
                <s:documentation>How often (e.g. Code=QID, Desc=QID, Factor=4)&lt;br&gt;
QID is Latin, meaning 4x a day.  BID means 2x day, etc.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though TQ1-3 is a repeating field, HL7ToSDA3 will only parse the first&lt;br&gt;
non-null instance.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Frequency, then that&lt;br&gt;
Frequency will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-3 : RepeatPattern&lt;br&gt;
SDATableName=Frequency, ViewerClass=User.HS.PHCFreq&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPHFreqDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  TQ1-3.1.1 : RepeatPattern.RepeatPatternCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-3.1.2 : RepeatPattern.RepeatPatternCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7:  TQ1-3.5 : RepeatPattern.PeriodQuantity&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRFactor)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Duration" type="Duration">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Duration is parsed from (in order of precedence) TQ1-6, RXE-1.3, OBR-27.3,&lt;br&gt;
or ORC-7.3. The RXE, OBR, and ORC fields will only set the Duration Code.&lt;br&gt;
TQ1-6 will populate the Code, Description, and Factor as described below.&lt;br&gt;
Though ORC-7 is a repeating field, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance. OBR-27 is also a repeating field, and HL7ToSDA3 parses every&lt;br&gt;
non-null instance of it. The last non-null instance of Duration in OBR-27&lt;br&gt;
is the one that takes precedence. Note that an RDE_O11 message may contain&lt;br&gt;
TQ1 segments in two different places. HL7ToSDA3 parses the one following&lt;br&gt;
the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Duration, then that Duration&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  TQ1-6 : ServiceDuration&lt;br&gt;
SDATableName=Duration, ViewerClass=User.HS.PHCDuration&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDuratDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
When parsing the TQ1-6 field, Code is initially parsed from subfield 2.1&lt;br&gt;
(Units.Identifier). If subfield 1 (Quantity) is not null, then if subfields&lt;br&gt;
2.1 and 2.2 (Units.Text) are null, Code will be parsed from Quantity. Then,&lt;br&gt;
if Quantity starts with a non-zero number and the parsed value for Code&lt;br&gt;
does not, the parsed value for Code is set to +[Quantity]_[Code]. For&lt;br&gt;
example, if Quantity="2" and Units.Identifier="D", the value parsed to Code&lt;br&gt;
is "2D". For the other segments that Duration Code may be parsed from (RXE,&lt;br&gt;
OBR, ORC), the value is simply parsed from the field listed below.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null and +[Quantity] is logically "true",&lt;br&gt;
and if TQ1-6.2.2 (Units.Text) is not null and +[Units.Text] is logically&lt;br&gt;
"false" (basically, if Quantity starts with a number and Units.Text&lt;br&gt;
doesn't), then the value parsed to Description is&lt;br&gt;
+[Quantity]_" "_[Units.Text]. For example, if Quantity="2" and&lt;br&gt;
Units.Text="Days", the value parsed to Description is "2 Days". If these&lt;br&gt;
conditions are not all met then the Description is simply parsed from&lt;br&gt;
TQ1-6.2.2.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null, then if +[Quantity] is logically "true",&lt;br&gt;
Factor is parsed as +[Quantity], otherwise Factor is parsed as null. If&lt;br&gt;
Quantity is null, then if +[TQ1-2.1/Units.Identifier] is logically "true",&lt;br&gt;
Factor is parsed as +[Units.Identifier], else if +[TQ1-2.2/Units.Text] is&lt;br&gt;
logically "true", Factor is parsed as +[Units.Text], else Factor is not&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUFactor)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status">
            <s:annotation>
                <s:documentation>The current status of the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The following values are mapped in the HL7 to SDA3 parsing:&lt;br&gt;
DC-&gt;D, CA-&gt;C, RP-&gt;R, HD-&gt;H, SC-&gt;IP, CM-&gt;E, [Other]-&gt;unchanged&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For any type of Order, in the OnValidate method of the streamlet class, if&lt;br&gt;
Status is null, it is defaulted to "V" for "Verified". Then, for Orders&lt;br&gt;
that can have results (LabOrder, RadOrder, OtherOrder), if the Order has a&lt;br&gt;
Result, Status is set to "E" for "Executed", unless it is "D", "C", "R", or&lt;br&gt;
"H" (for Discontinued, Cancelled, Replaced, or On Hold, respectively). The&lt;br&gt;
reasoning behind setting the Status to "E" is that if the Order has a&lt;br&gt;
Result, then it must have been executed. The reasoning behind the&lt;br&gt;
exceptions to this is that those particular statuses may have been entered&lt;br&gt;
after the Result was submitted. Also, for any type of Order, when Orders of&lt;br&gt;
of that type are inactivated with ActionCode="I", the Status of each will&lt;br&gt;
be set to "I".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Status is stored in the Viewer Cache as an OECOrderStatus with OSTATCode&lt;br&gt;
matching Status, ALPHAUP collated. If no such entry in OECOrderStatus&lt;br&gt;
exists, Status will be stored as V/Verified in the Viewer Cache only and an&lt;br&gt;
alert logged in the Ensemble Event Log. Note that the OECOrderStatus table&lt;br&gt;
is loaded from the SITE- or HS-Default-OrderStatus.txt file at the time the&lt;br&gt;
Access Gateway is reset.&lt;br&gt;&lt;br&gt;
HL7:  ORC-5 : OrderStatus&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.OECOrderStatus&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemStatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Priority" type="Priority">
            <s:annotation>
                <s:documentation>The Priority of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Priority is parsed from (in order of precendence) TQ1-9, RXE-1.6, OBR-27.6,&lt;br&gt;
OBR-5, or ORC-7.6. TQ1-9 may set the Code, Description, and&lt;br&gt;
SDACodingStandard. Every other field only sets the Code. Though TQ1-9 and&lt;br&gt;
ORC-7 are repeating fields, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance of each. OBR-27 is also a repeating field, and HL7ToSDA3 parses&lt;br&gt;
every non-null instance of it. The last non-null instance of Priority in&lt;br&gt;
OBR-27 is the one that takes precedence. Note that an RDE_O11 message may&lt;br&gt;
contain TQ1 segments in two different places. HL7ToSDA3 parses the one&lt;br&gt;
following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order contains no Priority, one is defaulted in with Code="N" and &lt;br&gt;
Description="Normal".&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9   : Priority&lt;br&gt;
SDATableName=Priority, ViewerClass=User.HS.OECPriority&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPriorityDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9.1  : Priority.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-9.2  : Priority.Text&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  TQ1-9.3  : Priority.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConfidentialityCode" type="Confidentiality">
            <s:annotation>
                <s:documentation>Confidentiality code (e.g. VIP, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-28 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-28 : ConfidentialtyCode&lt;br&gt;
SDATableName=Confidentiality, ViewerClass=User.HS.OECOverReasonNonConsent&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINoConsentOverrideReasDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-28.1 : ConfidentialtyCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-28.2 : ConfidentialtyCode.Text&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-28.3 : ConfidentialtyCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Condition">
            <s:annotation>
                <s:documentation>Condition, e.g. "keep BP below 110"&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Condition is parsed from (in order of precendence) TQ1-10, RXE-1.7,&lt;br&gt;
OBR-27.7, or ORC-7.7. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Condition in OBR-27 is the one that takes precendence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  OBR-27.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  RXE-1.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  TQ1-10  : ConditionText&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILtClinicalCondition)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="TextInstruction" type="s:string">
            <s:annotation>
                <s:documentation>Text instructions or directions, e.g. "After food", or if Duration etc.&lt;Br&gt;
isn't coded, "Take 3 twice a day"&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
TextInstruction is parsed from (in order of precendence) TQ1-11, RXE-1.8,&lt;br&gt;
OBR-27.8, or ORC-7.8. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Text in OBR-27 is the one that takes precendence. Note that an RDE_O11&lt;br&gt;
message may contain TQ1 segments in two different places. HL7ToSDA3 parses&lt;br&gt;
the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a TextInstruction, then that&lt;br&gt;
TextInstruction will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.8 : QuantityTiming.Text&lt;br&gt;
HL7:  OBR-27.8 : QuantityTiming.Text&lt;br&gt;
HL7:  RXE-1.8 : QuantityTimingText&lt;br&gt;
HL7:  TQ1-11  : TextInstruction&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDepProcNotes)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderGroup" type="s:string">
            <s:annotation>
                <s:documentation>This is a way to group related Orders together, such as a prescription&lt;br&gt;
chain.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemGroup)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Order Comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Order Comments are always parsed from NTE segments, though HL7 order&lt;br&gt;
messages may contain NTEs in different places, and only certain ones are&lt;br&gt;
parsed to Order Comments. For ORM and OMP messages, it is the first set of&lt;br&gt;
NTEs following the ORC (in the message schema, not necessarily in the&lt;br&gt;
message) that are parsed to Comments.  In an RDE message the set of NTEs&lt;br&gt;
following the RXE segment are parsed to Order Comments. Order Comments can&lt;br&gt;
only be parsed from an ORU message if it contains a text result (either&lt;br&gt;
ORC-29 is not "LAB", or all OBX-2 values = "FT", "TX", or "ED"). In this&lt;br&gt;
case the NTEs immediately following the OBR are parsed to Order Comments.&lt;br&gt;
In an ORU containing atomic lab results, the NTEs following the OBR are&lt;br&gt;
parsed to the Result Comments, and in an ORU containing Observations&lt;br&gt;
(ORC-29="OBS"), these NTEs are not parsed.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRemarks)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConsultationDepartment" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Department or facility that consulted&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIConsultDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AuthorizationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the order was authorized&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthorisedDate) + User.HS.OEOrdItem(OEORIAuthorisedTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReceivingLocation" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Location or facility receiving/performing the order&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRecDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedComments" type="s:string">
            <s:annotation>
                <s:documentation>Verified order comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthComments)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultCopiesTo" type="ArrayOfCareProvider">
            <s:annotation>
                <s:documentation>Who to send copies of results to&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-28 is a repeating field, and HL7ToSDA3 will parse each instance with a&lt;br&gt;
non-null value in subfield 1.&lt;br&gt;&lt;br&gt;
HL7:  OBR-28  : ResultCopiesTo&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-28.1 : ResultCopiesTo.Code&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  OBR-28.2.1 : ResultCopiesTo.FamilyName.Surname&lt;br&gt;
HL7:  OBR-28.3 : ResultCopiesTo.GivenName&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-28.9 : ResultCopiesTo.AssigningAuthority&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  OBR-28.2.1 : ResultCopiesTo.FamilyName.Surname&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  OBR-28.3 : ResultCopiesTo.GivenName&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  OBR-28.6 : ResultCopiesTo.Prefix&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  OBR-28.7 : ResultCopiesTo.Degree&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupId" type="s:string">
            <s:annotation>
                <s:documentation>If this item was ordered as part of a group, this is the identifier of that&lt;br&gt;
group. The SDA2-to-SDA3 transform populates this field with the SDA2&lt;br&gt;
ExternalId property.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.1 : PlacerGroupNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILab1)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupAssigningAuthority" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
GroupAssigningAuthority is composed of subfields 2, 3, and 4 concatenated&lt;br&gt;
together as "[.2]^[.3]^[.4]", but only if at least one of these is not&lt;br&gt;
null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.2: PlacerGroupNumber.NamespaceID&lt;br&gt;
HL7:  ORC-4.3: PlacerGroupNumber.UniversalID&lt;br&gt;
HL7:  ORC-4.4: PlacerGroupNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate all orders of this type (set Status="I")&lt;br&gt;
C = Clear/delete all orders of this type&lt;br&gt;
R = Replace - Applies only to Atomic Result Items.  Clears previous result items before storing all new items,
ignoring matching on test item code.  &lt;b&gt;Use ONLY when always receiving full updates.  Using this with
partial updates may cause a loss of test item data.&lt;/b&gt;&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation of the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in ORC-1 will be parsed as ActionCode="I", while&lt;br&gt;
four double quotes ("""") will be parsed as ActionCode="C". &lt;br&gt;
ActionCode="R" in ORC-1 will impact parsing of TestItemCode.  See the
TestItemCode property of HS.SDA3.LabResultItem for details.&lt;br&gt;
Any other value will not be parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-1 : OrderControl&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Only used for Medications, see the annotation in HS.SDA3.Medication.&lt;br&gt;
Otherwise ActionScope is not used for Orders.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-10 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-10 : EnteredBy&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserUpdate)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-10.1 : EnteredBy.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-10.2.1 : EnteredBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-10.3 : EnteredBy.GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-10.9 : EnteredBy.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-21 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed. ORC-22 is also a repeating field, however HL7ToSDA3 will only parse&lt;br&gt;
the instance corresponding to the instance of ORC-21 parsed. For example,&lt;br&gt;
if the third instance of ORC-21 is parsed (because the first two are null),&lt;br&gt;
then the third instance of ORC-22 will be parsed as well. For Address.City,&lt;br&gt;
State, Zip, Country, and County only the Code is parsed. HL7ToSDA3 does not&lt;br&gt;
set the Description. Every instance of ORC-23 will be examined but may not&lt;br&gt;
be parsed to the SDA. The algorithm to parse a number out of one instance&lt;br&gt;
of ORC-23 is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else no number can be parsed from this instance.&lt;br&gt;
-Whichever number is parsed, if subfield 9 of that instance is not null, it&lt;br&gt;
will be appended to the number, delimited by a semicolon.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;&lt;br&gt;
HL7:  ORC-21 : OrderingFacilityName&lt;br&gt;
HL7:  ORC-22 : OrderingFacilityAddress&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserAddHospDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-21.10 will be parsed to the Code if present, else ORC-21.3 will.&lt;br&gt;
HL7:  ORC-21.10 : OrderingFacilityName.OrganizationIdentifier&lt;br&gt;
HL7:  ORC-21.3 : OrderingFacilityName.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-21.1 : OrderingFacilityName.OrganizationName&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-21.6 : OrderingFacilityName.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-22.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-22.1.1.&lt;br&gt;
HL7:  ORC-22.1.1 : OrderingFacilityAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-22.2 : OrderingFacilityAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPAddress)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-22.3 : OrderingFacilityAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCity)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-22.4 : OrderingFacilityAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPProvinceDR)&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-22.5 : OrderingFacilityAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-22.6 : OrderingFacilityAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountryDR)&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-22.9 : OrderingFacilityAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountyParishDR)&lt;br&gt;
.ContactInfo.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
WorkPhoneNumber is parsed from the first instance of ORC-23 with subfield 2&lt;br&gt;
in ["",WPN,ASN,EMR] and subfield 3 in ["",PH] and from which a phone number&lt;br&gt;
can be parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPPhone)&lt;br&gt;
.ContactInfo.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MobilePhoneNumber is parsed from the first instance of ORC-23 with subfield&lt;br&gt;
2 = "BPN" and subfield 3 in [CP,BP] and from which a phone number can be&lt;br&gt;
parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ContactInfo.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
EmailAddress is parsed from the first non-null instance of ORC-23.4.&lt;br&gt;
HL7:  ORC-23.4 : OrderingFacilityPhoneNumber.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPEmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. For Orders than can have&lt;br&gt;
Results (LabOrder, RadOrder, OtherOrder), if the Order actually has a&lt;br&gt;
Result and FromTime, EnteredOn, and Result.ResultTime are all null, an&lt;br&gt;
error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  ORC-9.1 : DateTimeofTransaction.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUpdateDate) + User.HS.OEOrdItem(OEORIUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
FromTime is parsed from (in order of precedence) TQ1-7.1, RXE-1.4,&lt;br&gt;
OBR-27.4, OBR-6.1, or ORC-7.4. Though ORC-7 is a repeating field, HL7ToSDA3&lt;br&gt;
only parses the first non-null instance. OBR-27 is also a repeating field,&lt;br&gt;
and HL7ToSDA3 parses every non-null instance of it. The last non-null&lt;br&gt;
instance of StartDateTime.Time in OBR-27 is the one that takes precedence.&lt;br&gt;
Note that an RDE_O11 message may contain TQ1 segments in two different&lt;br&gt;
places. HL7ToSDA3 parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. Then, if the Order has a&lt;br&gt;
Result and FromTime is still null, it is defaulted to Result.ResultTime.&lt;br&gt;
Finally, if the Order has a Result and FromTime is still null, an error&lt;br&gt;
will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a FromTime, then that FromTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  OBR-6.1 : RequestedDateTime.Time&lt;br&gt;
HL7:  OBR-27.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  RXE-1.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  TQ1-7.1 : StartDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORISttDat) + User.HS.OEOrdItem(OEORISttTim)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ToTime is parsed from (in order of precedence) TQ1-8, RXE-1.5, OBR-27.5,&lt;br&gt;
or ORC-7.5. Though ORC-7 is a repeating field, HL7ToSDA3 only parses the&lt;br&gt;
first non-null instance. OBR-27 is also a repeating field, and HL7ToSDA3&lt;br&gt;
parses every non-null instance of it. The last non-null instance of&lt;br&gt;
EndDateTime.Time in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a ToTime, then that ToTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  OBR-27.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  RXE-1.5.1 : QuantityTiming.EndDateTimeTime&lt;br&gt;
HL7:  TQ1-8.1   : EndDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEndDate) + User.HS.OEOrdItem(OEORIEndTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Result" type="Result">
            <s:annotation>
                <s:documentation>VIEWERLIB: see HS.SDA3.Result&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Specimens" type="ArrayOfSpecimen">
            <s:annotation>
                <s:documentation>HL7:  SPM&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ClinicalInformation" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-13 : ReleventClinicalInformation&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservation" type="LabTestItem">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is a copy of the parent observation (as a LabTestItem). For&lt;br&gt;
example, the parent observation could be a bacterial culture identified in&lt;br&gt;
a specimen taken from the patient, and this order would contain the&lt;br&gt;
antibiotic susceptibilities of that culture.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentResultObservation itself is not&lt;br&gt;
stored in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-26.1 : ParentResult.ParentObservationIdentifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-26.1.1 : ParentResult.ParentObservationIdentifier.Text&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-26.1.2 : ParentResult.ParentObservationIdentifier.Identifier&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-26.1.3 : ParentResult.ParentObservationIdentifier.NameofCodingSystem&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, and 6 will be parsed&lt;br&gt;
into the Code, Description, and CodeSystem, respectively, of a PriorCode in&lt;br&gt;
the list of PriorCodes.&lt;br&gt;
HL7:  OBR-26.1.4 : ParentResult.ParentObservationIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-26.1.5 : ParentResult.ParentObservationIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-26.1.6 : ParentResult.ParentObservationIdentifier.NameofAlternateCodingSystem&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservationSubId">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is the SubId of the parent observation.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentResultObservationSubId itself is not&lt;br&gt;
stored in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-26.2 : ParentResult.ParentObservationSubidentifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="30"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservationText" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-26.3 : ParentResultObservationText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentPlacerId" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-29.1.1 : Parent.PlacerAssignedIdentifier.EntityIdentifier&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentPlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the Parent ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-29.1 will be used if a value can be parsed from it.&lt;br&gt;
ParentPlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.1.2 : Parent.PlacerAssignedIdentifier.NamespaceID&lt;br&gt;
HL7:  OBR-29.1.3 : Parent.PlacerAssignedIdentifier.UniversalID&lt;br&gt;
HL7:  OBR-29.1.4 : Parent.PlacerAssignedIdentifier.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ParentFillerId" type="s:string">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is the FillerId of the parent observation.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentFillerId itself is not stored in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.2.1 : Parent.FillerAssignedIdentifier.EntityIdentifier&lt;br&gt;
Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentFillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the Parent ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-29.2 will be used if a value can be parsed from it.&lt;br&gt;
ParentFillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.2.2 : Parent.FillerAssignedIdentifier.NamespaceID&lt;br&gt;
HL7:  OBR-29.2.3 : Parent.FillerAssignedIdentifier.UniversalID&lt;br&gt;
HL7:  OBR-29.2.4 : Parent.FillerAssignedIdentifier.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ReasonForStudy" type="ReasonforStudy">
            <s:annotation>
                <s:documentation>HL7:  OBR-31 : ReasonforStudy&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-31.1 : ReasonforStudy.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-31.2 : ReasonforStudy.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-31.3 : ReasonforStudy.NameofCodingSystem&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-31.7 : ReasonforStudy.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  OBR-31.4 : ReasonforStudy.AlternateIdentifier&lt;br&gt;
HL7:  OBR-31.5 : ReasonforStudy.AlternateText&lt;br&gt;
HL7:  OBR-31.6 : ReasonforStudy.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-31.8 : ReasonforStudy.AlternateCodingSystemVersionID&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="LabOrderExtension"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Order">
    <s:annotation>
        <s:documentation>Order is processed "in-line" in the Viewer Cache in&lt;br&gt;
web.SDA3.Order:UpdateOrder since it needs to know about its "parent"&lt;br&gt;
OrderCategory and order type. A reference to the "parent" OrderCategory (as&lt;br&gt;
an ARCItemCat) is stored in the ARCIMItemCatDR property.&lt;br&gt;&lt;br&gt;
In addition to Code, Description, and SDACodingStandard, Orders are also&lt;br&gt;
matched on their "parent" order type (LAB, RAD, MED, VXU, or OTH), although&lt;br&gt;
this matching is only approximate. See&lt;br&gt;
HS.SDA3.CodeTableDetail.OrderCategory for more info. The parent&lt;br&gt;
OrderCategory is sometimes used as a match property as well, depending on&lt;br&gt;
the value of the Configuration Registry key:&lt;br&gt;
&lt;pre&gt;
\Viewer\OrderCategory\AlwaysUseInbound
&lt;/pre&gt;
If the value of the key is 1, then two Orders must match on OrderCategory&lt;br&gt;
to be considered a match. Else, the Orders can match even if the&lt;br&gt;
OrderCategories do not match, so long as they match on Code, Description,&lt;br&gt;
SDACodingStandard, and order type. In this case, the existing OrderCategory&lt;br&gt;
will be used, and the inbound value basically discarded. This can be useful&lt;br&gt;
for setting up the Access Gateway as the "source of truth" for the category&lt;br&gt;
of orders via the SITE-Default-OrderItem.txt file, so that orders can be&lt;br&gt;
grouped by category in the Clinical Viewer.&lt;br&gt;&lt;br&gt;
If an inbound Order has no "parent" OrderCategory, then on add to the&lt;br&gt;
Viewer Cache (no match found on Code, Description, SDACodingStandard, and&lt;br&gt;
OrderType), the OrderCategory with Code and Description = [order type]&lt;br&gt;
will be defaulted in. If a match is found on Code, Description,&lt;br&gt;
SDACodingStandard, and OrderType but the inbound Order has no parent&lt;br&gt;
OrderCategory, then the comparison will be called a match and the existing&lt;br&gt;
OrderCategory used.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="OrderExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ARCItmMast(ARCIMCode)&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMAbbrev)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ARCItmMast(ARCIMDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="OrderExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="OrderCategory">
    <s:annotation>
        <s:documentation>Before being processed into the Viewer Cache, if an OrderCategory has an&lt;br&gt;
SDACodingStandard that is not null and is not the Preferred Code System,&lt;br&gt;
then it will be set to null and a warning logged in the Event Log. See the&lt;br&gt;
HS documentation for more info on the Preferred Code System.&lt;br&gt;&lt;br&gt;
OrderCategory is processed "in-line" in the Viewer Cache in&lt;br&gt;
web.SDA3.Order:UpdateOrder since it needs to know about its "parent" order&lt;br&gt;
type (LAB, RAD, MED, VXU, or OTH). In addition to Code, Description, and&lt;br&gt;
SDACodingStandard, OrderCategory is also matched on the parent order type,&lt;br&gt;
except the Viewer Cache doesn't support the same range of values for order&lt;br&gt;
type that SDA does. Order type is stored in the Viewer Cache in the&lt;br&gt;
ARCICOrderType property of ARCItemCat. HealthShare maps the SDA order type&lt;br&gt;
"LAB" to "L" for "LabTrak", "MED" and "VXU" to "R" for "Drug", and "RAD"&lt;br&gt;
and "OTH" to "N" for "Normal". So technically, two OrderCategories with the&lt;br&gt;
same Code, Description, and SDACodingStandard, one for a Medication and the&lt;br&gt;
other for a Vaccination, could match each other in the Viewer Cache.&lt;br&gt;
However, an OrderCategory for a LabOrder will never match one for a&lt;br&gt;
Medication.&lt;br&gt;&lt;br&gt;
OrderCategory also populates User.HS.OECOrderCategory, which ARCItemCat&lt;br&gt;
contains a reference to (ARCICOrdCatDR). The Code and Description of the&lt;br&gt;
linked ARCItemCat and OECOrderCategory should be the same.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="OrderCategoryExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ARCItemCat(ARCICCode)&lt;br&gt;
VIEWERLIB: User.HS.OECOrderCategory(ORCATCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.ARCItemCat(ARCICDesc)&lt;br&gt;
VIEWERLIB: User.HS.OECOrderCategory(ORCATDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="OrderCategoryExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Frequency">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="FrequencyExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCFreq(PHCFRCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCFreq(PHCFRDesc1)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Factor">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
On add or update, if +[Factor]=0 and +[PHCFRFactor]=0, then PHCFRFactor is&lt;br&gt;
set to 1. If an inbound Frequency matches an existing PHCFreq on Code,&lt;br&gt;
Description, and SDACodingStandard, then if +[Factor] does not match&lt;br&gt;
PHCFRFactor, PHCFRFactor will be set to the value of Factor.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRFactor)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="FrequencyExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Duration">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DurationExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCDuration(PHCDUCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCDuration(PHCDUDesc1)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Factor">
            <s:annotation>
                <s:documentation>Number of days&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
On add or update, if +[Factor]=0 and +[PHCDUFactor]=0, then PHCDUFactor is&lt;br&gt;
set to 1. If an inbound Duration matches an existing PHCDuration on Code,&lt;br&gt;
Description, and SDACodingStandard, then if +[Factor] does not match&lt;br&gt;
PHCDUFactor, PHCDUFactor will be set to the value of Factor.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUFactor)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DurationExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Priority">
    <s:annotation>
        <s:documentation>This type describes the priority of an Order, unlike the EncounterPriority&lt;br&gt;
CodeTableDetail class, which describes the priority of an Encounter.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PriorityExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.OECPriority(OECPRCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.OECPriority(OECPRDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PriorityExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Confidentiality">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ConfidentialityExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ConfidentialityExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Result">
    <s:annotation>
        <s:documentation>A Result can be a property of a LabOrder, RadOrder, or OtherOrder.&lt;br&gt;
Results may be either text or atomic. Atomic results may have ResultItems.&lt;br&gt;
Text results may have ResultText, FileType, DocumentName, Stream,&lt;br&gt;
DocumentURL, and DocumentNumber. A LabOrder can contain either text or&lt;br&gt;
atomic results, but not both. A RadOrder or OtherOrder can contain only&lt;br&gt;
text results. In HL7ToSDA3, a result is determined to be atomic if&lt;br&gt;
ORC-29.1="LAB" and either (a) at least one OBX-2 value for the result&lt;br&gt;
is NOT "FT", "TX", or "ED", or (b) not all OBX segments are for the same&lt;br&gt;
item (i.e. they don't all have the same OBX-3 value).&lt;br&gt;
Otherwise, the result is text.&lt;br&gt;&lt;br&gt;
If HS.Gateway.HL7.InboundProcess has the compatibility setting &lt;br&gt;
MultiLineOBXCompatibilityMode turned on, requirement (b) is dropped -&lt;br&gt;
results are parsed as text even if their OBX-3 values differ, as long as&lt;br&gt;
they all have an OBX-2 value of "FT", "TX", or "ED".</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ResultExtension"/>
        <s:element minOccurs="0" name="ResultType" type="s:string">
            <s:annotation>
                <s:documentation>Describes the type of result&lt;br&gt;
Can be either "IM" for "Image" (text result, containing ResultText and/or&lt;br&gt;
Stream) or "AT" for "Atomic" (atomic result, containing ResultItems)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If an order in an ORU message is determined to contain atomic results&lt;br&gt;
(ORC-29.1="LAB" and either (a) not all OBX-2 values for this result are "FT",&lt;br&gt;
"TX", or "ED", or (b) not all OBX-3 values are the same), then ResultType&lt;br&gt;
will be parsed as "AT".&lt;br&gt;
If the setting MultiLineOBXCompatibilityMode is turned on in &lt;br&gt;
HS.Gateway.HL7.InboundProcess, requirement (b) is dropped - results are&lt;br&gt;
parsed as text even if their OBX-3 values differ, as long as they all have&lt;br&gt;
an OBX-2 value of "FT", "TX", or "ED".&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
RadOrders and OtherOrders can only have text results, so in the&lt;br&gt;
OnBeforeMatch method of the streamlet class, if ResultType is not "IM", it&lt;br&gt;
is set to "IM". If it was not initially null, a warning will be logged in&lt;br&gt;
the Ensemble Event Log.&lt;br&gt;
LabOrders can have text results (ResultText or Stream) or atomic results&lt;br&gt;
(ResultItems), but not both. In the OnBeforeMatch method of the streamlet&lt;br&gt;
class, if the Result is found to contain both text and atomic results, then&lt;br&gt;
ResultType is used to determine which to discard and which to save. If&lt;br&gt;
ResultType is "IM", atomic results are discarded, and if ResultType is&lt;br&gt;
"AT", text results are discarded. In either case a warning is logged. If&lt;br&gt;
the Result has both text and atomic results but ResultType is not "IM" or&lt;br&gt;
"AT", then an error will be logged and the streamlet will not be processed.&lt;br&gt;
If the Result contains only atomic results, ResultType is set to "AT", and&lt;br&gt;
if it contains only text results, "IM". If the Result contains no actual&lt;br&gt;
results, ResultType is set to null. Note that it is possible for a Result&lt;br&gt;
to go from having text results to atomic or vice versa. In the&lt;br&gt;
OnUpdateSDAResult method of the streamlet class (which is invoked instead&lt;br&gt;
the standard, generated SDA update code for a Result), if the ResultType of&lt;br&gt;
the inbound Result is "IM" and the existing ResultType is "AT", a warning&lt;br&gt;
is logged and the existing ResultItems set to null before proceeding with&lt;br&gt;
the update. If the inbound ResultType is "AT" and the existing is "IM", a&lt;br&gt;
warning is logged and the ResultText, FileType, DocumentName, Stream,&lt;br&gt;
DocumentURL, and DocumentNumber are all set to null before proceeding with&lt;br&gt;
the update.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId.&lt;br&gt;&lt;br&gt;
HL7:  ORC-29 : OrderType&lt;br&gt;
HL7:  OBX-2 : ValueType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultItems" type="ArrayOfLabResultItem">
            <s:annotation>
                <s:documentation>A list of the lab result's items, used for atomic results&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If an order in an ORU message is determined to contain atomic results&lt;br&gt;
(ORC-29.1="LAB" and either (a) not all OBX-2 values for this result are "FT",&lt;br&gt;
"TX", or "ED", or (b) not all OBX-3 values are the same), the OBXs will be&lt;br&gt;
parsed to LabResultItems in ResultItems, and the NTEs among them parsed as&lt;br&gt;
LabResultItem Comments. See HS.SDA3.LabResultItem for more info.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
A Result belonging to a LabOrder may have ResultItems or ResultText/Stream,&lt;br&gt;
but not both. In the OnBeforeMatch method of the streamlet class, if the&lt;br&gt;
Result has ResultItems and ResultText/Stream, then if ResultType="AT",&lt;br&gt;
ResultText and Stream will be set to null and a warning logged. Else if&lt;br&gt;
ResultType="IM", ResultItems will be set to null and a warning logged. Else&lt;br&gt;
(ResultType is null or not recognized) an error will be logged and the&lt;br&gt;
Order will not be processed. RadOrders and OtherOrders may not have&lt;br&gt;
ResultItems. In the OnBeforeMatch method of the streamlet class, if a&lt;br&gt;
RadOrder or OtherOrder Result has ResultItems, ResultItems will be set to&lt;br&gt;
null and a warning logged. For LabOrders, rather than the standard logic to&lt;br&gt;
update SDA lists, special logic exists to update ResultItems. See&lt;br&gt;
HS.SDA3.LabResultItem for more info.&lt;br&gt;&lt;br&gt;
HL7:  OBX,NTE&lt;br&gt;
VIEWERLIB: see HS.SDA3.LabResultItem</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>Care provider who verified the Result&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
VerifiedBy is stored in the VISTSPathologistIDDR property for atomic&lt;br&gt;
results and in the TRCTCPDR property for text results.&lt;br&gt;&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.EPVisitTestSet(VISTSPathologistIDDR)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRCTCPDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time of result&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For LabOrder, RadOrder, and OtherOrder, in the OnBeforeMatch method of the&lt;br&gt;
streamlet class, Result.EnteredOn and Result.AuthorizationTime default to&lt;br&gt;
Result.ResultTime. In the OnValidate method, if the Order FromTime is null,&lt;br&gt;
it is defaulted to the Order EnteredOn. If the Order has a Result and&lt;br&gt;
FromTime is still null, it is defaulted to Result.ResultTime. If the Order&lt;br&gt;
has a Result and FromTime is still null, then an error will be logged and&lt;br&gt;
the Order will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The EPVisitTestSet properties are set for atomic results only, and the&lt;br&gt;
OETextResult properties are set for text results only. Note that while&lt;br&gt;
OEORIHL7ResultTime and TRTimeUpdated are %Time values stored in $H format,&lt;br&gt;
VISTSDateOfAuthorisation is a %Float value containing the time as a number&lt;br&gt;
of minutes since midnight.&lt;br&gt;&lt;br&gt;
HL7:  OBR-22.1 : ResultsRptStatusChngDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIHL7ResultDate) + User.HS.OEOrdItem(OEORIHL7ResultTime)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSet(VISTSDateOfAuthorisation) + lab.HS.EPVisitTestSet(VISTSDateOfAuthorisation)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRDateUpdated) + User.HS.OETextResult(TRTimeUpdated)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultStatus" type="s:string">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
For LabOrders, in the OnBeforeMatch method of the Streamlet class,&lt;br&gt;
ResultStatus is ALPHAUP collated, then possibly mapped: FIN-&gt;F, COR-&gt;K,&lt;br&gt;
C-&gt;K, ENT-&gt;R, [other]-&gt;unchanged. For RadOrders and OtherOrders, in the&lt;br&gt;
OnBeforeMatch method of the Streamlet class, ResultStatus is also ALPHAUP&lt;br&gt;
collated and possibly mapped, though the mappings are slightly different:&lt;br&gt;
FIN-&gt;F, COR-&gt;C, ENT-&gt;R, [other]-&gt;unchanged. Then, for LabOrders, RadOrders,&lt;br&gt;
and OtherOrders, ResultStatus is validated against the list of codes for&lt;br&gt;
the Trak "ResultType" Standard Type: I, R, F, C, K, V, O, S, A, P, or X. If&lt;br&gt;
ResultStatus is not one of these values or null, it is set to null and a&lt;br&gt;
warning logged. In the OnValidate method of the Streamlet classes for&lt;br&gt;
LabOrder, RadOrder, and OtherOrder, if the Order has a Result, but&lt;br&gt;
ResultStatus is null, it is defaulted to "R" for "Entered". Then, if the&lt;br&gt;
Result has ResultItems, and ResultStatus is "F" for "Final", and the&lt;br&gt;
TestItemStatus of any LabResultItem in ResultItems is "K" for "Corrected",&lt;br&gt;
ResultStatus will be set to "K" for "Corrected".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The VISTSStatusResult property is set for atomic results only, and is&lt;br&gt;
simply set to the SDA ResultStatus value. TRResStatDR is set for text&lt;br&gt;
results only and contains a reference to the User.HS.OECResultStatus with&lt;br&gt;
RESSTCode=[ResultStatus]. Note that unlike other code tables in the Viewer&lt;br&gt;
Cache, OECResultStatus is not populated dynamically as codes are processed.&lt;br&gt;
OECResultStatus is only populated by the SITE- or&lt;br&gt;
HS-Default-ResultStatus.txt file at the time the Access Gateway is reset.&lt;br&gt;
See the HS documentation for more info on working with SITE-Default files.&lt;br&gt;
TRExternalResultStatus is also set for text results only and is derived&lt;br&gt;
from the ResultStatus value.  It is set to "A" if ResultStatus is "F", "K"&lt;br&gt;
if ResultStatus is "C", and "E" otherwise. OEORIResultFlag is set for both&lt;br&gt;
text and atomic results, though with slightly different logic. For text&lt;br&gt;
results, OEORIResultFlag is set to "C" if ResultStatus is "C", and "A"&lt;br&gt;
otherwise. For atomic results, OEORIResultFlag is set to "C" if&lt;br&gt;
ResultStatus is "K", and "A" otherwise.&lt;br&gt;&lt;br&gt;
HL7:  OBR-25 : ResultStatus&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSet(VISTSStatusResult)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRResStatDR)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRExternalResultStatus)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIResultFlag)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultText" type="s:string">
            <s:annotation>
                <s:documentation>The actual text of the result&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
ResultText is used for text results only.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If the Result is determined to be text, then any NTE segments immediately&lt;br&gt;
following the OBR and before the first OBX will be parsed to the Order&lt;br&gt;
Comments. Then, if subfield 2 of the first OBX (Value Type) is not "ED"&lt;br&gt;
(for "Encapsulated Data") and subfield 5.1 does not start with "{\rtf",&lt;br&gt;
then each OBX and NTE, starting from the first OBX, will be parsed to&lt;br&gt;
ResultText. OBX-5 and NTE-3 are repeating fields, and each instance is&lt;br&gt;
parsed as one line in the ResultText. ResultText will be HL7-unescaped&lt;br&gt;
according to the annotation on HS.Gateway.HL7.HL7ToSDA3:unescape.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If a stored text result of a LabOrder is updated to have atomic results (by&lt;br&gt;
changing ResultType from "IM" to "AT"), a warning will be logged and&lt;br&gt;
ResultText (among other properties) set to null.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5 : ObservationValue&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(ChildOETextResultSection)-&gt;User.HS.OETextResultSection(SECText)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FileType" type="s:string">
            <s:annotation>
                <s:documentation>The type of data e.g PDF, DOC, RTF, TXT&lt;br&gt;
FileType is used for text results only.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If the result is text, then if field 2 of the first OBX (Value Type) is&lt;br&gt;
"ED" for "Encapsulated Data", then FileType will be parsed from field 5.3&lt;br&gt;
of that OBX. Else if field 5.1 of that OBX starts with "{\rtf", FileType&lt;br&gt;
will be set to "RTF". Else FileType is not set in the SDA.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For LabOrders, RadOrders, and OtherOrders, in the OnValidate method of the&lt;br&gt;
Streamlet classes, if the Order has a text result, and DocumentName and&lt;br&gt;
DocumentURL are null, and the Result has a Stream of Size &gt; 0, then&lt;br&gt;
DocumentName will be defaulted to FileType.&lt;br&gt;
If a stored text result of a LabOrder is updated to have atomic results (by&lt;br&gt;
changing ResultType from "IM" to "AT"), a warning will be logged and&lt;br&gt;
FileType (among other properties) set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Result has a Stream of Size &gt; 0, Stream will be stored in a&lt;br&gt;
websys.Document[xxx], where [xxx] is determined by finding the entry in&lt;br&gt;
websys.Document:ClassNames corresponding to the entry in&lt;br&gt;
websys.Document:ValidTypes that matches FileType. For example, if&lt;br&gt;
FileType="PDF", Stream will be stored in a websys.DocumentPDF. If&lt;br&gt;
FileType="HTML", Stream will be stored in a websys.DocumentOTHER. If no&lt;br&gt;
entry in ValidTypes matches FileType, Stream will be stored in a&lt;br&gt;
websys.DocumentOTHER. FileType itself is stored as the docType of a&lt;br&gt;
websys.Document.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5.3 : ObservationValue.DataSubtype&lt;br&gt;
VIEWERLIB: websys.Document(docType)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DocumentName">
            <s:annotation>
                <s:documentation>The name of the document&lt;br&gt;
DocumentName is used for text results only.&lt;br&gt;
The MAXLEN comes from the Trak property (TRDocumentName).&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For LabOrders, RadOrders, and OtherOrders, in the OnValidate method of the&lt;br&gt;
Streamlet classes, if the Order has a text result and DocumentName is null,&lt;br&gt;
it will be defaulted to DocumentURL. If still null and the Result has a&lt;br&gt;
Stream of Size &gt; 0, DocumentName will be defaulted to FileType.&lt;br&gt;
If a stored text result of a LabOrder is updated to have atomic results (by&lt;br&gt;
changing ResultType from "IM" to "AT"), a warning will be logged and&lt;br&gt;
DocumentName (among other properties) set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Result has a GUID that is not expired (GUIDExpDate in the future),&lt;br&gt;
then TRDocumentName will be set to "View Image". Else TRDocumentName will&lt;br&gt;
be set to the Result DocumentName. Note that TRDocumentName is used as the&lt;br&gt;
text of the link to the document in the Clinical Viewer.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRDocumentName)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Stream" type="s:base64Binary">
            <s:annotation>
                <s:documentation>An alternative to ResultText, this property may contain the result as a&lt;br&gt;
stream of either plaintext or binary data (e.g. DOC, PDF, JPG), with the&lt;br&gt;
type of data given by FileType. Stream is used for text results only,&lt;br&gt;
never atomic.&lt;br&gt;&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
Note that because of the type of this property (%GlobalBinaryStream),&lt;br&gt;
character data written to it must be single-width, ie, no double-wide&lt;br&gt;
Unicode characters. On export, the content will be Base64 encoded, and on&lt;br&gt;
import, Base64 decoded.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If the result is determined to be text, then if field 2 of the first OBX&lt;br&gt;
(Value Type) is "ED" for "Encapsulated Data", or if field 5.1 of that OBX&lt;br&gt;
starts with "{\rtf", then the result will be parsed to Stream. Starting&lt;br&gt;
with the first OBX following the OBR, each OBX-5 and NTE-3 value will be&lt;br&gt;
parsed to Stream. OBX-5 and NTE-3 are repeating fields, and each instance&lt;br&gt;
of both will be parsed as its own line in Stream. For each OBX, if field 2&lt;br&gt;
is "ED", the value will be parsed from field 5.5, else the value will be&lt;br&gt;
parsed from field 5 in its entirety. Note that the maximum amount of data&lt;br&gt;
that can parsed this way is about 3.6 million characters. If the result is&lt;br&gt;
longer than this, it will be truncated. If no OBX-2 value in the result is&lt;br&gt;
"ED", then entire body of parsed text will be HL7-unescaped according to&lt;br&gt;
the annotation on HS.Gateway.HL7.HL7ToSDA3:unescape. If field 5.4 of the&lt;br&gt;
first OBX is not "BASE64" (case-insensitive), then the parsed text will be&lt;br&gt;
base-64 encoded before being inserted into the SDA.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If a stored text result of a LabOrder is updated to have atomic results (by&lt;br&gt;
changing ResultType from "IM" to "AT"), a warning will be logged and&lt;br&gt;
Stream (among other properties) set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OETextResult references a websys.Document, which references a&lt;br&gt;
websys.Document[xxx] (where [xxx] is derived from FileType, see the&lt;br&gt;
annotation on that property), which is where Stream is actually stored in&lt;br&gt;
the Viewer Cache. Note that the websys.Document does not contain an actual&lt;br&gt;
reference to the Document[xxx], but rather stores its ID in the DataId&lt;br&gt;
property.&lt;br&gt;
If the value of the Configuration Registry key&lt;br&gt;
"\Viewer\SDA3ResultStreamEncoded" is "1", then the content of Stream will&lt;br&gt;
be converted from UTF-8 output format (ie, $ZCVT(,"I","UTF8")) before being&lt;br&gt;
inserted into the Viewer Cache. This is useful in cases where the original&lt;br&gt;
document data contained double-wide Unicode characters that had to be&lt;br&gt;
converted to UTF-8 output format before being written to the stream, since&lt;br&gt;
it cannot contain double-wide characters.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5 : ObservationValue&lt;br&gt;
HL7:  NTE-3 : Comments&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRDocumentDR)-&gt;websys.Document&lt;br&gt;
VIEWERLIB: websys.Document[xxx](docData)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DocumentURL">
            <s:annotation>
                <s:documentation>The full URL where the document can be accessed&lt;br&gt;
DocumentURL is used for text results only.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For LabOrders, RadOrders, and OtherOrders, in the OnValidate method of the&lt;br&gt;
Streamlet class, if the Order has a text result and DocumentName is null,&lt;br&gt;
it will be defaulted to DocumentURL.&lt;br&gt;
If a stored text result of a LabOrder is updated to have atomic results (by&lt;br&gt;
changing ResultType from "IM" to "AT"), a warning will be logged and&lt;br&gt;
DocumentURL (among other properties) set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Result has a GUID that is not expired (GUIDExpDate in the future),&lt;br&gt;
then TRDocumentURL will be set based on the GUID and whichever third-party&lt;br&gt;
image viewing service HealthShare is integrated with. Else TRDocumentURL&lt;br&gt;
will be set to the Result DocumentURL.  In the Clinical Viewer, a link to&lt;br&gt;
TRDocumentURL will appear with the Result.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRDocumentURL)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="DocumentNumber">
            <s:annotation>
                <s:documentation>Used as an external reference ID&lt;br&gt;
DocumentNumber is used for text results only.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If a stored text result of a LabOrder is updated to have atomic results (by&lt;br&gt;
changing ResultType from "IM" to "AT"), a warning will be logged and&lt;br&gt;
DocumentNumber (among other properties) set to null.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRDocumentExtId)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For atomic results, Comments is parsed from the NTE segments following the&lt;br&gt;
OBR but before the first OBX. For text results, Result Comments cannot be&lt;br&gt;
parsed from HL7. (NTEs in the same place in a text result are parsed as&lt;br&gt;
Comments on the Order.)&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORITestSetComments is set for both text and atomic results.&lt;br&gt;
TRTestSetComments is set for text results only.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORITestSetComments)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRTestSetComments)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AuthorizationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time the result was authenticated/verified&lt;br&gt;
AuthorizationTime is meant to be used for text results only.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-22 is parsed to AuthorizationTime for text results only.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The OETextResult properties are set for text results only.&lt;br&gt;&lt;br&gt;
HL7:  OBR-22.1 : ResultsRptStatusChngDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRDateVerified) + User.HS.OETextResult(TRTimeVerified)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PerformedAt" type="Organization">
            <s:annotation>
                <s:documentation>PerformedAt / ProducersID&lt;br&gt;
This can be used to specify the external organization that actually did the&lt;br&gt;
test.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
PerformedAt is only set at the result level for text results. For atomic&lt;br&gt;
results, it is set at the item level. For text results, it is parsed from&lt;br&gt;
the fields of the first OBX segment.&lt;br&gt;
If subfield 1 or 10 of OBX-23 is not null, Code, Description, and&lt;br&gt;
SDACodingStandard will be parsed from OBX-23. Else if subfield 1 or 2 of&lt;br&gt;
OBX-15 is not null, Code, Description, and SDACodingStandard will be parsed&lt;br&gt;
from OBX-15.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
TRPerformedAtDR is set for text results only.&lt;br&gt;&lt;br&gt;
HL7:  OBX-15 : ProducersReference&lt;br&gt;
HL7:  OBX-23 : PerformingOrganizationName&lt;br&gt;
HL7:  OBX-24 : PerformingOrganizationAddress&lt;br&gt;
HL7:  OBX-25 : PerformingOrganizationMedicalDirector&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRPerformedAtDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If being parsed from OBX-23, subfield 10 will be used if not null, else&lt;br&gt;
subfield 3 will be used.&lt;br&gt;
HL7:  OBX-23.10 : PerformingOrganizationName.OrganizationIdentifier&lt;br&gt;
HL7:  OBX-23.3 : PerformingOrganizationName.IDNumber&lt;br&gt;
HL7:  OBX-15.1 : ProducersReference.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBX-23.10 : PerformingOrganizationName.OrganizationName&lt;br&gt;
HL7:  OBX-15.2 : ProducersReference.Text&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-23.6 : PerformingOrganizationName.AssigningAuthority&lt;br&gt;
HL7:  OBX-15.3 : ProducersReference.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Address&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Address will only be parsed from OBX-24 is subfield 1 or 5 is not null. For&lt;br&gt;
the City, State, Zip, Country, and County properties, the HL7 field will be&lt;br&gt;
parsed to the Code. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  OBX-24 : PerformingOrganizationAddress&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If OBX-24.2 is not null, Street will be parsed as "[.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from OBX-24.1.&lt;br&gt;
HL7:  OBX-24.1 : PerformingOrganizationAddress.Street&lt;br&gt;
HL7:  OBX-24.2 : PerformingOrganizationAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPAddress)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  OBX-24.3 : PerformingOrganizationAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCity)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  OBX-24.4 : PerformingOrganizationAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPProvinceDR)&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  OBX-24.5 : PerformingOrganizationAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  OBX-24.6 : PerformingOrganizationAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountryDR)&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  OBX-24.9 : PerformingOrganizationAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountyParishDR)&lt;br&gt;&lt;br&gt;
.MedicalDirector&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MedicalDirector will only be parsed from OBX-25 if subfield 1, 2, or 9 is&lt;br&gt;
not null.&lt;br&gt;
HL7:  OBX-25 : PerformingOrganizationMedicalDirector&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.MedicalDirector.Code&lt;br&gt;
HL7:  OBX-25.1 : IDNumber&lt;br&gt;
.MedicalDirector.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  OBX-25.2 : FamilyName&lt;br&gt;
HL7:  OBX-25.3 : GivenName&lt;br&gt;
.MedicalDirector.SDACodingStandard&lt;br&gt;
HL7:  OBX-25.9 : AssigningAuthority&lt;br&gt;
.MedicalDirector.Name.FamilyName&lt;br&gt;
HL7:  OBX-25.2 : FamilyName&lt;br&gt;
.MedicalDirector.Name.GivenName&lt;br&gt;
HL7:  OBX-25.3 : GivenName&lt;br&gt;
.MedicalDirector.Name.MiddleName&lt;br&gt;
HL7:  OBX-25.4 : SecondandFurtherGivenNamesorInitialsThereof&lt;br&gt;
.MedicalDirector.Name.NamePrefix&lt;br&gt;
HL7:  OBX-25.6 : Prefix&lt;br&gt;
.MedicalDirector.Name.NameSuffix&lt;br&gt;
HL7:  OBX-25.5 : Suffix&lt;br&gt;
.MedicalDirector.Name.ProfessionalSuffix&lt;br&gt;
HL7:  OBX-25.21 : ProfessionalSuffix</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultInterpretation" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
For text results, if any instance of any OBX-8 value (OBX-8 is a repeating&lt;br&gt;
field) is "A" for "Abnormal", ResultInterpretation will be set to "A".&lt;br&gt;
HL7ToSDA3 does not set the ResultInterpretation at the result level for&lt;br&gt;
atomic results.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For RadOrders, OtherOrders, and LabOrders with text results, in the&lt;br&gt;
OnBeforeMatch method of the Streamlet classes, if ResultInterpretation is&lt;br&gt;
not null, "A", or two double quotes (the delete instruction), it is set to&lt;br&gt;
null and a warning logged. For LabOrders with atomic results, in the&lt;br&gt;
OnBeforeMatch method of the Streamlet class, if ResultInterpretation is not&lt;br&gt;
null, it is set to null. In the OnValidate method, if a LabResultItem has&lt;br&gt;
an abnormal ResultInterpretation (H, HH, L, LL, A, or AA) or if it has no&lt;br&gt;
ResultInterpretation but ResultValue is numeric, the normalized&lt;br&gt;
ResultNormalRange is one of the numeric forms (see the annotation on&lt;br&gt;
HS.SDA3.LabResultItem:ResultNormalRange), and ResultValue is outside of&lt;br&gt;
ResultNormalRange, then this ResultInterpretation will be set to "A".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For both text and atomic results, if ResultInterpretation="A",&lt;br&gt;
OEORIAbnormal will be set to "Y". Else, OEORIAbnormal will be set to null.&lt;br&gt;&lt;br&gt;
HL7:  OBX-8 : AbnormalFlags&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAbnormal)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GUID" type="s:string">
            <s:annotation>
                <s:documentation>If HealthShare is integrated with a third-party image viewing service (such&lt;br&gt;
as eHealth Technologies), and that service has an image for this Result,&lt;br&gt;
then this GUID identifies that image. GUID is meant to come from the image&lt;br&gt;
viewing service, not the data provider that submitted the Result. Therefore&lt;br&gt;
GUID should not be included in an inbound SDA. See the HS Documentation for&lt;br&gt;
more info on how HealthShare can be integrated with an image viewing&lt;br&gt;
service.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The way GUID gets set in the Streamlet Cache will depend on which image&lt;br&gt;
viewing service HealthShare is integrated with. See the HS Documentation&lt;br&gt;
for more info.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If GUID is not null and the current date/time is not after GUIDExpDate,&lt;br&gt;
then a link to the image will appear with the Result in the Clinical&lt;br&gt;
Viewer.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GUIDExpDate" type="TimeStamp">
            <s:annotation>
                <s:documentation>If HealthShare is integrated with a third-party image viewing service (such&lt;br&gt;
as eHealth Technologies), and that service has an image for this Result,&lt;br&gt;
then this is the date and time that the received GUID for the image&lt;br&gt;
expires. Like GUID, GUIDExpDate is meant to come from the image viewing&lt;br&gt;
service, not the data provider that submitted the Result. Therefore&lt;br&gt;
GUIDExpDate should not be included in an inbound SDA. See the HS&lt;br&gt;
Documentation for more info on how HealthShare can be integrated with an&lt;br&gt;
image viewing service.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The way GUIDExpDate gets set in the Streamlet Cache will depend on which&lt;br&gt;
image viewing service HealthShare is integrated with. See the HS&lt;br&gt;
Documentation for more info.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If GUID is not null and the current date/time is not after GUIDExpDate,&lt;br&gt;
then a link to the image will appear with the Result in the Clinical&lt;br&gt;
Viewer.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
The properties of OETextResult are set for text results only.&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIResultUpdateUserDR)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRUserVerified)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRUserCreated)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
TRLastUpdateHospitalDR is set for text results only.&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIResultUpdateHospitalDR)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRLastUpdateHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
The properties of OETextResult are set for text results only.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIResultUpdateDate) + User.HS.OEOrdItem(OEORIResultUpdateTime)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRDateCreated) + User.HS.OETextResult(TRTimeCreated)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
For LabOrders, RadOrders, and OtherOrders, in the OnBeforeMatch method of&lt;br&gt;
the Streamlet classes, if the Order FillerId is null, it is defaulted to&lt;br&gt;
the Result ExternalId. FillerId undergoes other processing as well. See the&lt;br&gt;
annotation on HS.SDA3.AbstractOrder:FillerId for more info.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ResultExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfLabResultItem">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="LabResultItem" nillable="true" type="LabResultItem"/>
    </s:sequence>
</s:complexType>
<s:complexType name="LabResultItem">
    <s:annotation>
        <s:documentation>LabResultItems are stored in the ResultItems property of an HS.SDA3.Result&lt;br&gt;
containing atomic (as opposed to text) results (ResultType="AT"). Of the&lt;br&gt;
three Order types that can have Results, only LabOrder can have atomic&lt;br&gt;
results. RadOrder and OtherOrder can only have text results.&lt;br&gt;
LabResultItems are parsed from HL7 by the HL7 Inbound Process operation of&lt;br&gt;
the Edge production. Parsing is affected by the following settings:&lt;br&gt;
- KeepDuplicateOBXIdentifiers&lt;br&gt;
- ObservationCompatibilityMode (referred to here as Compatibility Mode&lt;br&gt;
on or off).&lt;br&gt;
- ActionCode="R" in ORC-1 for atomic lab results only&lt;br&gt;
LabResultItems come in two flavors, regular and antibiotic sensitivity.&lt;br&gt;
Sensitivities are part of microbiolgy results and are always "against" a&lt;br&gt;
regular item (i.e. an organism identified in a culture). Structurally,&lt;br&gt;
sensitivities are the same as regular items, and there is no one field that&lt;br&gt;
distinguishes an item as a sensitivity (although if ResultInterpretation is&lt;br&gt;
"S", "R", "I", "MS", or "VS", then the item is probably intended to be a&lt;br&gt;
sensitivity). Rather it is the SubId, ResultInterpretation, and an item's&lt;br&gt;
location in ResultItems relative to other items that distinguishes it as a&lt;br&gt;
sensitivity. Basically, the logic to determine whether an item is a&lt;br&gt;
sensitivity is:&lt;br&gt;
-If ResultInterpretation is S, R, I, MS, or VS,&lt;br&gt;
-And SubId is not null and is the same as the last non-sensitivity item&lt;br&gt;
with a non-null SubId in the result,&lt;br&gt;
-Then the item is a sensitivity against the last non-sensitivity item with&lt;br&gt;
a non-null SubId,&lt;br&gt;
-Else it is a regular item.&lt;br&gt;
Consider this excerpt from an HL7 ORU message:&lt;br&gt;
&lt;pre&gt;
	OBX|1|ST|AAO^ORGANISM|1|MODERATE GROWTH||||||F
	OBX|2|ST|AAO^ORGANISM|2|STREP, BETA HEM GROUP A||||||F
	OBX|3|ST|AAT^METHOD||KB||||||F
	OBX|4|ST|AM^AMPICILLIN|2|SUSCEPTIBLE|||S|||F
	OBX|5|ST|CLIN^CLINDAMYCIN|2|SUSCEPTIBLE|||S|||F
	OBX|6|ST|E^ERYTHROMYCIN|2|RESISTANT|||R|||F
&lt;/pre&gt;
The 2nd OBX is the organism identified in the culture, and the 4th, 5th,&lt;br&gt;
and 6th segments are the antibiotics tested against it.&lt;br&gt;&lt;br&gt;
In the OnUpdateSDAResult method of the LabOrder Streamlet class (invoked to&lt;br&gt;
update a Result in place of the standard, generated code), for regular (not&lt;br&gt;
sensitivity) items, inbound and existing items are matched on SubId and&lt;br&gt;
TestItemCode.Code and .SDACodingStandard. If a match is found, UpdateSDA is&lt;br&gt;
called on the existing item with the inbound item as its argument.&lt;br&gt;
Otherwise the inbound item is inserted into ResultItems. Sensitivity items&lt;br&gt;
in an update are not matched, but rather processed in "snapshot" mode. If&lt;br&gt;
an update contains sensitivities with a given SubId, then all existing&lt;br&gt;
sensitivities with that SubId are deleted and the inbound sensitivities&lt;br&gt;
inserted into ResultItems after the corresponding "organism" item.&lt;br&gt;&lt;br&gt;
In the Viewer Cache, regular test items are stored as&lt;br&gt;
lab.HS.EPVisitTestSetData, while sensitivities are stored as&lt;br&gt;
lab.HS.EPVisitTestSetDataAntibiotics that are linked to a regular item via&lt;br&gt;
the relationship between these two classes.&lt;br&gt;&lt;br&gt;
Also note that the matching of LabTestItem CodeTableDetails in the SDA to&lt;br&gt;
CTTestCodes in the Viewer Cache can optionally use the ResultValueUnits&lt;br&gt;
of this class as a match property. See the ResultValueUnits property for&lt;br&gt;
more details.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time updated or entered.  For labs, this represents when the order was&lt;br&gt;
placed.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="LabResultItemExtension"/>
        <s:element minOccurs="0" name="TestItemCode" type="LabTestItem">
            <s:annotation>
                <s:documentation>Code for test item&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The logic to parse TestItemCode is:&lt;br&gt;
-SDACodingStandard is always parsed from OBX-3.3 and CodeSystemVersionId&lt;br&gt;
from OBX-3.7.&lt;br&gt;
-If OBX-2="NM", parse Code from OBX-3.1, Description from OBX-3.2, and set&lt;br&gt;
IsNumeric to "true".&lt;br&gt;
-Else if OBX-2="CE" and OBX-8 is not "S", "R", "I", "MS", or "VS":&lt;br&gt;
--If KeepDuplicateOBXIdentifiers is true, or ORC-1="R", or the OBX-3.1 value&lt;br&gt;
is unique in this result, or if it has not yet appeared in this result&lt;br&gt;
with OBX-2="CE" or "ST", parse Code from OBX-3.1.&lt;br&gt;
--Else if OBX-4 is not null, parse fields 3.1 and 4 to Code as "[3.1][4]".&lt;br&gt;
--Else parse field 3.1 and the segment number to the Code as "[3.1][seg#]".&lt;br&gt;
--Parse Description from OBX-3.2.&lt;br&gt;
-Else if OBX-2="ST":&lt;br&gt;
--If KeepDuplicateOBXIdentifiers is true, or ORC-1="R", or the OBX-3.1 value&lt;br&gt;
is unique in this result, or if it has not yet appeared in this result&lt;br&gt;
with OBX-2="CE" or "ST", parse Code from OBX-3.1.&lt;br&gt;
--Else if OBX-4 is not null, parse fields 3.1 and 4 to Code as "[3.1][4]".&lt;br&gt;
--Else parse field 3.1 and the segment number to the Code as "[3.1][seg#]".&lt;br&gt;
--Parse Description from OBX-3.2.&lt;br&gt;
--Set IsNumeric to "true".&lt;br&gt;
-Else if fields 3.1 and .2 are the same as they were for the previous&lt;br&gt;
segment and Compatibility Mode is on, parse Code from OBX-3.1 as&lt;br&gt;
"[3.1] Notes" and Description from OBX-3.2 as "[3.2] Notes".&lt;br&gt;
-Else parse Code from OBX-3.1 and Description from OBX-3.2.&lt;br&gt;
-PriorCodes and OriginalText will only be parsed if the parsed Code was not&lt;br&gt;
changed from OBX-3.1 (by adding either the SubID, segment number, or&lt;br&gt;
"Notes"). Additionally, PriorCodes will only be parsed if OBX-3.4 or .5 is&lt;br&gt;
not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if a LabResultItem has&lt;br&gt;
no TestItemCode, it will be removed from ResultItems and a warning logged.&lt;br&gt;
Two LabResultItems in the same set of ResultItems with the same SubId and&lt;br&gt;
TestItemCode.Code and .SDACodingStandard are considered to be the same&lt;br&gt;
item. In the OnBeforeMatch method, if any duplicate LabResultItems are&lt;br&gt;
found, they are consolidated into a single LabResultItem by invoking the&lt;br&gt;
UpdateSDA method on the first LabResultItem with the second LabResultItem&lt;br&gt;
as its argument, then removing the second LabResultItem from ResultItems,&lt;br&gt;
and repeating as necessary. NOTE: This deduplication is skipped if ORC-1="R"&lt;br&gt;
In the OnUpdateSDAResult method, if a LabResultItem is determined not to&lt;br&gt;
be an antibiotic sensitivity, then it is compared to the existing&lt;br&gt;
LabResultItems on SubId and TestItemCode.Code and SDACodingStandard.&lt;br&gt;
If a match is found, the existing LabResultItem is updated by calling &lt;br&gt;
UpdateSDA on it with the inbound LabResultItem as its argument.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The Clinical Viewer does not support an atomic lab result containing two or&lt;br&gt;
more regular (not sensitivity) test items with the same code and different&lt;br&gt;
SubIds. (If the SubIds are the same, the test items are considered the same&lt;br&gt;
and will be consolidated.) If ResultItems contains data like this, a suffix&lt;br&gt;
of the form ":[#]" will be appended to the TestItemCode Code to make it&lt;br&gt;
unique within the Result. In this case, the Description is unchanged. If&lt;br&gt;
the LabResultItem is determined to be an antibiotic sensitivity, then this&lt;br&gt;
TestItemCode will be inserted into the Viewer Cache as a&lt;br&gt;
lab.HS.CTAntibiotics, referenced by a lab.HS.EPVisitTestSetDataAntibiotics&lt;br&gt;
that is related to the lab.HS.EPVisitTestSetData representing the organism&lt;br&gt;
identified. Otherwise, this TestItemCode will be stored as a CTTestCode&lt;br&gt;
referenced by EPVisitTestSetData. Note backslash ("\") is a reserved&lt;br&gt;
character for both of these tables (CTAntiobiotics and CTTestCode), so in&lt;br&gt;
the Viewer Cache only, backslashes in a TestItemCode Code or Description&lt;br&gt;
will be replaced with underscores ("_"). &lt;br&gt;
Also note that the matching of LabTestItem CodeTableDetails in the SDA to&lt;br&gt;
CTTestCodes in the Viewer Cache can optionally use the ResultValueUnits&lt;br&gt;
of this class as a match property. See the ResultValueUnits property for&lt;br&gt;
more details.&lt;br&gt;&lt;br&gt;
HL7:  OBX-3 : ObservationIdentifier&lt;br&gt;
SDATableName=LabTestItem, ViewerClass=User.HS.CTTestCode&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDTestCodeDR)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetDataAntibiotics(VISTAAntibioticDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Code is always parsed from OBX-3.1, but may be altered slightly from the&lt;br&gt;
original value depending on the message. See above.&lt;br&gt;
Viewer cache:&lt;br&gt;
As the Clinical Viewer does not support multiple instances of the same&lt;br&gt;
regular (not sensitivity) test item code with different SubIds in the same&lt;br&gt;
Result, Code may have a suffix of the form ":[#]" appended to it to make it&lt;br&gt;
unique within a the Result.&lt;br&gt;
Code will be stored in CTANTCode if this LabResultItem is determined to be&lt;br&gt;
an antibiotic sensitivity, and CTTestCode otherwise.&lt;br&gt;
HL7:  OBX-3.1 : ObservationIdentifier.Identifier&lt;br&gt;
VIEWERLIB:  User.HS.CTTestCode(CTTCCode)&lt;br&gt;
VIEWERLIB: lab.HS.CTAntibiotics(CTANTCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Description is always parsed from OBX-3.2, but may be altered slightly from&lt;br&gt;
the original value depending on the message. See above.&lt;br&gt;
HL7:  OBX-3.2 : ObservationIdentifier.Text&lt;br&gt;
VIEWERLIB: User.HS.CTTestCode(CTTCDesc)&lt;br&gt;
VIEWERLIB: lab.HS.CTAntibiotics(CTANTName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-3.3 : ObservationIdentifier.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodingSystemVersionId&lt;br&gt;
HL7:  OBX-3.7 : ObservationIdentifier.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.IsNumeric&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
IsNumeric will be set to "true" in the SDA if OBX-2 is "NM" or "ST",&lt;br&gt;
otherwise it will not be set.&lt;br&gt;
Viewer cache:&lt;br&gt;
The CTTCShowInCummulative property and the ARCIMDisplayCumulative property of the ARCItmMast 
for the current order will always be set to "Y", regardless of IsNumeric.&lt;br&gt;
HL7:  OBX-2 : ValueType&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultValue" type="s:string">
            <s:annotation>
                <s:documentation>Result's value&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The logic to parse ResultValue is:&lt;br&gt;
-If OBX-2 is "TX" or "FT":&lt;br&gt;
--Parse each instance of this OBX-5.1 (OBX-5 is repeating) to its own line&lt;br&gt;
in ResultValue, HL7-unescaped according to the annotation on&lt;br&gt;
HS.Gateway.HL7.HL7ToSDA3:unescape. If the next segment is an OBX with the&lt;br&gt;
same values for OBX-3.1 and .2, parse that OBX-5.1 to this ResultValue in&lt;br&gt;
the same way. Continue doing this until a non-OBX segment or an OBX with&lt;br&gt;
different values in fields 3.1 or 3.2 is encountered.&lt;br&gt;
-Else if Compatibility Mode is off and OBX-2="SN", parse ResultValue from&lt;br&gt;
OBX-5 as: "[5.1][5.2][5.3][5.4]". Ex: if OBX-5 = "&gt;^5", then &lt;br&gt;
ResultValue = "&gt;5"; if OBX-5="^1^-^10", then ResultValue="1-10".&lt;br&gt;
-Else if Compatibility Mode is off and OBX-2 is "CE", "CNE", or "CWE",&lt;br&gt;
parse OBX-5.2 to ResultValue.&lt;br&gt;
-Else if OBX-2="DT", parse the first non-null instance of OBX-5.1&lt;br&gt;
(converted from HL7 timestamp to XML timestamp format) to ResultValue.&lt;br&gt;
-Else parse the first non-null instance of OBX-5.1 (HL7-unescaped according&lt;br&gt;
to the annotation on HS.Gateway.HL7.HL7ToSDA3:unescape) to ResultValue.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The logic to insert ResultValue into the Viewer Cache is:&lt;br&gt;
-If the LabResultItem is an antibiotic sensitivity:&lt;br&gt;
--If the ResultValue consists of only punctuation and/or numbers, it is&lt;br&gt;
inserted into the VISTAResultMIC property of&lt;br&gt;
lab.HS.EPVisitTestSetDataAntibiotics.&lt;br&gt;
--Else ResultValue is not inserted into the Viewer Cache.&lt;br&gt;
-If the LabResultItem is not an antibiotic sensitivity, then the characters&lt;br&gt;
"^", "\", and "|" in the ResultValue are translated to $C(16), $C(17), and&lt;br&gt;
$C(18), respectively, before ResultValue is inserted into the VISTDTestData&lt;br&gt;
property of lab.HS.EPVisitTestSetData. (The reverse translation will be&lt;br&gt;
done when the data is displayed in the Clinical Viewer.)&lt;br&gt;&lt;br&gt;
HL7:  OBX-5 : ObservationValue&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetDataAntibiotics(VISTAResultMIC)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDTestData)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SubId">
            <s:annotation>
                <s:documentation>An ID that ties together different parts of a result (e.g. multiple&lt;br&gt;
organisms in a culture battery, multiple diagnostic impressions of a chest&lt;br&gt;
x-ray, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In some situations where an OBX-3.1 value appears more than once in a&lt;br&gt;
result, OBX-4 may get appended to it to make the TestItemCode Code unique&lt;br&gt;
within the Result. See TestItemCode for more info.&lt;br&gt;
If OBX-2="NM", OBX-4 is not null, and the following segment is an OBX that&lt;br&gt;
matches the current one on OBX-3.1 but not on OBX-4, then OBX-5.1 of the&lt;br&gt;
next segment will be parsed to the Comments of the current LabResultItem.&lt;br&gt;
See Comments for more info.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
Once saved to the Streamlet Cache, SubId cannot be deleted. In the&lt;br&gt;
OnBeforeMatch method of the LabOrder Streamlet class, if the SubId of an&lt;br&gt;
inbound LabResultItem is two double quotes (the delete instruction), it&lt;br&gt;
will be set to null and a warning logged. LabResultItems with the same&lt;br&gt;
SubId and TestItemCode.Code and .SDACodingStandard are considered to be the&lt;br&gt;
same item, so in the OnBeforeMatch method, any matching LabResultItems in&lt;br&gt;
the inbound ResultItems are condensed by calling UpdatedSDA on the first&lt;br&gt;
item with the second as its argument, removing the second from ResultItems,&lt;br&gt;
and repeating as necessary. Note that this excludes LabResultItems that are&lt;br&gt;
susceptibilities (ResultInterpretation= "S", "R", "I", "MS", "VS") and&lt;br&gt;
includes items with null SubIds.&lt;br&gt;
In the OnUpdateSDAResult method, if an inbound LabResultItem is determined&lt;br&gt;
not to be an antibiotic susceptibility, then it is compared to items in the&lt;br&gt;
existing Result on SubId and TestItemCode.Code and .SDACodingStandard. If a&lt;br&gt;
match is found, the existing item is updated by calling UpdateSDA on it with&lt;br&gt;
the inbound item as its argument. Otherwise the inbound item is inserted&lt;br&gt;
into the existing ResultItems.&lt;br&gt;
Sensitivities are processed in snapshot mode, so if an inbound&lt;br&gt;
LabResultItem is determined to be a sensitivity, then any existing&lt;br&gt;
sensitivities with the same SubId are deleted, and the inbound item is&lt;br&gt;
inserted into ResultItems after the organism item with the same SubId. This&lt;br&gt;
deletion only happens once per update though, so sensitivities just&lt;br&gt;
inserted will not be deleted.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
A LabResultItem will be inserted into the Viewer Cache as a&lt;br&gt;
lab.HS.EPVisitTestSetDataAntibiotics if the ResultInterpretation is "S",&lt;br&gt;
"R", "I", "MS", or "VS", if SubId is not null, and if the last regular (not&lt;br&gt;
sensitivity) item processed had the same SubId. The&lt;br&gt;
EPVisitTestSetDataAntibiotics will be linked to the EPVisitTestSetData&lt;br&gt;
created by that item via the relationship between them.&lt;br&gt;
VISTDMachineDR is only set for regular (not sensitivity) items.&lt;br&gt;&lt;br&gt;
HL7:  OBX-4 : SubId&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDMachineDR)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="30"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ResultValueUnits">
            <s:annotation>
                <s:documentation>Units of result value&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
ResultValueUnits is not stored for antibiotic sensitivities. In the&lt;br&gt;
OnUpdateSDAResult method of the LabOrder Streamlet class, if a&lt;br&gt;
LabResultItem is determined to be a sensitivity, ResultValueUnits will be&lt;br&gt;
set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For a regular (not sensitivity) test item, a "^" in ResultValueUnits will&lt;br&gt;
be translated to $C(16) before being inserted into CTTCUnits. (The reverse&lt;br&gt;
translation will be done when the value is displayed in the Clinical&lt;br&gt;
Viewer.)&lt;br&gt;
Also, if ResultValueUnits contains any "\" characters, these will be&lt;br&gt;
translated to "_" before being stored in the Viewer Cache. This translation&lt;br&gt;
is done in the Viewer Cache only. The original SDA is not affected.&lt;br&gt;
When LabTestItem CodeTableDetails are compared to CTTestCodes in the Viewer&lt;br&gt;
Cache to determine if there is a match, ResultValueUnits can optionally be&lt;br&gt;
included in the matching. If the value of the Configuration Registry key&lt;br&gt;
"\Viewer\LabTestItem\MatchOnUnits" is 1, then ResultValueUnits is used as&lt;br&gt;
a match property. It must match the CTTCUnits value for the comparison to&lt;br&gt;
be considered a match. Because of this, the CT_TestCode table can contain&lt;br&gt;
multiple instances of the same Code (made unique by uniqueness suffixes) so&lt;br&gt;
long as they have different CTTCUnits values. If this key is not set or if&lt;br&gt;
the value is not 1, ResultValueUnits is not used as a match property.&lt;br&gt;
LabTestItems will be matched on Code and SDACodingStandard only. If a&lt;br&gt;
LabTestItem and a CTTestCode match but the units differ, CTTCUnits will be&lt;br&gt;
updated with the ResultValueUnits value.&lt;br&gt;
ResultValueUnits is not stored in the Viewer Cache for sensitivities.&lt;br&gt;&lt;br&gt;
HL7:  OBX-6.1 : Units.Identifier&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDTestCodeDR)-&gt;User.HS.CTTestCode(CTTCUnits)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="30"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ResultNormalRange">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the LabOrder Streamlet class, for regular&lt;br&gt;
(not sensitivity) test items, ResultNormalRange is normalized via a call to&lt;br&gt;
NormalizeRange. The logic is:&lt;br&gt;
-Strip out any control characters (via $ZSTRIP, mask code "C").&lt;br&gt;
-If the first non-whitespace character is "&lt;" or "&gt;", the value is&lt;br&gt;
unchanged.&lt;br&gt;
-Else determine the high and low values of the range:&lt;br&gt;
--If the first non-whitespace character is "-" and the value contains "/",&lt;br&gt;
the low value is everything before the "/" and the high value is everything&lt;br&gt;
after. (This assumes only one "/".)&lt;br&gt;
--Else if the first non-whitespace character is "-" and the value contains&lt;br&gt;
at least one more "-", the low value is everything before the second "-",&lt;br&gt;
and the high value is everything after.&lt;br&gt;
--Else the low value is everything before "-", and the high value&lt;br&gt;
everything after. If there is no "-", the entire value is treated as the&lt;br&gt;
low value.&lt;br&gt;
-Once the high and low values have been determined, then if stripping the&lt;br&gt;
leading and trailing whitespace ($ZSTRIP, mask code "W") would make them&lt;br&gt;
valid numbers (determined by $IsValidNum), then this is done.&lt;br&gt;
-If both the low and high values are not null, the value is returned as:&lt;br&gt;
"[lo]-[hi]".&lt;br&gt;
-If the low value is null and the high value is not:&lt;br&gt;
--If the high value is a valid number ($IsValidNum), the value returned is&lt;br&gt;
returned as "&lt;[hi]", else the high value is returned.&lt;br&gt;
-If the high value is null and the low value is not:&lt;br&gt;
--If the low value is a valid number ($IsValidNum), the value returned is&lt;br&gt;
returned as "&gt;[lo]", else the low value is returned.&lt;br&gt;
-Else a null string is returned.&lt;br&gt;
After normalization, ResultNormalRange should have the form "&amp;lt;x", "&lt;=x",&lt;br&gt;
"&gt;x", "&gt;=x", "-x-y", "x-y", or some non-numeric value. ResultNormalRange is&lt;br&gt;
not used to calculate ResultInterpretation for this LabResultItem, however&lt;br&gt;
it may be used to flag the containing Result as abnormal. In the OnValidate&lt;br&gt;
method of the LabOrder Streamlet class, if a LabResultItem has an abnormal&lt;br&gt;
ResultInterpretation (H, HH, L, LL, A, or AA) or if it has no&lt;br&gt;
ResultInterpretation but ResultValue is numeric, ResultNormalRange is one&lt;br&gt;
of the numeric forms, and ResultValue is outside of ResultNormalRange, then&lt;br&gt;
ResultInterpretation of the containing Result will be set to "A".&lt;br&gt;
ResultNormalRange is not stored for antibiotic sensitivities. In the&lt;br&gt;
OnUpdateSDAResult method , if a LabResultItem is determined to be a&lt;br&gt;
sensitivity, ResultNormalRange will be set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
ResultNormalRange is stored as separate high and low values in the Viewer&lt;br&gt;
Cache. The logic to parse them out of the ResultNormalRange (which should&lt;br&gt;
have been normalized) is:&lt;br&gt;
-If the first non-whitespace character is "&lt;", the value is stored as the&lt;br&gt;
high value and the low value is null.&lt;br&gt;
-Else if the first non-whitespace character is "&gt;", the value is stored as&lt;br&gt;
the low value and the high value is null.&lt;br&gt;
-Else if the first non-whitespace character is "-", everything before the&lt;br&gt;
second "-" is the low value and everything after is the high value. If&lt;br&gt;
there isn't another "-", the entire value is stored as the low value.&lt;br&gt;
-Else if the value contains at least one "-", everything before the first&lt;br&gt;
"-" is the low value, and everything after is the high value.&lt;br&gt;
-Else the value is stored as the low value.&lt;br&gt;&lt;br&gt;
HL7:  OBX-7 : ReferencesRange&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDResultRefRangeLow) + lab.HS.EPVisitTestSetData(VISTDResultRefRangeHigh)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ResultInterpretation">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Each non-null instance of OBX-8 (as it is repeating) will be parsed to&lt;br&gt;
ResultInterpretation, separated by a comma. The value parsed may affect the&lt;br&gt;
way OBX-3 is parsed to TestItemCode. See TestItemCode for more info.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the LabOrder Streamlet class, if&lt;br&gt;
ResultInterpretation is not N, H, HH, L, LL, A, AA, S, I, R, MS, VS, null,&lt;br&gt;
or two double quotes (the delete instruction), it will be set to null and a&lt;br&gt;
warning logged. Also in the OnBeforeMatch method, LabResultItems with the&lt;br&gt;
same SubId and TestItemCode.Code and .SDACodingStandard are consolidated as&lt;br&gt;
they are considered to be the same item, except for items with&lt;br&gt;
ResultInterpretation= S, R, I, MS, or VS, as this indicates an antibiotic&lt;br&gt;
sensitivity, and the same antibiotic may appear multiple times in a result&lt;br&gt;
if multiple organisms were detected.&lt;br&gt;
In the OnUpdateSDAResult method, ResultInterpretation is used to determine&lt;br&gt;
whether an item is a sensitivity. The full logic is:&lt;br&gt;
-If (ResultInterpretation is S, R, I, MS, or VS,),&lt;br&gt;
-and (SubId is not null),&lt;br&gt;
-and ((this SubId appears in the existing data) OR (this SubId is the same&lt;br&gt;
as for the last non-sensitivity item with a non-null SubId)),&lt;br&gt;
-then this LabResultItem is a sensitivity,&lt;br&gt;
-else is is a regular item.&lt;br&gt;
Sensitivies are processed differently from regular items in this method.&lt;br&gt;
See the annotations on each property for more info.&lt;br&gt;
In the OnValidate method, if a LabResultItem has an abnormal&lt;br&gt;
ResultInterpretation (H, HH, L, LL, A, or AA) or if it has no&lt;br&gt;
ResultInterpretation but ResultValue is numeric, ResultNormalRange is a&lt;br&gt;
numeric form, and ResultValue is outside of ResultNormalRange, then&lt;br&gt;
ResultInterpretation of the containing Result will be set to "A".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
ResultInterpretation is used in the Viewer Cache to determine whether to&lt;br&gt;
insert a LabResultItem as a regular item (lab.HS.EPVisitTestSetData) or a&lt;br&gt;
sensitivitiy (lab.HS.EPVisitTestSetDataAntibiotics). The full logic is:&lt;br&gt;
-If ResultInterpretation is S, R, I, MS, or VS,&lt;br&gt;
-and SubId is not null,&lt;br&gt;
-and SubId matches the last regular test item inserted with a non-null&lt;br&gt;
SubId, but is not the item itself,&lt;br&gt;
-then insert the item as a sensitivity,&lt;br&gt;
-else insert it as a regular test item.&lt;br&gt;
If this item is inserted as a sensitivity, VISTAResultDR of the&lt;br&gt;
EPVisitTestSetDataAntibiotics will reference the lab.HS.CTSensitivity with&lt;br&gt;
CTSNCode=[ResultInterpretation]. Else ResultInterpretation will populate&lt;br&gt;
VISTDInstrumentFlags of EPVisitTestSetData.&lt;br&gt;&lt;br&gt;
HL7:  OBX-8 : AbnormalFlags&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetDataAntibiotics(VISTAResultDR)-&gt;lab.HS.CTSensitivity(CTSNCode)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDInstrumentFlags)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="100"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="TestItemStatus">
            <s:annotation>
                <s:documentation>Note that within HealthShare, the code for an item status of "Corrected" is&lt;br&gt;
"K", not "C".&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
An OBX-11 value of "C" will be parsed to the SDA as "K". Any other value&lt;br&gt;
will be parsed as-is.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the LabOrder Streamlet class, a&lt;br&gt;
TestItemStatus of "C" will be mapped to "K". Any other value will be&lt;br&gt;
unchanged.&lt;br&gt;
In the OnUpdateSDAResult method, if a match is found between an existing&lt;br&gt;
LabResultItem and an inbound item (for regular items only, sensitivities&lt;br&gt;
are not matched), if the existing TestItemStatus is "F" or "K", then if the&lt;br&gt;
ResultValue or ResultNormalRange of the existing item is updated or deleted&lt;br&gt;
by the inbound item, then TestItemStatus will be set to "K", regardless of&lt;br&gt;
what was passed in. Otherwise, TestItemStatus will be updated normally.&lt;br&gt;
Note that a deletion will only cause the status to be set to "K" if the&lt;br&gt;
existing item has a non-null value to delete.&lt;br&gt;
TestItemStatus is not stored for antibiotic sensitivities. In the&lt;br&gt;
OnUpdateSDAResult method, if a LabResultItem is determined to be a&lt;br&gt;
sensitivity, TestItemStatus will be set to null.&lt;br&gt;
In the OnValidate method, if the TestItemStatus of any&lt;br&gt;
LabResultItem is "K" and the ResultStatus of the containing Result is "F",&lt;br&gt;
the ResultStatus will be changed to "K".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
VISTDResultStatus is set for regular (not sensitivity) items. The value&lt;br&gt;
that will appear in the Clinical Viewer is the Description for the&lt;br&gt;
Trak "TestItemStatusHealthShare" Standard Type item with&lt;br&gt;
Internal Value = [TestItemStatus]. See the HS documentation for guidance on&lt;br&gt;
configuring Standard Types. For sensitivities, TestItemStatus is not&lt;br&gt;
inserted into the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBX-11 : ObservationResultStatus&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDResultStatus)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="100"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Each instance of each NTE-3 following an OBX in an atomic result will be&lt;br&gt;
parsed as one line in Comments. It is also possible for subsequent OBXs to&lt;br&gt;
be parsed as Comments on the current one. If the current OBX-2 is "NM" and&lt;br&gt;
the current OBX-4 is not null, and if the next segment is an OBX that&lt;br&gt;
matches the current one on OBX-3.1 but not on OBX-4, then each instance of&lt;br&gt;
the next OBX-5.1 will be parsed as a line in Comments. Each line will be&lt;br&gt;
HL7-unescaped according to the annotation on&lt;br&gt;
HS.Gateway.HL7.HL7ToSDA3:unescape. Once every instance of OBX-5.1 has been&lt;br&gt;
parsed, then if the next segment is an OBX with the same OBX-3.1 and .2,&lt;br&gt;
then that OBX-5.1 will be parsed in the same way. This will continue until&lt;br&gt;
a non-OBX or an OBX that does not match on fields 3.1 and .2 is&lt;br&gt;
encountered. Then, if any NTEs are following the last OBX, the NTE-3 values&lt;br&gt;
will be parsed to Comments as well.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
Comments is not stored for antibiotic sensitivities. In the&lt;br&gt;
OnUpdateSDAResult method, if a LabResultItem is determined to be a&lt;br&gt;
sensitivity, Comments will be set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For regular test items only (not sensitivities), the characters "^", "\",&lt;br&gt;
and "|" in Comments will be translated to $C(16), $C(17), and $C(18),&lt;br&gt;
respectively, before being saved to the Viewer Cache. (The reverse&lt;br&gt;
translation is done when Comments is output to the Clinical Viewer.)&lt;br&gt;
VISTDComments is set for regular test items only. Comments on sensitivites&lt;br&gt;
are not stored in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comments&lt;br&gt;
HL7:  OBX-5.1 : ObservationValue&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDComments)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReferenceComment">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
ReferenceComment is not stored for antibiotic sensitivities. In the&lt;br&gt;
OnUpdateSDAResult method, if a LabResultItem is determined to be a&lt;br&gt;
sensitivity, ReferenceComment will be set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
VISTDHL7ReferenceComment is set for regular test items only, not&lt;br&gt;
sensitivities.&lt;br&gt;&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDHL7ReferenceComment)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="1000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PerformedAt" type="Organization">
            <s:annotation>
                <s:documentation>PerformedAt / ProducersID&lt;br&gt;
This can be used to specify the external organization that actually did the&lt;br&gt;
test.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 1 or 10 of OBX-23 is not null, Code, Description, and&lt;br&gt;
SDACodingStandard will be parsed from OBX-23. Else if subfield 1 or 2 of&lt;br&gt;
OBX-15 is not null, Code, Description, and SDACodingStandard will be parsed&lt;br&gt;
from OBX-15.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
PerformedAt is not stored for antibiotic sensitivities. In the&lt;br&gt;
OnUpdateSDAResult method, if a LabResultItem is determined to be a&lt;br&gt;
sensitivity, PerformedAt will be set to null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
VISTDPerformedAtDR is set for regular test items only, not sensitivities.&lt;br&gt;&lt;br&gt;
HL7:  OBX-15 : ProducersReference&lt;br&gt;
HL7:  OBX-23 : PerformingOrganizationName&lt;br&gt;
HL7:  OBX-24 : PerformingOrganizationAddress&lt;br&gt;
HL7:  OBX-25 : PerformingOrganizationMedicalDirector&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDPerformedAtDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If being parsed from OBX-23, subfield 10 will be used if not null, else&lt;br&gt;
subfield 3 will be used.&lt;br&gt;
HL7:  OBX-23.10 : PerformingOrganizationName.OrganizationIdentifier&lt;br&gt;
HL7:  OBX-23.3 : PerformingOrganizationName.IDNumber&lt;br&gt;
HL7:  OBX-15.1 : ProducersReference.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBX-23.10 : PerformingOrganizationName.OrganizationName&lt;br&gt;
HL7:  OBX-15.2 : ProducersReference.Text&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-23.6 : PerformingOrganizationName.AssigningAuthority&lt;br&gt;
HL7:  OBX-15.3 : ProducersReference.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Address&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Address will only be parsed from OBX-24 is subfield 1 or 5 is not null. For&lt;br&gt;
the City, State, Zip, Country, and County properties, the HL7 field will be&lt;br&gt;
parsed to the Code. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  OBX-24 : PerformingOrganizationAddress&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If OBX-24.2 is not null, Street will be parsed as "[.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from OBX-24.1.&lt;br&gt;
HL7:  OBX-24.1 : PerformingOrganizationAddress.Street&lt;br&gt;
HL7:  OBX-24.2 : PerformingOrganizationAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPAddress)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  OBX-24.3 : PerformingOrganizationAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCity)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  OBX-24.4 : PerformingOrganizationAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPProvinceDR)&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  OBX-24.5 : PerformingOrganizationAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  OBX-24.6 : PerformingOrganizationAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountryDR)&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  OBX-24.9 : PerformingOrganizationAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountyParishDR)&lt;br&gt;&lt;br&gt;
.MedicalDirector&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MedicalDirector will only be parsed from OBX-25 if subfield 1, 2, or 9 is&lt;br&gt;
not null.&lt;br&gt;
HL7:  OBX-25 : PerformingOrganizationMedicalDirector&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.MedicalDirector.Code&lt;br&gt;
HL7:  OBX-25.1 : IDNumber&lt;br&gt;
.MedicalDirector.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  OBX-25.2 : FamilyName&lt;br&gt;
HL7:  OBX-25.3 : GivenName&lt;br&gt;
.MedicalDirector.SDACodingStandard&lt;br&gt;
HL7:  OBX-25.9 : AssigningAuthority&lt;br&gt;
.MedicalDirector.Name.FamilyName&lt;br&gt;
HL7:  OBX-25.2 : FamilyName&lt;br&gt;
.MedicalDirector.Name.GivenName&lt;br&gt;
HL7:  OBX-25.3 : GivenName&lt;br&gt;
.MedicalDirector.Name.MiddleName&lt;br&gt;
HL7:  OBX-25.4 : SecondandFurtherGivenNamesorInitialsThereof&lt;br&gt;
.MedicalDirector.Name.NamePrefix&lt;br&gt;
HL7:  OBX-25.6 : Prefix&lt;br&gt;
.MedicalDirector.Name.NameSuffix&lt;br&gt;
HL7:  OBX-25.5 : Suffix&lt;br&gt;
.MedicalDirector.Name.ProfessionalSuffix&lt;br&gt;
HL7:  OBX-25.21 : ProfessionalSuffix</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationMethods" type="ArrayOfObservationMethod">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
OBX-17 is a repeating field. Each non-null instance will be parsed as one&lt;br&gt;
ObservationMethod in this list.&lt;br&gt;&lt;br&gt;
HL7:  OBX-17 : ObservationMethod&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBX-17.1 : ObservationMethod.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBX-17.2 : ObservationMethod.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-17.3 : ObservationMethod.NameofCodingSystem&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBX-17.7 : ObservationMethod.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If OBX-17.4 or .5 are not null, then OBX-17.4, .5, .6, and .8 will be&lt;br&gt;
parsed to a PriorCode as Code, Description, CodeSystem, and&lt;br&gt;
CodeSystemVersionId, respectively.&lt;br&gt;
HL7:  OBX-17.4 : ObservationMethod.AlternateIdentifier&lt;br&gt;
HL7:  OBX-17.5 : ObservationMethod.AlternateText&lt;br&gt;
HL7:  OBX-17.6 : ObservationMethod.AlternateNameofCodingSystem&lt;br&gt;
HL7:  OBX-17.8 : ObservationMethod.AlternateCodingSystemVersion</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AnalysisTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time of analyis&lt;br&gt;&lt;br&gt;
HL7:  OBX-19.1 : DateTimeoftheAnalysis.Time&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationValueType" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBX-2 : ValueType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultCodedValue" type="ObservationValueCode">
            <s:annotation>
                <s:documentation>Coded value of result&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If OBX-2 is "CE", "CWE", or "CNE" and OBX-5.3 is not null, then OBX-5 will&lt;br&gt;
be parsed to ResultCodedValue.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5 : ObservationValue&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBX-5.1 : ObservationValue&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBX-5.2 : ObservationValue&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-5.3 : ObservationValue&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 of OBX-5 is not null, then subfields 4, 5, 6, and 8 will&lt;br&gt;
be parsed to the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  OBX-5.4 : ObservationValue&lt;br&gt;
HL7:  OBX-5.5 : ObservationValue&lt;br&gt;
HL7:  OBX-5.6 : ObservationValue&lt;br&gt;
HL7:  OBX-5.8 : ObservationValue&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBX-5.7 : ObservationValue&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  OBX-5.9 : ObservationValue</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ObservationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7:  OBX-14.1 : DateTimeOfTheObservation.Time&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSetData(VISTDInstrumentDate) + lab.HS.EPVisitTestSetData(VISTDInstrumentTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3: &lt;br&gt;
Though OBX-16 is a repeating field, only the first non-null instance will&lt;br&gt;
be parsed.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
EnteredBy is not stored for antibiotic sensitivities. In the&lt;br&gt;
OnUpdateSDAResult method, if a LabResultItem is determined to be a&lt;br&gt;
sensitivity, EnteredBy will be set to null.&lt;br&gt;&lt;br&gt;
HL7:  OBX-16 : ResponsibleObserver&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBX-16.1 : ResponsibleObserver.IDNumber&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  OBX-16.2.1 : ResponsibleObserver.FamilyName.Surname&lt;br&gt;
HL7:  OBX-16.3 : ResponsibleObserver.GivenName&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-16.9 : ResponsibleObserver.AssigningAuthority&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="LabResultItemExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="LabTestItem">
    <s:annotation>
        <s:documentation>The Viewer Cache table for LabTestItem, CT_TestCode, is not constrained to&lt;br&gt;
have unique Descriptions, so Description will never have a uniqueness&lt;br&gt;
suffix added to it in the Viewer Cache.&lt;br&gt;&lt;br&gt;
Note that in addition to the other reserved characters (documented in the&lt;br&gt;
CodeTableDetail class), LabTestItem Codes and Descriptions may not contain&lt;br&gt;
backslash characters ("\") in the Viewer Cache only. In the Viewer Cache,&lt;br&gt;
backslashes will be replaced with underscores ("_").&lt;br&gt;&lt;br&gt;
lab.HS.CTAntibiotics is for antibiotic sensitivities only. See&lt;br&gt;
HS.SDA3.LabResultItem:TestItemCode for more info.&lt;br&gt;&lt;br&gt;
Also note that the matching of LabTestItem CodeTableDetails in the SDA to&lt;br&gt;
CTTestCodes in the Viewer Cache can optionally use the ResultValueUnits&lt;br&gt;
of the containing LabResultItem as a match property. See&lt;br&gt;
HS.SDA3.LabResultItem:ResultValueUnits for more details.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="LabTestItemExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTTestCode(CTTCCode)
VIEWERLIB: lab.HS.CTAntibiotics(CTANTCode)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.CTTestCode(CTTCDesc)
VIEWERLIB: lab.HS.CTAntibiotics(CTANTName)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="IsNumeric" type="Boolean">
            <s:annotation>
                <s:documentation>Whether this test item is numeric.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The CTTCShowInCummulative property and the ARCIMDisplayCumulative property of the ARCItmMast 
for the current order will always be set to "Y", regardless of IsNumeric.&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="LabTestItemExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSpecimen">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Specimen" nillable="true" type="Specimen"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Specimen">
    <s:annotation>
        <s:documentation>Specimen appears in the SDA as a list property of the LabOrder, RadOrder,&lt;br&gt;
and OtherOrder HS.SDA3 classes. Specimens (the list of HS.SDA3.Specimen)&lt;br&gt;
should not be confused with the Specimen property of every Order class,&lt;br&gt;
which is a string.&lt;br&gt;&lt;br&gt;
HS.SDA3.Specimen is not loaded into the Viewer Cache, however the&lt;br&gt;
DisplaySpecimens method of web.SDA3.Order can be invoked to write out in an&lt;br&gt;
HTML textarea the details of all the HS.SDA3.Specimens linked to an order.&lt;br&gt;
As this method is intended to be invoked from the Clinical Viewer, it takes&lt;br&gt;
as parameters the IDs of the Trak PAPerson and OEOrdItem objects (Patient&lt;br&gt;
and Order). In the default Clinical Viewer layout, it is invoked from the&lt;br&gt;
OEOrder.Lab component (Order Details screen) as a custom expression:&lt;br&gt;
&lt;example&gt;
do ##class(web.SDA3.Order).DisplaySpecimens($G(%request.Data("PatientID",1)),$G(%request.Data("OEORIROWID",1)))
&lt;/example&gt;
Implementors of HealthShare are free to copy this method to a class of&lt;br&gt;
their own, make any changes needed, and customize their layout to call&lt;br&gt;
their custom method.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Optional ActionCode qualifier&lt;br&gt;
For selected SDA classes, this qualifies ActionCodes "I" (if it is&lt;br&gt;
supported) and "C" by giving them a scope. Ex: for Problems, ActionCode="C"&lt;br&gt;
and ActionScope="PAST" will only delete past problems. (The meaning of&lt;br&gt;
"past" is explained in HS.SDA3.Problem.) Whether ActionScope is supported&lt;br&gt;
and what values are supported is documented in each individual subclass.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="SpecimenExtension"/>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>HL7:  SPM-2 : SpecimenID&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="SpecimenType" type="SpecimenType">
            <s:annotation>
                <s:documentation>Specimen Type&lt;br&gt;&lt;br&gt;
HL7:  SPM-4 : SpecimenType&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-4.1 : SpecimenType.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-4.2 : SpecimenType.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-4.3 : SpecimenType.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-4.7 : SpecimenType.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-4.4 : SpecimenType.AlternateIdentifier&lt;br&gt;
HL7:  SPM-4.5 : SpecimenType.AlternateText&lt;br&gt;
HL7:  SPM-4.6 : SpecimenType.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-4.8 : SpecimenType.AlternateCodingSystemVersionID</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenTypeModifiers" type="ArrayOfSpecimenTypeModifier">
            <s:annotation>
                <s:documentation>Specimen Type Modifiers&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
SPM-5 is a repeating field. Each instance will be parsed as a&lt;br&gt;
SpecimenTypeModifier in the list.&lt;br&gt;&lt;br&gt;
HL7:  SPM-5 : SpecimenTypeModifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-5.1 : SpecimenTypeModifier.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-5.2 : SpecimenTypeModifier.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-5.3 : SpecimenTypeModifier.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-5.7 : SpecimenTypeModifier.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-5.4 : SpecimenTypeModifier.AlternateIdentifier&lt;br&gt;
HL7:  SPM-5.5 : SpecimenTypeModifier.AlternateText&lt;br&gt;
HL7:  SPM-5.6 : SpecimenTypeModifier.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-5.8 : SpecimenTypeModifier.AlternateCodingSystemVersionID</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenAdditives" type="ArrayOfSpecimenAdditive">
            <s:annotation>
                <s:documentation>Specimen Additives&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
SPM-6 is a repeating field. Each instance will be parsed as a&lt;br&gt;
SpecimenAdditive in the list.&lt;br&gt;&lt;br&gt;
HL7:  SPM-6 : SpecimenAdditives&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-6.1 : SpecimenAdditives.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-6.2 : SpecimenAdditives.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-6.3 : SpecimenAdditives.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-6.7 : SpecimenAdditives.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-6.4 : SpecimenAdditives.AlternateIdentifier&lt;br&gt;
HL7:  SPM-6.5 : SpecimenAdditives.AlternateText&lt;br&gt;
HL7:  SPM-6.6 : SpecimenAdditives.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-6.8 : SpecimenAdditives.AlternateCodingSystemVersionID</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CollectionMethod" type="CollectionMethod">
            <s:annotation>
                <s:documentation>Collection Method&lt;br&gt;&lt;br&gt;
HL7:  SPM-7 : SpecimenCollectionMethod&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-7.1 : SpecimenCollectionMethod.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-7.2 : SpecimenCollectionMethod.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-7.3 : SpecimenCollectionMethod.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-7.7 : SpecimenCollectionMethod.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-7.4 : SpecimenCollectionMethod.AlternateIdentifier&lt;br&gt;
HL7:  SPM-7.5 : SpecimenCollectionMethod.AlternateText&lt;br&gt;
HL7:  SPM-7.6 : SpecimenCollectionMethod.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-7.8 : SpecimenCollectionMethod.AlternateCodingSystemVersionID</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenSourceSite" type="SpecimenSourceSite">
            <s:annotation>
                <s:documentation>Specimen Source Site&lt;br&gt;&lt;br&gt;
HL7:  SPM-8 : SpecimenSourceSite&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-8.1 : SpecimenSourceSite.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-8.2 : SpecimenSourceSite.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-8.3 : SpecimenSourceSite.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-8.7 : SpecimenSourceSite.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-8.4 : SpecimenCollectionMethod.AlternateIdentifier&lt;br&gt;
HL7:  SPM-8.5 : SpecimenCollectionMethod.AlternateText&lt;br&gt;
HL7:  SPM-8.6 : SpecimenCollectionMethod.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-8.8 : SpecimenCollectionMethod.AlternateCodingSystemVersionID</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenSourceSiteModifiers" type="ArrayOfSpecimenSourceSiteModifier">
            <s:annotation>
                <s:documentation>Specimen Source Site Modifier&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
SPM-9 is a repeating field. Each instance will be parsed as a&lt;br&gt;
SpecimenSourceSiteModifier in the list.&lt;br&gt;&lt;br&gt;
HL7:  SPM-9 : SpecimenSourceSiteModifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-9.1 : SpecimenSourceSiteModifier.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-9.2 : SpecimenSourceSiteModifier.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-9.3 : SpecimenSourceSiteModifier.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-9.7 : SpecimenSourceSiteModifier.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-9.4 : SpecimenSourceSiteModifier.AlternateIdentifier&lt;br&gt;
HL7:  SPM-9.5 : SpecimenSourceSiteModifier.AlternateText&lt;br&gt;
HL7:  SPM-9.6 : SpecimenSourceSiteModifier.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-9.8 : SpecimenSourceSiteModifier.AlternateCodingSystemVersionID</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenRoles" type="ArrayOfSpecimenRole">
            <s:annotation>
                <s:documentation>Specimen Role&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
SPM-11 is a repeating field. Each instance will be parsed as a&lt;br&gt;
SpecimenRole in the list.&lt;br&gt;&lt;br&gt;
HL7:  SPM-11 : SpecimenRole&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-11.1 : SpecimenRole.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-11.2 : SpecimenRole.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-11.3 : SpecimenRole.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-11.7 : SpecimenRole.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-11.4 : SpecimenRole.AlternateIdentifier&lt;br&gt;
HL7:  SPM-11.5 : SpecimenRole.AlternateText&lt;br&gt;
HL7:  SPM-11.6 : SpecimenRole.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-11.8 : SpecimenRole.AlternateCodingSystemVersionID</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CollectionAmount">
            <s:annotation>
                <s:documentation>Specimen Collection Amount&lt;br&gt;&lt;br&gt;
HL7:  SPM-12.1 : SpecimenCollectionAmount.Quantity&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="999"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CollectionAmountUnits" type="UoM">
            <s:annotation>
                <s:documentation>Specimen Collection Amount&lt;br&gt;&lt;br&gt;
HL7:  SPM-12.2 : SpecimenCollectionAmount.Units&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-12.2.1 : SpecimenCollectionAmount.Units.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-12.2.2 : SpecimenCollectionAmount.Units.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-12.2.3 : SpecimenCollectionAmount.Units.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-12.2.7 : SpecimenCollectionAmount.Units.CodingSystemVersionID&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of the time range over which the sample was collected, as opposed to&lt;br&gt;
the time the sample collection device was recovered. A minimum of year,&lt;br&gt;
month, and day should be provided when the actual date/time is known.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-7.1 and SPM-17.1 represent the same value and therefore should contain&lt;br&gt;
the same value if both are present, however HealthShare does not enforce&lt;br&gt;
this. OBR-7.1 is parsed to Order.SpecimenCollectedTime. For OBXs reporting&lt;br&gt;
observations based on this specimen, OBX-14 should contain the same value&lt;br&gt;
as SPM-17.1, but again, this is not enforced. (Field 14 is not parsed from&lt;br&gt;
OBXs following the SPM.)&lt;br&gt;&lt;br&gt;
HL7:  SPM-17.1 : SpecimenCollectionDateTime.RangeStartDateTime&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of the time range over which the sample was collected&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-8.1 and SPM-17.2 represent the same value and therefore should contain&lt;br&gt;
the same value if both are present, however HealthShare does not enforce&lt;br&gt;
this. Currently OBR-8 is not parsed to the SDA.&lt;br&gt;&lt;br&gt;
HL7:  SPM-17.2 : SpecimenCollectionDateTime.RangeEndDateTime&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Time the specimen was received at the diagnostic service. The actual time&lt;br&gt;
that is recorded is based on how specimen receipt is managed, and may&lt;br&gt;
correspond to the time the sample is logged in.&lt;br&gt;&lt;br&gt;
HL7:  SPM-18 : SpecimenReceivedDateTime&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RejectReasons" type="ArrayOfSpecimenRejectReason">
            <s:annotation>
                <s:documentation>Specimen Reject Reason&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
SPM-21 is a repeating field. Each instance will be parsed as a&lt;br&gt;
SpecimenRejectReason in the list.&lt;br&gt;&lt;br&gt;
HL7:  SPM-21 : SpecimenRejectReason&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-21.1 : SpecimenRejectReason.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-21.2 : SpecimenRejectReason.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-21.3 : SpecimenRejectReason.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-21.7 : SpecimenRejectReason.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-21.4 : SpecimenRejectReason.AlternateIdentifier&lt;br&gt;
HL7:  SPM-21.5 : SpecimenRejectReason.AlternateText&lt;br&gt;
HL7:  SPM-21.6 : SpecimenRejectReason.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-21.8 : SpecimenRejectReason.AlternateCodingSystemVersionID&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  SPM-21.9 : SpecimenRejectReason.OriginalText&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Quality" type="SpecimenQuality">
            <s:annotation>
                <s:documentation>Specimen Quality&lt;br&gt;&lt;br&gt;
HL7:  SPM-22 : SpecimenQuality&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-22.1 : SpecimenQuality.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-22.2 : SpecimenQuality.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-22.3 : SpecimenQuality.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-22.7 : SpecimenQuality.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-22.4 : SpecimenQuality.AlternateIdentifier&lt;br&gt;
HL7:  SPM-22.5 : SpecimenQuality.AlternateText&lt;br&gt;
HL7:  SPM-22.6 : SpecimenQuality.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-22.8 : SpecimenQuality.AlternateCodingSystemVersionID&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  SPM-22.9 : SpecimenQuality.OriginalText</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Appropriateness" type="SpecimenAppropriateness">
            <s:annotation>
                <s:documentation>Specimen Appropriateness&lt;br&gt;&lt;br&gt;
HL7:  SPM-23 : SpecimenAppropriateness&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-23.1 : SpecimenAppropriateness.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-23.2 : SpecimenAppropriateness.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-23.3 : SpecimenAppropriateness.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-23.7 : SpecimenAppropriateness.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-23.4 : SpecimenAppropriateness.AlternateIdentifier&lt;br&gt;
HL7:  SPM-23.5 : SpecimenAppropriateness.AlternateText&lt;br&gt;
HL7:  SPM-23.6 : SpecimenAppropriateness.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-23.8 : SpecimenAppropriateness.AlternateCodingSystemVersionID&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  SPM-23.9 : SpecimenAppropriateness.OriginalText</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Condition" type="ArrayOfSpecimenCondition">
            <s:annotation>
                <s:documentation>Specimen Condition&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
SPM-24 is a repeating field. Each instance will be parsed as a&lt;br&gt;
SpecimenCondition in the list.&lt;br&gt;&lt;br&gt;
HL7:  SPM-24 : SpecimenCondition&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SPM-24.1 : SpecimenCondition.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  SPM-24.2 : SpecimenCondition.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SPM-24.3 : SpecimenCondition.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  SPM-24.7 : SpecimenCondition.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  SPM-24.4 : SpecimenCondition.AlternateIdentifier&lt;br&gt;
HL7:  SPM-24.5 : SpecimenCondition.AlternateText&lt;br&gt;
HL7:  SPM-24.6 : SpecimenCondition.NameofAlternateCodingSystem&lt;br&gt;
HL7:  SPM-24.8 : SpecimenCondition.AlternateCodingSystemVersionID&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  SPM-24.9 : SpecimenCondition.OriginalText&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Age">
            <s:annotation>
                <s:documentation>Specimen Age&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If there is an OBX segment immediately following the SPM, it will be parsed&lt;br&gt;
to the Age and AgeUnits of the Specimen. Though the OBX following the SPM&lt;br&gt;
is repeating, only one OBX per SPM will be parsed this way.&lt;br&gt;&lt;br&gt;
HL7:  OBX-5 : ObservationValue&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="999"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="AgeUnits" type="UoM">
            <s:annotation>
                <s:documentation>Specimen Age Units&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If there is an OBX segment immediately following the SPM, it will be parsed&lt;br&gt;
to the Age and AgeUnits of the Specimen. Though the OBX following the SPM&lt;br&gt;
is repeating, only one OBX per SPM will be parsed this way.&lt;br&gt;&lt;br&gt;
HL7:  OBX-6 : Units&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBX-6.1 : Units.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBX-6.2 : Units.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBX-6.3 : Units.NameofCodingSysten&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBX-6.7 : Units.CodingSystemVersionID&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Unlike other SDA types, the ActionCode for Specimen is not functional.&lt;br&gt;
There are no restrictions on the values it can contain, and setting it does&lt;br&gt;
not do anything to the Specimen.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Note that in an ORU message, there can be multiple SPM segments per OBR. In&lt;br&gt;
this case, the Specimen parsed from each SPM gets its ActionCode from&lt;br&gt;
the preceding OBR-11.&lt;br&gt;&lt;br&gt;
HL7:  OBR-11 : SpecimenActionCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="SpecimenExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenType">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenTypeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSpecimenTypeModifier">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="SpecimenTypeModifier" nillable="true" type="SpecimenTypeModifier"/>
    </s:sequence>
</s:complexType>
<s:complexType name="SpecimenTypeModifier">
    <s:annotation>
        <s:documentation>Specimen Type Modifier</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenTypeModifierExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenTypeModifierExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSpecimenAdditive">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="SpecimenAdditive" nillable="true" type="SpecimenAdditive"/>
    </s:sequence>
</s:complexType>
<s:complexType name="SpecimenAdditive">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenAdditiveExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenAdditiveExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="CollectionMethod">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="CollectionMethodExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="CollectionMethodExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenSourceSite">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenSourceSiteExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenSourceSiteExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSpecimenSourceSiteModifier">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="SpecimenSourceSiteModifier" nillable="true" type="SpecimenSourceSiteModifier"/>
    </s:sequence>
</s:complexType>
<s:complexType name="SpecimenSourceSiteModifier">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenSourceSiteModifierExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenSourceSiteModifierExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSpecimenRole">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="SpecimenRole" nillable="true" type="SpecimenRole"/>
    </s:sequence>
</s:complexType>
<s:complexType name="SpecimenRole">
    <s:annotation>
        <s:documentation>HL7: SPM-11</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenRoleExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenRoleExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSpecimenRejectReason">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="SpecimenRejectReason" nillable="true" type="SpecimenRejectReason"/>
    </s:sequence>
</s:complexType>
<s:complexType name="SpecimenRejectReason">
    <s:annotation>
        <s:documentation>HL7 code table 490 (Specimen Reject Reason)</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenRejectReasonExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenRejectReasonExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenQuality">
    <s:annotation>
        <s:documentation>HL7 code table 491 (Specimen Quality)</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenQualityExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenQualityExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenAppropriateness">
    <s:annotation>
        <s:documentation>HL7 coe table 492 (Specimen Appropriateness)</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenAppropriatenessExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenAppropriatenessExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSpecimenCondition">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="SpecimenCondition" nillable="true" type="SpecimenCondition"/>
    </s:sequence>
</s:complexType>
<s:complexType name="SpecimenCondition">
    <s:annotation>
        <s:documentation>HL7 code table 493 (Specimen Condition)</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecimenConditionExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecimenConditionExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ReasonforStudy">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ReasonforStudyExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ReasonforStudyExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="LabOrderExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfRadOrder">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="RadOrder" nillable="true" type="RadOrder"/>
    </s:sequence>
</s:complexType>
<s:complexType name="RadOrder">
    <s:annotation>
        <s:documentation>For Radiology Orders</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="PlacerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the PlacerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId. If the PlacerId, FillerId, ExternalId, and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the LabOrder&lt;br&gt;
will not be processed. If the LabOrder has no OrderItem and does not match&lt;br&gt;
exactly 1 other LabOrder in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId, which itself may have been&lt;br&gt;
defaulted to the Result ExternalId. If PlacerId, FillerId, ExternalId and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the Order will&lt;br&gt;
not be processed. If the Order has no OrderItem and does not match exactly&lt;br&gt;
1 other Order of the same type in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the Order will not be processed.&lt;br&gt;
-MED,VXU:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId. If the Order has no OrderItem&lt;br&gt;
or DrugProduct and does not match exactly 1 other Order of the same type in&lt;br&gt;
the same Encounter on PlacerId (ALPHAUP collated), an error will be logged&lt;br&gt;
and the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPlacerNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-2 will be used if a value can be parsed from it, else ORC-2 will be&lt;br&gt;
used. In either case, PlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the FillerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId, then to PlacerId, which itself&lt;br&gt;
may have been defaulted to ExternalId. If FillerId, PlacerId, ExternalId,&lt;br&gt;
and Result.ExternalId are all null, an error will be logged and the&lt;br&gt;
LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId. If FillerId, PlacerId,&lt;br&gt;
ExternalId, and Result.ExternalId are all null, an error will be logged and&lt;br&gt;
the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId. Also for LabOrders only, the stored&lt;br&gt;
value for FillerId in the Viewer Cache is required to be unique. If an&lt;br&gt;
inbound LabOrder.FillerId matches one already in the Viewer Cache (if the&lt;br&gt;
same patient record has been loaded multiple times, for example), the&lt;br&gt;
inbound value is made unique by appending "x[OEORDId]" to it, where&lt;br&gt;
"[OEORDId]" is the ID of the parent OEOrder to the OEOrdItem that the&lt;br&gt;
LabOrder is stored as.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIFillerNo)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabEpisodeNo)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3 will be used if a value can be parsed from it, else ORC-3 will be&lt;br&gt;
used. In either case, FillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OrderItem" type="Order">
            <s:annotation>
                <s:documentation>What was ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-4 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Medications and Vaccinations, in the OnBeforeMatch method of the&lt;br&gt;
Streamlet class, if the Order has no OrderItem but does have a DrugProduct,&lt;br&gt;
then an OrderItem will be defaulted in with Code, Description, and&lt;br&gt;
SDACodingStandard copied from the DrugProduct. For all types of Orders (and&lt;br&gt;
for Medications and Vaccinations, following this defaulting), if the Order&lt;br&gt;
has no OrderItem and does not match exactly 1 other Order of the same type&lt;br&gt;
in the same Encounter on PlacerId (ALPHAUP collated), an error will be&lt;br&gt;
logged and the Order will not be processed. In the OnValidate method, if&lt;br&gt;
the Order does not have an OrderItem (if it was deleted in an update, for&lt;br&gt;
example), an error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7: OBR-4 : UniversalServiceIdentifier&lt;br&gt;
SDATableName=Order, ViewerClass=User.HS.ARCItmMast&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItmMastDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
Viewer cache:&lt;br&gt;
TRName is for text results only.&lt;br&gt;
HL7:  OBR-4.1 : UniversalServiceIdentifier.Identifier&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMCode)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRName)&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-4.2 : UniversalServiceIdentifier.Text&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-4.3 : UniversalServiceIdentifier.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-4.7 : UniversalServiceIdentifier.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to subfield 1 or 2 not being null, if subfield 4 or 5 is not&lt;br&gt;
null, then subfields 4, 5, 6, and 8 will be parsed into the Code,&lt;br&gt;
Description, CodeSystem, and CodeSystemVersionId, respectively, of a&lt;br&gt;
PriorCode in the list of PriorCodes. In this case, the PriorCode Type is&lt;br&gt;
set to "A".&lt;br&gt;
HL7:  OBR-4.4 : UniversalServiceIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-4.5 : UniversalServiceIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-4.6 : UniversalServiceIdentifier.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-4.8 : UniversalServiceIdentifier.AlternateCodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  OBR-4.9 : UniversalServiceIdentifier.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderCategory" type="OrderCategory">
            <s:annotation>
                <s:documentation>Can be used to group orders in the Clinical Viewer.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-24 is parsed to the OrderCategory Code. HL7ToSDA3 does not set the&lt;br&gt;
Description. The parsed value is converted to uppercase in the SDA.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For all Order types, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order has an OrderCategory, then the InfoSubType of the streamlet is&lt;br&gt;
set to the OrderCategory Code, converted to uppercase.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The OrderCategory is stored as a property of the ARCItmMast (OrderItem),&lt;br&gt;
which is itself a property of the OEOrderItem (Order).&lt;br&gt;&lt;br&gt;
HL7:  OBR-24 : DiagnosticServSectID&lt;br&gt;
SDATableName=OrderCategory, ViewerClass=User.HS.ARCItemCat&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMItemCatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderQuantity" type="s:string">
            <s:annotation>
                <s:documentation>Number of items ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderQuantity is parsed from (in order of precendence) TQ1-2.1, RXE-1.1.1,&lt;br&gt;
OBR-27.1.1, or ORC-7.1.1. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Quantity in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  OBR-27.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  RXE-1.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  TQ1-2.1   : Quantity.Quantity&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>Who placed the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderedBy is parsed from (in order of precendence) OBR-16, RXO-14, RXE-13,&lt;br&gt;
or ORC-12 and -24. Though each of these fields is repeating, for each one&lt;br&gt;
except ORC-24, HL7ToSDA3 will only parse the first non-null instance. For&lt;br&gt;
ORC-24, the instance corresponding to the first non-null instance of ORC-12&lt;br&gt;
will be parsed. ORC-12 and -24 are used in combination to set the&lt;br&gt;
provider's Name and Address in the SDA. Every other field only sets the&lt;br&gt;
Name. For Adress.City, .State, .Zip, .Country, and .County as well as NameTypeCode&lt;br&gt;
and IdentifierTypeCode, only the Code is parsed. HL7ToSDA3 does not set the&lt;br&gt;
Description. Note that an RDE_O11 message technically can contain both an&lt;br&gt;
RXO segment and an RXE, however HL7ToSDA3 does not parse the RXO segment&lt;br&gt;
from an RDE message.&lt;br&gt;&lt;br&gt;
HL7:  ORC-12 : OrderingProvider&lt;br&gt;
HL7:  ORC-24 : OrderingProviderAddress&lt;br&gt;
HL7:  RXE-13 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  RXO-14 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  OBR-16 : OrderingProvider&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDoctorDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-12.1 : OrderingProvider.IDNumber&lt;br&gt;
HL7:  RXE-13.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  RXO-14.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  OBR-16.1 : OrderingProvider.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-12.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
HL7:  RXE-13.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  RXO-14.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  OBR-16.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-12.4 : OrderingProvider.MiddleName&lt;br&gt;
HL7:  RXE-13.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  RXO-14.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  OBR-16.4 : OrderingProvider.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-12.6 : OrderingProvider.NamePrefix&lt;br&gt;
HL7:  RXE-13.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  RXO-14.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  OBR-16.6 : OrderingProvider.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-24.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-24.1.1.&lt;br&gt;
HL7:  ORC-24.1.1 : OrderingProviderAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-24.2 : OrderingProviderAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPStName)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-24.3 : OrderingProviderAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCityDR)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-24.4 : OrderingProviderAddress.StateorProvince&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-24.5 : OrderingProviderAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-24.6 : OrderingProviderAddress.Country&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-24.9 : OrderingProviderAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.NameTypeCode&lt;br&gt;
HL7:  OBR-16.10 : OrderingProvider.NameTypeCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.IdentifierTypeCode&lt;br&gt;
HL7:  OBR-16.13 : OrderingProvider.IdentifierTypeCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteringOrganization" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Entering Facility (Location)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-13 is only parsed if subfield 1 is not null. Only the Code is parsed.&lt;br&gt;
HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
HL7:  ORC-13.1 : EnterersLocation.PointofCare&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIOrdDeptDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Only the Code is parsed. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>VerifiedBy (CareProvider)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-32 will be used if present, else the first non-null instance of ORC-11&lt;br&gt;
will be used, if there is one.&lt;br&gt;&lt;br&gt;
HL7:  ORC-11 : VerifiedBy&lt;br&gt; 
HL7:  OBR-32 : PrincipalResultInterpreter&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthoriseClinicianDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-11.1 : VerifiedBy.IDNumber&lt;br&gt;
HL7:  OBR-32.1.1 : PrincipalResultInterpreter.Name.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields, the given and family names are concatenated together as&lt;br&gt;
"[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-11.9 : VerifiedBy.AssigningAuthority&lt;br&gt;
HL7:  OBR-32.1.9 : PrincipalResultInterpreter.Name.AssigningAuthorityNamespaceID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-11.4 : VerifiedBy.SecondandFurtherGivenNames&lt;br&gt;
HL7:  OBR-32.1.4 : PrincipalResultInterpreter.Name.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-11.6 : VerifiedBy.Prefix&lt;br&gt;
HL7:  OBR-32.1.6 : PrincipalResultInterpreter.Name.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  ORC-11.7 : VerifiedBy.Degree&lt;br&gt;
HL7:  OBR-32.1.5 : PrincipalResultInterpreter.Name.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  OBR-32.1.7 : PrincipalResultInterpreter.Name.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CallbackNumber">
            <s:annotation>
                <s:documentation>Callback number (who to contact with questions, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-17 is used if any regular (business), mobile, or fax numbers or e-mail&lt;br&gt;
addresses can be parsed from it, else ORC-14 is used. In either case, the&lt;br&gt;
format of CallbackNumber is: "[List of business #s], Mobile: [List of&lt;br&gt;
mobile #s], Fax: [List of fax #s], email: [List of e-mail addresses]". Each&lt;br&gt;
list is comma-delimited. Each tag (Mobile, Fax, email) will only be used if&lt;br&gt;
there are elements of that type. For each field, every instance will be&lt;br&gt;
parsed, if that field is used. Up to three numbers can be parsed from each&lt;br&gt;
instance of a field:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, a number is parsed from them&lt;br&gt;
as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-If subfield 12 is not null, it is parsed.&lt;br&gt;
-If subfield 1 is not null, it is parsed.&lt;br&gt;
-Additionally, if subfield 9 is not null, the first number parsed from that&lt;br&gt;
instance will have it appended to the end after a semicolon separator.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;
The logic to determine the type of the number is:&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 is in ["",PH], the&lt;br&gt;
number is a regular (business) number.&lt;br&gt;
-If subfield 2 = "BPN" and subfield 3 is in [CP,BP], the number is a mobile&lt;br&gt;
number.&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 = "FX", the number is&lt;br&gt;
a fax number.&lt;br&gt;
Finally, each non-null instance of subfield 4 is parsed as an e-mail&lt;br&gt;
address.&lt;br&gt;&lt;br&gt;
HL7:  OBR-17 : OrderCallbackPhoneNumber&lt;br&gt;
HL7:  ORC-14 : CallBackPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINotify)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Specimen">
            <s:annotation>
                <s:documentation>Specimen code or description as a string&lt;br&gt;
Not to be confused with the Specimens property of LabOrder, RadOrder, and&lt;br&gt;
OtherOrder, which is of type List of HS.SDA3.Specimen.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-15.1.2 will be used if not null, else OBR-15.1.1 will be used.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Specimen is inserted into the Viewer Cache as a CTSpecimen with SPECCode&lt;br&gt;
and SPECDesc=[Specimen]. The CTSpecimen is the linked to the ARCItmMast&lt;br&gt;
(OrderItem) via an ARCItemSpecimen. Specimen is also inserted as an&lt;br&gt;
OEOrdSpecimen (with SPECCode=[Specimen]) that is linked to the OEOrdItem&lt;br&gt;
(Order). Note that backslash ("\") is a reserved character for the&lt;br&gt;
CTSpecimen table, so Specimen should not contain a backslash.&lt;br&gt;&lt;br&gt;
HL7: OBR-15 : SpecimenSource&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.CTSpecimen&lt;br&gt;
VIEWERLIB: User.HS.OEOrdSpecimen(SPECCode)&lt;br&gt;
VIEWERLIB: User.HS.CTSpecimen(SPECCode) + User.HS.CTSpecimen(SPECDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="SpecimenCollectedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the specimen was collected&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-7.1 and SPM-17.1 represent the same value and therefore should contain&lt;br&gt;
the same value if both are present, however HealthShare does not enforce&lt;br&gt;
this. SPM-17.1 is parsed to Specimen.FromTime.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIEpisArriveDate and OEORIEpisArriveTime are only set for Lab, Rad, and&lt;br&gt;
Other Orders, not Medications or Vaccinations. SPECDate and SPECTime are&lt;br&gt;
only set if the Order contains a Specimen (the string property, not an&lt;br&gt;
HS.SDA3.Specimen). The properties of lab.HS.EPVisitNumber and&lt;br&gt;
EPVisitTestSet are set for atomic results only. Note that while&lt;br&gt;
VISTSTimeOfCollection is a %Time, EPVISTimeOfCollection is not. It is a&lt;br&gt;
%String value containing the time as a number of minutes since midnight.&lt;br&gt;&lt;br&gt;
HL7:  OBR-7.1 : ObservationDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEpisArriveDate) + User.HS.OEOrdItem(OEORIEpisArriveTime)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdSpecimen(SPECDate) + User.HS.OEOrdSpecimen(SPECTime)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitNumber(EPVISDateOfCollection) + lab.HS.EPVisitNumber(EPVISTimeOfCollection)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSet(VISTSDateOfCollection) + lab.HS.EPVisitTestSet(VISTSDateOfCollection)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenReceivedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the specimen was received&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORILabReceiveDate and OEORILabReceiveTime are only set for Lab, Rad, and&lt;br&gt;
Other Orders, not Medications or Vaccinations. The properties of&lt;br&gt;
lab.HS.EPVisitNumber are set for atomic results only. Note that&lt;br&gt;
EPVISTimeOfReceiving is not a %Time but rather a %String value containing&lt;br&gt;
the time as a number of minutes since midnight.&lt;br&gt;&lt;br&gt;
HL7: OBR-14.1 : SpecimenReceivedDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabReceiveDate) + User.HS.OEOrdItem(OEORILabReceiveTime)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitNumber(EPVISDateOfReceiving) + lab.HS.EPVisitNumber(EPVISTimeOfReceiving)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReassessmentTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>If the Order is not final, this is the date/time when it should be reviewed&lt;br&gt;
and perhaps finalized.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIReassessmentDate) + User.HS.OEOrdItem(OEORIReassessmentTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Frequency" type="Frequency">
            <s:annotation>
                <s:documentation>How often (e.g. Code=QID, Desc=QID, Factor=4)&lt;br&gt;
QID is Latin, meaning 4x a day.  BID means 2x day, etc.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though TQ1-3 is a repeating field, HL7ToSDA3 will only parse the first&lt;br&gt;
non-null instance.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Frequency, then that&lt;br&gt;
Frequency will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-3 : RepeatPattern&lt;br&gt;
SDATableName=Frequency, ViewerClass=User.HS.PHCFreq&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPHFreqDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  TQ1-3.1.1 : RepeatPattern.RepeatPatternCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-3.1.2 : RepeatPattern.RepeatPatternCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7:  TQ1-3.5 : RepeatPattern.PeriodQuantity&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRFactor)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Duration" type="Duration">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Duration is parsed from (in order of precedence) TQ1-6, RXE-1.3, OBR-27.3,&lt;br&gt;
or ORC-7.3. The RXE, OBR, and ORC fields will only set the Duration Code.&lt;br&gt;
TQ1-6 will populate the Code, Description, and Factor as described below.&lt;br&gt;
Though ORC-7 is a repeating field, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance. OBR-27 is also a repeating field, and HL7ToSDA3 parses every&lt;br&gt;
non-null instance of it. The last non-null instance of Duration in OBR-27&lt;br&gt;
is the one that takes precedence. Note that an RDE_O11 message may contain&lt;br&gt;
TQ1 segments in two different places. HL7ToSDA3 parses the one following&lt;br&gt;
the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Duration, then that Duration&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  TQ1-6 : ServiceDuration&lt;br&gt;
SDATableName=Duration, ViewerClass=User.HS.PHCDuration&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDuratDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
When parsing the TQ1-6 field, Code is initially parsed from subfield 2.1&lt;br&gt;
(Units.Identifier). If subfield 1 (Quantity) is not null, then if subfields&lt;br&gt;
2.1 and 2.2 (Units.Text) are null, Code will be parsed from Quantity. Then,&lt;br&gt;
if Quantity starts with a non-zero number and the parsed value for Code&lt;br&gt;
does not, the parsed value for Code is set to +[Quantity]_[Code]. For&lt;br&gt;
example, if Quantity="2" and Units.Identifier="D", the value parsed to Code&lt;br&gt;
is "2D". For the other segments that Duration Code may be parsed from (RXE,&lt;br&gt;
OBR, ORC), the value is simply parsed from the field listed below.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null and +[Quantity] is logically "true",&lt;br&gt;
and if TQ1-6.2.2 (Units.Text) is not null and +[Units.Text] is logically&lt;br&gt;
"false" (basically, if Quantity starts with a number and Units.Text&lt;br&gt;
doesn't), then the value parsed to Description is&lt;br&gt;
+[Quantity]_" "_[Units.Text]. For example, if Quantity="2" and&lt;br&gt;
Units.Text="Days", the value parsed to Description is "2 Days". If these&lt;br&gt;
conditions are not all met then the Description is simply parsed from&lt;br&gt;
TQ1-6.2.2.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null, then if +[Quantity] is logically "true",&lt;br&gt;
Factor is parsed as +[Quantity], otherwise Factor is parsed as null. If&lt;br&gt;
Quantity is null, then if +[TQ1-2.1/Units.Identifier] is logically "true",&lt;br&gt;
Factor is parsed as +[Units.Identifier], else if +[TQ1-2.2/Units.Text] is&lt;br&gt;
logically "true", Factor is parsed as +[Units.Text], else Factor is not&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUFactor)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status">
            <s:annotation>
                <s:documentation>The current status of the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The following values are mapped in the HL7 to SDA3 parsing:&lt;br&gt;
DC-&gt;D, CA-&gt;C, RP-&gt;R, HD-&gt;H, SC-&gt;IP, CM-&gt;E, [Other]-&gt;unchanged&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For any type of Order, in the OnValidate method of the streamlet class, if&lt;br&gt;
Status is null, it is defaulted to "V" for "Verified". Then, for Orders&lt;br&gt;
that can have results (LabOrder, RadOrder, OtherOrder), if the Order has a&lt;br&gt;
Result, Status is set to "E" for "Executed", unless it is "D", "C", "R", or&lt;br&gt;
"H" (for Discontinued, Cancelled, Replaced, or On Hold, respectively). The&lt;br&gt;
reasoning behind setting the Status to "E" is that if the Order has a&lt;br&gt;
Result, then it must have been executed. The reasoning behind the&lt;br&gt;
exceptions to this is that those particular statuses may have been entered&lt;br&gt;
after the Result was submitted. Also, for any type of Order, when Orders of&lt;br&gt;
of that type are inactivated with ActionCode="I", the Status of each will&lt;br&gt;
be set to "I".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Status is stored in the Viewer Cache as an OECOrderStatus with OSTATCode&lt;br&gt;
matching Status, ALPHAUP collated. If no such entry in OECOrderStatus&lt;br&gt;
exists, Status will be stored as V/Verified in the Viewer Cache only and an&lt;br&gt;
alert logged in the Ensemble Event Log. Note that the OECOrderStatus table&lt;br&gt;
is loaded from the SITE- or HS-Default-OrderStatus.txt file at the time the&lt;br&gt;
Access Gateway is reset.&lt;br&gt;&lt;br&gt;
HL7:  ORC-5 : OrderStatus&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.OECOrderStatus&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemStatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Priority" type="Priority">
            <s:annotation>
                <s:documentation>The Priority of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Priority is parsed from (in order of precendence) TQ1-9, RXE-1.6, OBR-27.6,&lt;br&gt;
OBR-5, or ORC-7.6. TQ1-9 may set the Code, Description, and&lt;br&gt;
SDACodingStandard. Every other field only sets the Code. Though TQ1-9 and&lt;br&gt;
ORC-7 are repeating fields, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance of each. OBR-27 is also a repeating field, and HL7ToSDA3 parses&lt;br&gt;
every non-null instance of it. The last non-null instance of Priority in&lt;br&gt;
OBR-27 is the one that takes precedence. Note that an RDE_O11 message may&lt;br&gt;
contain TQ1 segments in two different places. HL7ToSDA3 parses the one&lt;br&gt;
following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order contains no Priority, one is defaulted in with Code="N" and &lt;br&gt;
Description="Normal".&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9   : Priority&lt;br&gt;
SDATableName=Priority, ViewerClass=User.HS.OECPriority&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPriorityDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9.1  : Priority.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-9.2  : Priority.Text&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  TQ1-9.3  : Priority.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConfidentialityCode" type="Confidentiality">
            <s:annotation>
                <s:documentation>Confidentiality code (e.g. VIP, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-28 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-28 : ConfidentialtyCode&lt;br&gt;
SDATableName=Confidentiality, ViewerClass=User.HS.OECOverReasonNonConsent&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINoConsentOverrideReasDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-28.1 : ConfidentialtyCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-28.2 : ConfidentialtyCode.Text&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-28.3 : ConfidentialtyCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Condition">
            <s:annotation>
                <s:documentation>Condition, e.g. "keep BP below 110"&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Condition is parsed from (in order of precendence) TQ1-10, RXE-1.7,&lt;br&gt;
OBR-27.7, or ORC-7.7. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Condition in OBR-27 is the one that takes precendence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  OBR-27.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  RXE-1.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  TQ1-10  : ConditionText&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILtClinicalCondition)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="TextInstruction" type="s:string">
            <s:annotation>
                <s:documentation>Text instructions or directions, e.g. "After food", or if Duration etc.&lt;Br&gt;
isn't coded, "Take 3 twice a day"&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
TextInstruction is parsed from (in order of precendence) TQ1-11, RXE-1.8,&lt;br&gt;
OBR-27.8, or ORC-7.8. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Text in OBR-27 is the one that takes precendence. Note that an RDE_O11&lt;br&gt;
message may contain TQ1 segments in two different places. HL7ToSDA3 parses&lt;br&gt;
the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a TextInstruction, then that&lt;br&gt;
TextInstruction will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.8 : QuantityTiming.Text&lt;br&gt;
HL7:  OBR-27.8 : QuantityTiming.Text&lt;br&gt;
HL7:  RXE-1.8 : QuantityTimingText&lt;br&gt;
HL7:  TQ1-11  : TextInstruction&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDepProcNotes)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderGroup" type="s:string">
            <s:annotation>
                <s:documentation>This is a way to group related Orders together, such as a prescription&lt;br&gt;
chain.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemGroup)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Order Comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Order Comments are always parsed from NTE segments, though HL7 order&lt;br&gt;
messages may contain NTEs in different places, and only certain ones are&lt;br&gt;
parsed to Order Comments. For ORM and OMP messages, it is the first set of&lt;br&gt;
NTEs following the ORC (in the message schema, not necessarily in the&lt;br&gt;
message) that are parsed to Comments.  In an RDE message the set of NTEs&lt;br&gt;
following the RXE segment are parsed to Order Comments. Order Comments can&lt;br&gt;
only be parsed from an ORU message if it contains a text result (either&lt;br&gt;
ORC-29 is not "LAB", or all OBX-2 values = "FT", "TX", or "ED"). In this&lt;br&gt;
case the NTEs immediately following the OBR are parsed to Order Comments.&lt;br&gt;
In an ORU containing atomic lab results, the NTEs following the OBR are&lt;br&gt;
parsed to the Result Comments, and in an ORU containing Observations&lt;br&gt;
(ORC-29="OBS"), these NTEs are not parsed.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRemarks)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConsultationDepartment" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Department or facility that consulted&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIConsultDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AuthorizationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the order was authorized&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthorisedDate) + User.HS.OEOrdItem(OEORIAuthorisedTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReceivingLocation" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Location or facility receiving/performing the order&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRecDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedComments" type="s:string">
            <s:annotation>
                <s:documentation>Verified order comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthComments)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultCopiesTo" type="ArrayOfCareProvider">
            <s:annotation>
                <s:documentation>Who to send copies of results to&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-28 is a repeating field, and HL7ToSDA3 will parse each instance with a&lt;br&gt;
non-null value in subfield 1.&lt;br&gt;&lt;br&gt;
HL7:  OBR-28  : ResultCopiesTo&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-28.1 : ResultCopiesTo.Code&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  OBR-28.2.1 : ResultCopiesTo.FamilyName.Surname&lt;br&gt;
HL7:  OBR-28.3 : ResultCopiesTo.GivenName&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-28.9 : ResultCopiesTo.AssigningAuthority&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  OBR-28.2.1 : ResultCopiesTo.FamilyName.Surname&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  OBR-28.3 : ResultCopiesTo.GivenName&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  OBR-28.6 : ResultCopiesTo.Prefix&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  OBR-28.7 : ResultCopiesTo.Degree&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupId" type="s:string">
            <s:annotation>
                <s:documentation>If this item was ordered as part of a group, this is the identifier of that&lt;br&gt;
group. The SDA2-to-SDA3 transform populates this field with the SDA2&lt;br&gt;
ExternalId property.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.1 : PlacerGroupNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILab1)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupAssigningAuthority" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
GroupAssigningAuthority is composed of subfields 2, 3, and 4 concatenated&lt;br&gt;
together as "[.2]^[.3]^[.4]", but only if at least one of these is not&lt;br&gt;
null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.2: PlacerGroupNumber.NamespaceID&lt;br&gt;
HL7:  ORC-4.3: PlacerGroupNumber.UniversalID&lt;br&gt;
HL7:  ORC-4.4: PlacerGroupNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate all orders of this type (set Status="I")&lt;br&gt;
C = Clear/delete all orders of this type&lt;br&gt;
R = Replace - Applies only to Atomic Result Items.  Clears previous result items before storing all new items,
ignoring matching on test item code.  &lt;b&gt;Use ONLY when always receiving full updates.  Using this with
partial updates may cause a loss of test item data.&lt;/b&gt;&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation of the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in ORC-1 will be parsed as ActionCode="I", while&lt;br&gt;
four double quotes ("""") will be parsed as ActionCode="C". &lt;br&gt;
ActionCode="R" in ORC-1 will impact parsing of TestItemCode.  See the
TestItemCode property of HS.SDA3.LabResultItem for details.&lt;br&gt;
Any other value will not be parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-1 : OrderControl&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Only used for Medications, see the annotation in HS.SDA3.Medication.&lt;br&gt;
Otherwise ActionScope is not used for Orders.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-10 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-10 : EnteredBy&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserUpdate)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-10.1 : EnteredBy.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-10.2.1 : EnteredBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-10.3 : EnteredBy.GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-10.9 : EnteredBy.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-21 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed. ORC-22 is also a repeating field, however HL7ToSDA3 will only parse&lt;br&gt;
the instance corresponding to the instance of ORC-21 parsed. For example,&lt;br&gt;
if the third instance of ORC-21 is parsed (because the first two are null),&lt;br&gt;
then the third instance of ORC-22 will be parsed as well. For Address.City,&lt;br&gt;
State, Zip, Country, and County only the Code is parsed. HL7ToSDA3 does not&lt;br&gt;
set the Description. Every instance of ORC-23 will be examined but may not&lt;br&gt;
be parsed to the SDA. The algorithm to parse a number out of one instance&lt;br&gt;
of ORC-23 is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else no number can be parsed from this instance.&lt;br&gt;
-Whichever number is parsed, if subfield 9 of that instance is not null, it&lt;br&gt;
will be appended to the number, delimited by a semicolon.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;&lt;br&gt;
HL7:  ORC-21 : OrderingFacilityName&lt;br&gt;
HL7:  ORC-22 : OrderingFacilityAddress&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserAddHospDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-21.10 will be parsed to the Code if present, else ORC-21.3 will.&lt;br&gt;
HL7:  ORC-21.10 : OrderingFacilityName.OrganizationIdentifier&lt;br&gt;
HL7:  ORC-21.3 : OrderingFacilityName.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-21.1 : OrderingFacilityName.OrganizationName&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-21.6 : OrderingFacilityName.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-22.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-22.1.1.&lt;br&gt;
HL7:  ORC-22.1.1 : OrderingFacilityAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-22.2 : OrderingFacilityAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPAddress)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-22.3 : OrderingFacilityAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCity)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-22.4 : OrderingFacilityAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPProvinceDR)&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-22.5 : OrderingFacilityAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-22.6 : OrderingFacilityAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountryDR)&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-22.9 : OrderingFacilityAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountyParishDR)&lt;br&gt;
.ContactInfo.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
WorkPhoneNumber is parsed from the first instance of ORC-23 with subfield 2&lt;br&gt;
in ["",WPN,ASN,EMR] and subfield 3 in ["",PH] and from which a phone number&lt;br&gt;
can be parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPPhone)&lt;br&gt;
.ContactInfo.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MobilePhoneNumber is parsed from the first instance of ORC-23 with subfield&lt;br&gt;
2 = "BPN" and subfield 3 in [CP,BP] and from which a phone number can be&lt;br&gt;
parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ContactInfo.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
EmailAddress is parsed from the first non-null instance of ORC-23.4.&lt;br&gt;
HL7:  ORC-23.4 : OrderingFacilityPhoneNumber.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPEmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. For Orders than can have&lt;br&gt;
Results (LabOrder, RadOrder, OtherOrder), if the Order actually has a&lt;br&gt;
Result and FromTime, EnteredOn, and Result.ResultTime are all null, an&lt;br&gt;
error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  ORC-9.1 : DateTimeofTransaction.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUpdateDate) + User.HS.OEOrdItem(OEORIUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
FromTime is parsed from (in order of precedence) TQ1-7.1, RXE-1.4,&lt;br&gt;
OBR-27.4, OBR-6.1, or ORC-7.4. Though ORC-7 is a repeating field, HL7ToSDA3&lt;br&gt;
only parses the first non-null instance. OBR-27 is also a repeating field,&lt;br&gt;
and HL7ToSDA3 parses every non-null instance of it. The last non-null&lt;br&gt;
instance of StartDateTime.Time in OBR-27 is the one that takes precedence.&lt;br&gt;
Note that an RDE_O11 message may contain TQ1 segments in two different&lt;br&gt;
places. HL7ToSDA3 parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. Then, if the Order has a&lt;br&gt;
Result and FromTime is still null, it is defaulted to Result.ResultTime.&lt;br&gt;
Finally, if the Order has a Result and FromTime is still null, an error&lt;br&gt;
will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a FromTime, then that FromTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  OBR-6.1 : RequestedDateTime.Time&lt;br&gt;
HL7:  OBR-27.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  RXE-1.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  TQ1-7.1 : StartDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORISttDat) + User.HS.OEOrdItem(OEORISttTim)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ToTime is parsed from (in order of precedence) TQ1-8, RXE-1.5, OBR-27.5,&lt;br&gt;
or ORC-7.5. Though ORC-7 is a repeating field, HL7ToSDA3 only parses the&lt;br&gt;
first non-null instance. OBR-27 is also a repeating field, and HL7ToSDA3&lt;br&gt;
parses every non-null instance of it. The last non-null instance of&lt;br&gt;
EndDateTime.Time in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a ToTime, then that ToTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  OBR-27.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  RXE-1.5.1 : QuantityTiming.EndDateTimeTime&lt;br&gt;
HL7:  TQ1-8.1   : EndDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEndDate) + User.HS.OEOrdItem(OEORIEndTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Result" type="Result">
            <s:annotation>
                <s:documentation>VIEWERLIB: see HS.SDA3.Result&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Specimens" type="ArrayOfSpecimen">
            <s:annotation>
                <s:documentation>HL7:  SPM&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ClinicalInformation" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-13 : ReleventClinicalInformation&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservation" type="LabTestItem">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is a copy of the parent observation (as a LabTestItem). For&lt;br&gt;
example, the parent observation could be a bacterial culture identified in&lt;br&gt;
a specimen taken from the patient, and this order would contain the&lt;br&gt;
antibiotic susceptibilities of that culture.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentResultObservation itself is not&lt;br&gt;
stored in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-26.1 : ParentResult.ParentObservationIdentifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-26.1.1 : ParentResult.ParentObservationIdentifier.Text&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-26.1.2 : ParentResult.ParentObservationIdentifier.Identifier&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-26.1.3 : ParentResult.ParentObservationIdentifier.NameofCodingSystem&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, and 6 will be parsed&lt;br&gt;
into the Code, Description, and CodeSystem, respectively, of a PriorCode in&lt;br&gt;
the list of PriorCodes.&lt;br&gt;
HL7:  OBR-26.1.4 : ParentResult.ParentObservationIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-26.1.5 : ParentResult.ParentObservationIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-26.1.6 : ParentResult.ParentObservationIdentifier.NameofAlternateCodingSystem&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservationSubId">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is the SubId of the parent observation.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentResultObservationSubId itself is not&lt;br&gt;
stored in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-26.2 : ParentResult.ParentObservationSubidentifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="30"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservationText" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-26.3 : ParentResultObservationText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentPlacerId" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-29.1.1 : Parent.PlacerAssignedIdentifier.EntityIdentifier&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentPlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the Parent ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-29.1 will be used if a value can be parsed from it.&lt;br&gt;
ParentPlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.1.2 : Parent.PlacerAssignedIdentifier.NamespaceID&lt;br&gt;
HL7:  OBR-29.1.3 : Parent.PlacerAssignedIdentifier.UniversalID&lt;br&gt;
HL7:  OBR-29.1.4 : Parent.PlacerAssignedIdentifier.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ParentFillerId" type="s:string">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is the FillerId of the parent observation.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentFillerId itself is not stored in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.2.1 : Parent.FillerAssignedIdentifier.EntityIdentifier&lt;br&gt;
Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentFillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the Parent ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-29.2 will be used if a value can be parsed from it.&lt;br&gt;
ParentFillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.2.2 : Parent.FillerAssignedIdentifier.NamespaceID&lt;br&gt;
HL7:  OBR-29.2.3 : Parent.FillerAssignedIdentifier.UniversalID&lt;br&gt;
HL7:  OBR-29.2.4 : Parent.FillerAssignedIdentifier.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ReasonForStudy" type="ReasonforStudy">
            <s:annotation>
                <s:documentation>HL7:  OBR-31 : ReasonforStudy&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-31.1 : ReasonforStudy.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-31.2 : ReasonforStudy.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-31.3 : ReasonforStudy.NameofCodingSystem&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-31.7 : ReasonforStudy.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  OBR-31.4 : ReasonforStudy.AlternateIdentifier&lt;br&gt;
HL7:  OBR-31.5 : ReasonforStudy.AlternateText&lt;br&gt;
HL7:  OBR-31.6 : ReasonforStudy.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-31.8 : ReasonforStudy.AlternateCodingSystemVersionID&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="RadOrderExtension"/>
    </s:sequence>
</s:complexType>
<s:complexType name="RadOrderExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfOtherOrder">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="OtherOrder" nillable="true" type="OtherOrder"/>
    </s:sequence>
</s:complexType>
<s:complexType name="OtherOrder">
    <s:annotation>
        <s:documentation>For miscellaneous orders other than Lab, Rad, Med, and VXU</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="PlacerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the PlacerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId. If the PlacerId, FillerId, ExternalId, and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the LabOrder&lt;br&gt;
will not be processed. If the LabOrder has no OrderItem and does not match&lt;br&gt;
exactly 1 other LabOrder in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId, which itself may have been&lt;br&gt;
defaulted to the Result ExternalId. If PlacerId, FillerId, ExternalId and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the Order will&lt;br&gt;
not be processed. If the Order has no OrderItem and does not match exactly&lt;br&gt;
1 other Order of the same type in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the Order will not be processed.&lt;br&gt;
-MED,VXU:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId. If the Order has no OrderItem&lt;br&gt;
or DrugProduct and does not match exactly 1 other Order of the same type in&lt;br&gt;
the same Encounter on PlacerId (ALPHAUP collated), an error will be logged&lt;br&gt;
and the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPlacerNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-2 will be used if a value can be parsed from it, else ORC-2 will be&lt;br&gt;
used. In either case, PlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the FillerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId, then to PlacerId, which itself&lt;br&gt;
may have been defaulted to ExternalId. If FillerId, PlacerId, ExternalId,&lt;br&gt;
and Result.ExternalId are all null, an error will be logged and the&lt;br&gt;
LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId. If FillerId, PlacerId,&lt;br&gt;
ExternalId, and Result.ExternalId are all null, an error will be logged and&lt;br&gt;
the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId. Also for LabOrders only, the stored&lt;br&gt;
value for FillerId in the Viewer Cache is required to be unique. If an&lt;br&gt;
inbound LabOrder.FillerId matches one already in the Viewer Cache (if the&lt;br&gt;
same patient record has been loaded multiple times, for example), the&lt;br&gt;
inbound value is made unique by appending "x[OEORDId]" to it, where&lt;br&gt;
"[OEORDId]" is the ID of the parent OEOrder to the OEOrdItem that the&lt;br&gt;
LabOrder is stored as.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIFillerNo)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabEpisodeNo)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3 will be used if a value can be parsed from it, else ORC-3 will be&lt;br&gt;
used. In either case, FillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OrderItem" type="Order">
            <s:annotation>
                <s:documentation>What was ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-4 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Medications and Vaccinations, in the OnBeforeMatch method of the&lt;br&gt;
Streamlet class, if the Order has no OrderItem but does have a DrugProduct,&lt;br&gt;
then an OrderItem will be defaulted in with Code, Description, and&lt;br&gt;
SDACodingStandard copied from the DrugProduct. For all types of Orders (and&lt;br&gt;
for Medications and Vaccinations, following this defaulting), if the Order&lt;br&gt;
has no OrderItem and does not match exactly 1 other Order of the same type&lt;br&gt;
in the same Encounter on PlacerId (ALPHAUP collated), an error will be&lt;br&gt;
logged and the Order will not be processed. In the OnValidate method, if&lt;br&gt;
the Order does not have an OrderItem (if it was deleted in an update, for&lt;br&gt;
example), an error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7: OBR-4 : UniversalServiceIdentifier&lt;br&gt;
SDATableName=Order, ViewerClass=User.HS.ARCItmMast&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItmMastDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
Viewer cache:&lt;br&gt;
TRName is for text results only.&lt;br&gt;
HL7:  OBR-4.1 : UniversalServiceIdentifier.Identifier&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMCode)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRName)&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-4.2 : UniversalServiceIdentifier.Text&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-4.3 : UniversalServiceIdentifier.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-4.7 : UniversalServiceIdentifier.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to subfield 1 or 2 not being null, if subfield 4 or 5 is not&lt;br&gt;
null, then subfields 4, 5, 6, and 8 will be parsed into the Code,&lt;br&gt;
Description, CodeSystem, and CodeSystemVersionId, respectively, of a&lt;br&gt;
PriorCode in the list of PriorCodes. In this case, the PriorCode Type is&lt;br&gt;
set to "A".&lt;br&gt;
HL7:  OBR-4.4 : UniversalServiceIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-4.5 : UniversalServiceIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-4.6 : UniversalServiceIdentifier.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-4.8 : UniversalServiceIdentifier.AlternateCodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  OBR-4.9 : UniversalServiceIdentifier.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderCategory" type="OrderCategory">
            <s:annotation>
                <s:documentation>Can be used to group orders in the Clinical Viewer.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-24 is parsed to the OrderCategory Code. HL7ToSDA3 does not set the&lt;br&gt;
Description. The parsed value is converted to uppercase in the SDA.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For all Order types, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order has an OrderCategory, then the InfoSubType of the streamlet is&lt;br&gt;
set to the OrderCategory Code, converted to uppercase.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The OrderCategory is stored as a property of the ARCItmMast (OrderItem),&lt;br&gt;
which is itself a property of the OEOrderItem (Order).&lt;br&gt;&lt;br&gt;
HL7:  OBR-24 : DiagnosticServSectID&lt;br&gt;
SDATableName=OrderCategory, ViewerClass=User.HS.ARCItemCat&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMItemCatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderQuantity" type="s:string">
            <s:annotation>
                <s:documentation>Number of items ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderQuantity is parsed from (in order of precendence) TQ1-2.1, RXE-1.1.1,&lt;br&gt;
OBR-27.1.1, or ORC-7.1.1. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Quantity in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  OBR-27.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  RXE-1.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  TQ1-2.1   : Quantity.Quantity&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>Who placed the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderedBy is parsed from (in order of precendence) OBR-16, RXO-14, RXE-13,&lt;br&gt;
or ORC-12 and -24. Though each of these fields is repeating, for each one&lt;br&gt;
except ORC-24, HL7ToSDA3 will only parse the first non-null instance. For&lt;br&gt;
ORC-24, the instance corresponding to the first non-null instance of ORC-12&lt;br&gt;
will be parsed. ORC-12 and -24 are used in combination to set the&lt;br&gt;
provider's Name and Address in the SDA. Every other field only sets the&lt;br&gt;
Name. For Adress.City, .State, .Zip, .Country, and .County as well as NameTypeCode&lt;br&gt;
and IdentifierTypeCode, only the Code is parsed. HL7ToSDA3 does not set the&lt;br&gt;
Description. Note that an RDE_O11 message technically can contain both an&lt;br&gt;
RXO segment and an RXE, however HL7ToSDA3 does not parse the RXO segment&lt;br&gt;
from an RDE message.&lt;br&gt;&lt;br&gt;
HL7:  ORC-12 : OrderingProvider&lt;br&gt;
HL7:  ORC-24 : OrderingProviderAddress&lt;br&gt;
HL7:  RXE-13 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  RXO-14 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  OBR-16 : OrderingProvider&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDoctorDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-12.1 : OrderingProvider.IDNumber&lt;br&gt;
HL7:  RXE-13.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  RXO-14.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  OBR-16.1 : OrderingProvider.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-12.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
HL7:  RXE-13.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  RXO-14.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  OBR-16.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-12.4 : OrderingProvider.MiddleName&lt;br&gt;
HL7:  RXE-13.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  RXO-14.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  OBR-16.4 : OrderingProvider.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-12.6 : OrderingProvider.NamePrefix&lt;br&gt;
HL7:  RXE-13.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  RXO-14.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  OBR-16.6 : OrderingProvider.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-24.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-24.1.1.&lt;br&gt;
HL7:  ORC-24.1.1 : OrderingProviderAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-24.2 : OrderingProviderAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPStName)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-24.3 : OrderingProviderAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCityDR)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-24.4 : OrderingProviderAddress.StateorProvince&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-24.5 : OrderingProviderAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-24.6 : OrderingProviderAddress.Country&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-24.9 : OrderingProviderAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.NameTypeCode&lt;br&gt;
HL7:  OBR-16.10 : OrderingProvider.NameTypeCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.IdentifierTypeCode&lt;br&gt;
HL7:  OBR-16.13 : OrderingProvider.IdentifierTypeCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteringOrganization" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Entering Facility (Location)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-13 is only parsed if subfield 1 is not null. Only the Code is parsed.&lt;br&gt;
HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
HL7:  ORC-13.1 : EnterersLocation.PointofCare&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIOrdDeptDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Only the Code is parsed. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>VerifiedBy (CareProvider)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-32 will be used if present, else the first non-null instance of ORC-11&lt;br&gt;
will be used, if there is one.&lt;br&gt;&lt;br&gt;
HL7:  ORC-11 : VerifiedBy&lt;br&gt; 
HL7:  OBR-32 : PrincipalResultInterpreter&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthoriseClinicianDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-11.1 : VerifiedBy.IDNumber&lt;br&gt;
HL7:  OBR-32.1.1 : PrincipalResultInterpreter.Name.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields, the given and family names are concatenated together as&lt;br&gt;
"[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-11.9 : VerifiedBy.AssigningAuthority&lt;br&gt;
HL7:  OBR-32.1.9 : PrincipalResultInterpreter.Name.AssigningAuthorityNamespaceID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-11.4 : VerifiedBy.SecondandFurtherGivenNames&lt;br&gt;
HL7:  OBR-32.1.4 : PrincipalResultInterpreter.Name.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-11.6 : VerifiedBy.Prefix&lt;br&gt;
HL7:  OBR-32.1.6 : PrincipalResultInterpreter.Name.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  ORC-11.7 : VerifiedBy.Degree&lt;br&gt;
HL7:  OBR-32.1.5 : PrincipalResultInterpreter.Name.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  OBR-32.1.7 : PrincipalResultInterpreter.Name.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CallbackNumber">
            <s:annotation>
                <s:documentation>Callback number (who to contact with questions, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-17 is used if any regular (business), mobile, or fax numbers or e-mail&lt;br&gt;
addresses can be parsed from it, else ORC-14 is used. In either case, the&lt;br&gt;
format of CallbackNumber is: "[List of business #s], Mobile: [List of&lt;br&gt;
mobile #s], Fax: [List of fax #s], email: [List of e-mail addresses]". Each&lt;br&gt;
list is comma-delimited. Each tag (Mobile, Fax, email) will only be used if&lt;br&gt;
there are elements of that type. For each field, every instance will be&lt;br&gt;
parsed, if that field is used. Up to three numbers can be parsed from each&lt;br&gt;
instance of a field:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, a number is parsed from them&lt;br&gt;
as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-If subfield 12 is not null, it is parsed.&lt;br&gt;
-If subfield 1 is not null, it is parsed.&lt;br&gt;
-Additionally, if subfield 9 is not null, the first number parsed from that&lt;br&gt;
instance will have it appended to the end after a semicolon separator.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;
The logic to determine the type of the number is:&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 is in ["",PH], the&lt;br&gt;
number is a regular (business) number.&lt;br&gt;
-If subfield 2 = "BPN" and subfield 3 is in [CP,BP], the number is a mobile&lt;br&gt;
number.&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 = "FX", the number is&lt;br&gt;
a fax number.&lt;br&gt;
Finally, each non-null instance of subfield 4 is parsed as an e-mail&lt;br&gt;
address.&lt;br&gt;&lt;br&gt;
HL7:  OBR-17 : OrderCallbackPhoneNumber&lt;br&gt;
HL7:  ORC-14 : CallBackPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINotify)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Specimen">
            <s:annotation>
                <s:documentation>Specimen code or description as a string&lt;br&gt;
Not to be confused with the Specimens property of LabOrder, RadOrder, and&lt;br&gt;
OtherOrder, which is of type List of HS.SDA3.Specimen.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-15.1.2 will be used if not null, else OBR-15.1.1 will be used.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Specimen is inserted into the Viewer Cache as a CTSpecimen with SPECCode&lt;br&gt;
and SPECDesc=[Specimen]. The CTSpecimen is the linked to the ARCItmMast&lt;br&gt;
(OrderItem) via an ARCItemSpecimen. Specimen is also inserted as an&lt;br&gt;
OEOrdSpecimen (with SPECCode=[Specimen]) that is linked to the OEOrdItem&lt;br&gt;
(Order). Note that backslash ("\") is a reserved character for the&lt;br&gt;
CTSpecimen table, so Specimen should not contain a backslash.&lt;br&gt;&lt;br&gt;
HL7: OBR-15 : SpecimenSource&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.CTSpecimen&lt;br&gt;
VIEWERLIB: User.HS.OEOrdSpecimen(SPECCode)&lt;br&gt;
VIEWERLIB: User.HS.CTSpecimen(SPECCode) + User.HS.CTSpecimen(SPECDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="SpecimenCollectedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the specimen was collected&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-7.1 and SPM-17.1 represent the same value and therefore should contain&lt;br&gt;
the same value if both are present, however HealthShare does not enforce&lt;br&gt;
this. SPM-17.1 is parsed to Specimen.FromTime.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIEpisArriveDate and OEORIEpisArriveTime are only set for Lab, Rad, and&lt;br&gt;
Other Orders, not Medications or Vaccinations. SPECDate and SPECTime are&lt;br&gt;
only set if the Order contains a Specimen (the string property, not an&lt;br&gt;
HS.SDA3.Specimen). The properties of lab.HS.EPVisitNumber and&lt;br&gt;
EPVisitTestSet are set for atomic results only. Note that while&lt;br&gt;
VISTSTimeOfCollection is a %Time, EPVISTimeOfCollection is not. It is a&lt;br&gt;
%String value containing the time as a number of minutes since midnight.&lt;br&gt;&lt;br&gt;
HL7:  OBR-7.1 : ObservationDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEpisArriveDate) + User.HS.OEOrdItem(OEORIEpisArriveTime)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdSpecimen(SPECDate) + User.HS.OEOrdSpecimen(SPECTime)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitNumber(EPVISDateOfCollection) + lab.HS.EPVisitNumber(EPVISTimeOfCollection)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSet(VISTSDateOfCollection) + lab.HS.EPVisitTestSet(VISTSDateOfCollection)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenReceivedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the specimen was received&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORILabReceiveDate and OEORILabReceiveTime are only set for Lab, Rad, and&lt;br&gt;
Other Orders, not Medications or Vaccinations. The properties of&lt;br&gt;
lab.HS.EPVisitNumber are set for atomic results only. Note that&lt;br&gt;
EPVISTimeOfReceiving is not a %Time but rather a %String value containing&lt;br&gt;
the time as a number of minutes since midnight.&lt;br&gt;&lt;br&gt;
HL7: OBR-14.1 : SpecimenReceivedDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabReceiveDate) + User.HS.OEOrdItem(OEORILabReceiveTime)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitNumber(EPVISDateOfReceiving) + lab.HS.EPVisitNumber(EPVISTimeOfReceiving)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReassessmentTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>If the Order is not final, this is the date/time when it should be reviewed&lt;br&gt;
and perhaps finalized.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIReassessmentDate) + User.HS.OEOrdItem(OEORIReassessmentTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Frequency" type="Frequency">
            <s:annotation>
                <s:documentation>How often (e.g. Code=QID, Desc=QID, Factor=4)&lt;br&gt;
QID is Latin, meaning 4x a day.  BID means 2x day, etc.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though TQ1-3 is a repeating field, HL7ToSDA3 will only parse the first&lt;br&gt;
non-null instance.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Frequency, then that&lt;br&gt;
Frequency will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-3 : RepeatPattern&lt;br&gt;
SDATableName=Frequency, ViewerClass=User.HS.PHCFreq&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPHFreqDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  TQ1-3.1.1 : RepeatPattern.RepeatPatternCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-3.1.2 : RepeatPattern.RepeatPatternCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7:  TQ1-3.5 : RepeatPattern.PeriodQuantity&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRFactor)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Duration" type="Duration">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Duration is parsed from (in order of precedence) TQ1-6, RXE-1.3, OBR-27.3,&lt;br&gt;
or ORC-7.3. The RXE, OBR, and ORC fields will only set the Duration Code.&lt;br&gt;
TQ1-6 will populate the Code, Description, and Factor as described below.&lt;br&gt;
Though ORC-7 is a repeating field, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance. OBR-27 is also a repeating field, and HL7ToSDA3 parses every&lt;br&gt;
non-null instance of it. The last non-null instance of Duration in OBR-27&lt;br&gt;
is the one that takes precedence. Note that an RDE_O11 message may contain&lt;br&gt;
TQ1 segments in two different places. HL7ToSDA3 parses the one following&lt;br&gt;
the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Duration, then that Duration&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  TQ1-6 : ServiceDuration&lt;br&gt;
SDATableName=Duration, ViewerClass=User.HS.PHCDuration&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDuratDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
When parsing the TQ1-6 field, Code is initially parsed from subfield 2.1&lt;br&gt;
(Units.Identifier). If subfield 1 (Quantity) is not null, then if subfields&lt;br&gt;
2.1 and 2.2 (Units.Text) are null, Code will be parsed from Quantity. Then,&lt;br&gt;
if Quantity starts with a non-zero number and the parsed value for Code&lt;br&gt;
does not, the parsed value for Code is set to +[Quantity]_[Code]. For&lt;br&gt;
example, if Quantity="2" and Units.Identifier="D", the value parsed to Code&lt;br&gt;
is "2D". For the other segments that Duration Code may be parsed from (RXE,&lt;br&gt;
OBR, ORC), the value is simply parsed from the field listed below.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null and +[Quantity] is logically "true",&lt;br&gt;
and if TQ1-6.2.2 (Units.Text) is not null and +[Units.Text] is logically&lt;br&gt;
"false" (basically, if Quantity starts with a number and Units.Text&lt;br&gt;
doesn't), then the value parsed to Description is&lt;br&gt;
+[Quantity]_" "_[Units.Text]. For example, if Quantity="2" and&lt;br&gt;
Units.Text="Days", the value parsed to Description is "2 Days". If these&lt;br&gt;
conditions are not all met then the Description is simply parsed from&lt;br&gt;
TQ1-6.2.2.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null, then if +[Quantity] is logically "true",&lt;br&gt;
Factor is parsed as +[Quantity], otherwise Factor is parsed as null. If&lt;br&gt;
Quantity is null, then if +[TQ1-2.1/Units.Identifier] is logically "true",&lt;br&gt;
Factor is parsed as +[Units.Identifier], else if +[TQ1-2.2/Units.Text] is&lt;br&gt;
logically "true", Factor is parsed as +[Units.Text], else Factor is not&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUFactor)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status">
            <s:annotation>
                <s:documentation>The current status of the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The following values are mapped in the HL7 to SDA3 parsing:&lt;br&gt;
DC-&gt;D, CA-&gt;C, RP-&gt;R, HD-&gt;H, SC-&gt;IP, CM-&gt;E, [Other]-&gt;unchanged&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For any type of Order, in the OnValidate method of the streamlet class, if&lt;br&gt;
Status is null, it is defaulted to "V" for "Verified". Then, for Orders&lt;br&gt;
that can have results (LabOrder, RadOrder, OtherOrder), if the Order has a&lt;br&gt;
Result, Status is set to "E" for "Executed", unless it is "D", "C", "R", or&lt;br&gt;
"H" (for Discontinued, Cancelled, Replaced, or On Hold, respectively). The&lt;br&gt;
reasoning behind setting the Status to "E" is that if the Order has a&lt;br&gt;
Result, then it must have been executed. The reasoning behind the&lt;br&gt;
exceptions to this is that those particular statuses may have been entered&lt;br&gt;
after the Result was submitted. Also, for any type of Order, when Orders of&lt;br&gt;
of that type are inactivated with ActionCode="I", the Status of each will&lt;br&gt;
be set to "I".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Status is stored in the Viewer Cache as an OECOrderStatus with OSTATCode&lt;br&gt;
matching Status, ALPHAUP collated. If no such entry in OECOrderStatus&lt;br&gt;
exists, Status will be stored as V/Verified in the Viewer Cache only and an&lt;br&gt;
alert logged in the Ensemble Event Log. Note that the OECOrderStatus table&lt;br&gt;
is loaded from the SITE- or HS-Default-OrderStatus.txt file at the time the&lt;br&gt;
Access Gateway is reset.&lt;br&gt;&lt;br&gt;
HL7:  ORC-5 : OrderStatus&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.OECOrderStatus&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemStatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Priority" type="Priority">
            <s:annotation>
                <s:documentation>The Priority of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Priority is parsed from (in order of precendence) TQ1-9, RXE-1.6, OBR-27.6,&lt;br&gt;
OBR-5, or ORC-7.6. TQ1-9 may set the Code, Description, and&lt;br&gt;
SDACodingStandard. Every other field only sets the Code. Though TQ1-9 and&lt;br&gt;
ORC-7 are repeating fields, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance of each. OBR-27 is also a repeating field, and HL7ToSDA3 parses&lt;br&gt;
every non-null instance of it. The last non-null instance of Priority in&lt;br&gt;
OBR-27 is the one that takes precedence. Note that an RDE_O11 message may&lt;br&gt;
contain TQ1 segments in two different places. HL7ToSDA3 parses the one&lt;br&gt;
following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order contains no Priority, one is defaulted in with Code="N" and &lt;br&gt;
Description="Normal".&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9   : Priority&lt;br&gt;
SDATableName=Priority, ViewerClass=User.HS.OECPriority&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPriorityDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9.1  : Priority.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-9.2  : Priority.Text&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  TQ1-9.3  : Priority.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConfidentialityCode" type="Confidentiality">
            <s:annotation>
                <s:documentation>Confidentiality code (e.g. VIP, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-28 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-28 : ConfidentialtyCode&lt;br&gt;
SDATableName=Confidentiality, ViewerClass=User.HS.OECOverReasonNonConsent&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINoConsentOverrideReasDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-28.1 : ConfidentialtyCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-28.2 : ConfidentialtyCode.Text&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-28.3 : ConfidentialtyCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Condition">
            <s:annotation>
                <s:documentation>Condition, e.g. "keep BP below 110"&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Condition is parsed from (in order of precendence) TQ1-10, RXE-1.7,&lt;br&gt;
OBR-27.7, or ORC-7.7. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Condition in OBR-27 is the one that takes precendence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  OBR-27.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  RXE-1.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  TQ1-10  : ConditionText&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILtClinicalCondition)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="TextInstruction" type="s:string">
            <s:annotation>
                <s:documentation>Text instructions or directions, e.g. "After food", or if Duration etc.&lt;Br&gt;
isn't coded, "Take 3 twice a day"&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
TextInstruction is parsed from (in order of precendence) TQ1-11, RXE-1.8,&lt;br&gt;
OBR-27.8, or ORC-7.8. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Text in OBR-27 is the one that takes precendence. Note that an RDE_O11&lt;br&gt;
message may contain TQ1 segments in two different places. HL7ToSDA3 parses&lt;br&gt;
the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a TextInstruction, then that&lt;br&gt;
TextInstruction will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.8 : QuantityTiming.Text&lt;br&gt;
HL7:  OBR-27.8 : QuantityTiming.Text&lt;br&gt;
HL7:  RXE-1.8 : QuantityTimingText&lt;br&gt;
HL7:  TQ1-11  : TextInstruction&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDepProcNotes)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderGroup" type="s:string">
            <s:annotation>
                <s:documentation>This is a way to group related Orders together, such as a prescription&lt;br&gt;
chain.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemGroup)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Order Comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Order Comments are always parsed from NTE segments, though HL7 order&lt;br&gt;
messages may contain NTEs in different places, and only certain ones are&lt;br&gt;
parsed to Order Comments. For ORM and OMP messages, it is the first set of&lt;br&gt;
NTEs following the ORC (in the message schema, not necessarily in the&lt;br&gt;
message) that are parsed to Comments.  In an RDE message the set of NTEs&lt;br&gt;
following the RXE segment are parsed to Order Comments. Order Comments can&lt;br&gt;
only be parsed from an ORU message if it contains a text result (either&lt;br&gt;
ORC-29 is not "LAB", or all OBX-2 values = "FT", "TX", or "ED"). In this&lt;br&gt;
case the NTEs immediately following the OBR are parsed to Order Comments.&lt;br&gt;
In an ORU containing atomic lab results, the NTEs following the OBR are&lt;br&gt;
parsed to the Result Comments, and in an ORU containing Observations&lt;br&gt;
(ORC-29="OBS"), these NTEs are not parsed.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRemarks)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConsultationDepartment" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Department or facility that consulted&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIConsultDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AuthorizationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the order was authorized&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthorisedDate) + User.HS.OEOrdItem(OEORIAuthorisedTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReceivingLocation" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Location or facility receiving/performing the order&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRecDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedComments" type="s:string">
            <s:annotation>
                <s:documentation>Verified order comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthComments)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultCopiesTo" type="ArrayOfCareProvider">
            <s:annotation>
                <s:documentation>Who to send copies of results to&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-28 is a repeating field, and HL7ToSDA3 will parse each instance with a&lt;br&gt;
non-null value in subfield 1.&lt;br&gt;&lt;br&gt;
HL7:  OBR-28  : ResultCopiesTo&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-28.1 : ResultCopiesTo.Code&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  OBR-28.2.1 : ResultCopiesTo.FamilyName.Surname&lt;br&gt;
HL7:  OBR-28.3 : ResultCopiesTo.GivenName&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-28.9 : ResultCopiesTo.AssigningAuthority&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  OBR-28.2.1 : ResultCopiesTo.FamilyName.Surname&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  OBR-28.3 : ResultCopiesTo.GivenName&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  OBR-28.6 : ResultCopiesTo.Prefix&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  OBR-28.7 : ResultCopiesTo.Degree&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupId" type="s:string">
            <s:annotation>
                <s:documentation>If this item was ordered as part of a group, this is the identifier of that&lt;br&gt;
group. The SDA2-to-SDA3 transform populates this field with the SDA2&lt;br&gt;
ExternalId property.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.1 : PlacerGroupNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILab1)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupAssigningAuthority" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
GroupAssigningAuthority is composed of subfields 2, 3, and 4 concatenated&lt;br&gt;
together as "[.2]^[.3]^[.4]", but only if at least one of these is not&lt;br&gt;
null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.2: PlacerGroupNumber.NamespaceID&lt;br&gt;
HL7:  ORC-4.3: PlacerGroupNumber.UniversalID&lt;br&gt;
HL7:  ORC-4.4: PlacerGroupNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate all orders of this type (set Status="I")&lt;br&gt;
C = Clear/delete all orders of this type&lt;br&gt;
R = Replace - Applies only to Atomic Result Items.  Clears previous result items before storing all new items,
ignoring matching on test item code.  &lt;b&gt;Use ONLY when always receiving full updates.  Using this with
partial updates may cause a loss of test item data.&lt;/b&gt;&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation of the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in ORC-1 will be parsed as ActionCode="I", while&lt;br&gt;
four double quotes ("""") will be parsed as ActionCode="C". &lt;br&gt;
ActionCode="R" in ORC-1 will impact parsing of TestItemCode.  See the
TestItemCode property of HS.SDA3.LabResultItem for details.&lt;br&gt;
Any other value will not be parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-1 : OrderControl&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Only used for Medications, see the annotation in HS.SDA3.Medication.&lt;br&gt;
Otherwise ActionScope is not used for Orders.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-10 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-10 : EnteredBy&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserUpdate)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-10.1 : EnteredBy.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-10.2.1 : EnteredBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-10.3 : EnteredBy.GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-10.9 : EnteredBy.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-21 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed. ORC-22 is also a repeating field, however HL7ToSDA3 will only parse&lt;br&gt;
the instance corresponding to the instance of ORC-21 parsed. For example,&lt;br&gt;
if the third instance of ORC-21 is parsed (because the first two are null),&lt;br&gt;
then the third instance of ORC-22 will be parsed as well. For Address.City,&lt;br&gt;
State, Zip, Country, and County only the Code is parsed. HL7ToSDA3 does not&lt;br&gt;
set the Description. Every instance of ORC-23 will be examined but may not&lt;br&gt;
be parsed to the SDA. The algorithm to parse a number out of one instance&lt;br&gt;
of ORC-23 is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else no number can be parsed from this instance.&lt;br&gt;
-Whichever number is parsed, if subfield 9 of that instance is not null, it&lt;br&gt;
will be appended to the number, delimited by a semicolon.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;&lt;br&gt;
HL7:  ORC-21 : OrderingFacilityName&lt;br&gt;
HL7:  ORC-22 : OrderingFacilityAddress&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserAddHospDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-21.10 will be parsed to the Code if present, else ORC-21.3 will.&lt;br&gt;
HL7:  ORC-21.10 : OrderingFacilityName.OrganizationIdentifier&lt;br&gt;
HL7:  ORC-21.3 : OrderingFacilityName.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-21.1 : OrderingFacilityName.OrganizationName&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-21.6 : OrderingFacilityName.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-22.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-22.1.1.&lt;br&gt;
HL7:  ORC-22.1.1 : OrderingFacilityAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-22.2 : OrderingFacilityAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPAddress)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-22.3 : OrderingFacilityAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCity)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-22.4 : OrderingFacilityAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPProvinceDR)&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-22.5 : OrderingFacilityAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-22.6 : OrderingFacilityAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountryDR)&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-22.9 : OrderingFacilityAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountyParishDR)&lt;br&gt;
.ContactInfo.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
WorkPhoneNumber is parsed from the first instance of ORC-23 with subfield 2&lt;br&gt;
in ["",WPN,ASN,EMR] and subfield 3 in ["",PH] and from which a phone number&lt;br&gt;
can be parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPPhone)&lt;br&gt;
.ContactInfo.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MobilePhoneNumber is parsed from the first instance of ORC-23 with subfield&lt;br&gt;
2 = "BPN" and subfield 3 in [CP,BP] and from which a phone number can be&lt;br&gt;
parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ContactInfo.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
EmailAddress is parsed from the first non-null instance of ORC-23.4.&lt;br&gt;
HL7:  ORC-23.4 : OrderingFacilityPhoneNumber.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPEmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. For Orders than can have&lt;br&gt;
Results (LabOrder, RadOrder, OtherOrder), if the Order actually has a&lt;br&gt;
Result and FromTime, EnteredOn, and Result.ResultTime are all null, an&lt;br&gt;
error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  ORC-9.1 : DateTimeofTransaction.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUpdateDate) + User.HS.OEOrdItem(OEORIUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
FromTime is parsed from (in order of precedence) TQ1-7.1, RXE-1.4,&lt;br&gt;
OBR-27.4, OBR-6.1, or ORC-7.4. Though ORC-7 is a repeating field, HL7ToSDA3&lt;br&gt;
only parses the first non-null instance. OBR-27 is also a repeating field,&lt;br&gt;
and HL7ToSDA3 parses every non-null instance of it. The last non-null&lt;br&gt;
instance of StartDateTime.Time in OBR-27 is the one that takes precedence.&lt;br&gt;
Note that an RDE_O11 message may contain TQ1 segments in two different&lt;br&gt;
places. HL7ToSDA3 parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. Then, if the Order has a&lt;br&gt;
Result and FromTime is still null, it is defaulted to Result.ResultTime.&lt;br&gt;
Finally, if the Order has a Result and FromTime is still null, an error&lt;br&gt;
will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a FromTime, then that FromTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  OBR-6.1 : RequestedDateTime.Time&lt;br&gt;
HL7:  OBR-27.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  RXE-1.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  TQ1-7.1 : StartDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORISttDat) + User.HS.OEOrdItem(OEORISttTim)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ToTime is parsed from (in order of precedence) TQ1-8, RXE-1.5, OBR-27.5,&lt;br&gt;
or ORC-7.5. Though ORC-7 is a repeating field, HL7ToSDA3 only parses the&lt;br&gt;
first non-null instance. OBR-27 is also a repeating field, and HL7ToSDA3&lt;br&gt;
parses every non-null instance of it. The last non-null instance of&lt;br&gt;
EndDateTime.Time in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a ToTime, then that ToTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  OBR-27.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  RXE-1.5.1 : QuantityTiming.EndDateTimeTime&lt;br&gt;
HL7:  TQ1-8.1   : EndDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEndDate) + User.HS.OEOrdItem(OEORIEndTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Result" type="Result">
            <s:annotation>
                <s:documentation>VIEWERLIB: see HS.SDA3.Result&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Specimens" type="ArrayOfSpecimen">
            <s:annotation>
                <s:documentation>HL7:  SPM&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ClinicalInformation" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-13 : ReleventClinicalInformation&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservation" type="LabTestItem">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is a copy of the parent observation (as a LabTestItem). For&lt;br&gt;
example, the parent observation could be a bacterial culture identified in&lt;br&gt;
a specimen taken from the patient, and this order would contain the&lt;br&gt;
antibiotic susceptibilities of that culture.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentResultObservation itself is not&lt;br&gt;
stored in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-26.1 : ParentResult.ParentObservationIdentifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-26.1.1 : ParentResult.ParentObservationIdentifier.Text&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-26.1.2 : ParentResult.ParentObservationIdentifier.Identifier&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-26.1.3 : ParentResult.ParentObservationIdentifier.NameofCodingSystem&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, and 6 will be parsed&lt;br&gt;
into the Code, Description, and CodeSystem, respectively, of a PriorCode in&lt;br&gt;
the list of PriorCodes.&lt;br&gt;
HL7:  OBR-26.1.4 : ParentResult.ParentObservationIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-26.1.5 : ParentResult.ParentObservationIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-26.1.6 : ParentResult.ParentObservationIdentifier.NameofAlternateCodingSystem&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservationSubId">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is the SubId of the parent observation.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentResultObservationSubId itself is not&lt;br&gt;
stored in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-26.2 : ParentResult.ParentObservationSubidentifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="30"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservationText" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-26.3 : ParentResultObservationText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentPlacerId" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-29.1.1 : Parent.PlacerAssignedIdentifier.EntityIdentifier&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentPlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the Parent ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-29.1 will be used if a value can be parsed from it.&lt;br&gt;
ParentPlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.1.2 : Parent.PlacerAssignedIdentifier.NamespaceID&lt;br&gt;
HL7:  OBR-29.1.3 : Parent.PlacerAssignedIdentifier.UniversalID&lt;br&gt;
HL7:  OBR-29.1.4 : Parent.PlacerAssignedIdentifier.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ParentFillerId" type="s:string">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is the FillerId of the parent observation.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentFillerId itself is not stored in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.2.1 : Parent.FillerAssignedIdentifier.EntityIdentifier&lt;br&gt;
Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentFillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the Parent ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-29.2 will be used if a value can be parsed from it.&lt;br&gt;
ParentFillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.2.2 : Parent.FillerAssignedIdentifier.NamespaceID&lt;br&gt;
HL7:  OBR-29.2.3 : Parent.FillerAssignedIdentifier.UniversalID&lt;br&gt;
HL7:  OBR-29.2.4 : Parent.FillerAssignedIdentifier.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ReasonForStudy" type="ReasonforStudy">
            <s:annotation>
                <s:documentation>HL7:  OBR-31 : ReasonforStudy&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-31.1 : ReasonforStudy.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-31.2 : ReasonforStudy.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-31.3 : ReasonforStudy.NameofCodingSystem&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-31.7 : ReasonforStudy.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  OBR-31.4 : ReasonforStudy.AlternateIdentifier&lt;br&gt;
HL7:  OBR-31.5 : ReasonforStudy.AlternateText&lt;br&gt;
HL7:  OBR-31.6 : ReasonforStudy.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-31.8 : ReasonforStudy.AlternateCodingSystemVersionID&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="OtherOrderExtension"/>
    </s:sequence>
</s:complexType>
<s:complexType name="OtherOrderExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfMedication">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Medication" nillable="true" type="Medication"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Medication">
    <s:annotation>
        <s:documentation>HS.SDA3.Medication corresponds to the CDA Medications section, the
Medications Administered section, and the Hospital Discharge Medications
section.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="PlacerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the PlacerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId. If the PlacerId, FillerId, ExternalId, and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the LabOrder&lt;br&gt;
will not be processed. If the LabOrder has no OrderItem and does not match&lt;br&gt;
exactly 1 other LabOrder in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId, which itself may have been&lt;br&gt;
defaulted to the Result ExternalId. If PlacerId, FillerId, ExternalId and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the Order will&lt;br&gt;
not be processed. If the Order has no OrderItem and does not match exactly&lt;br&gt;
1 other Order of the same type in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the Order will not be processed.&lt;br&gt;
-MED,VXU:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId. If the Order has no OrderItem&lt;br&gt;
or DrugProduct and does not match exactly 1 other Order of the same type in&lt;br&gt;
the same Encounter on PlacerId (ALPHAUP collated), an error will be logged&lt;br&gt;
and the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPlacerNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-2 will be used if a value can be parsed from it, else ORC-2 will be&lt;br&gt;
used. In either case, PlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the FillerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId, then to PlacerId, which itself&lt;br&gt;
may have been defaulted to ExternalId. If FillerId, PlacerId, ExternalId,&lt;br&gt;
and Result.ExternalId are all null, an error will be logged and the&lt;br&gt;
LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId. If FillerId, PlacerId,&lt;br&gt;
ExternalId, and Result.ExternalId are all null, an error will be logged and&lt;br&gt;
the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId. Also for LabOrders only, the stored&lt;br&gt;
value for FillerId in the Viewer Cache is required to be unique. If an&lt;br&gt;
inbound LabOrder.FillerId matches one already in the Viewer Cache (if the&lt;br&gt;
same patient record has been loaded multiple times, for example), the&lt;br&gt;
inbound value is made unique by appending "x[OEORDId]" to it, where&lt;br&gt;
"[OEORDId]" is the ID of the parent OEOrder to the OEOrdItem that the&lt;br&gt;
LabOrder is stored as.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIFillerNo)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabEpisodeNo)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3 will be used if a value can be parsed from it, else ORC-3 will be&lt;br&gt;
used. In either case, FillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OrderItem" type="Order">
            <s:annotation>
                <s:documentation>What was ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-4 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Medications and Vaccinations, in the OnBeforeMatch method of the&lt;br&gt;
Streamlet class, if the Order has no OrderItem but does have a DrugProduct,&lt;br&gt;
then an OrderItem will be defaulted in with Code, Description, and&lt;br&gt;
SDACodingStandard copied from the DrugProduct. For all types of Orders (and&lt;br&gt;
for Medications and Vaccinations, following this defaulting), if the Order&lt;br&gt;
has no OrderItem and does not match exactly 1 other Order of the same type&lt;br&gt;
in the same Encounter on PlacerId (ALPHAUP collated), an error will be&lt;br&gt;
logged and the Order will not be processed. In the OnValidate method, if&lt;br&gt;
the Order does not have an OrderItem (if it was deleted in an update, for&lt;br&gt;
example), an error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7: OBR-4 : UniversalServiceIdentifier&lt;br&gt;
SDATableName=Order, ViewerClass=User.HS.ARCItmMast&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItmMastDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
Viewer cache:&lt;br&gt;
TRName is for text results only.&lt;br&gt;
HL7:  OBR-4.1 : UniversalServiceIdentifier.Identifier&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMCode)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRName)&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-4.2 : UniversalServiceIdentifier.Text&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-4.3 : UniversalServiceIdentifier.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-4.7 : UniversalServiceIdentifier.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to subfield 1 or 2 not being null, if subfield 4 or 5 is not&lt;br&gt;
null, then subfields 4, 5, 6, and 8 will be parsed into the Code,&lt;br&gt;
Description, CodeSystem, and CodeSystemVersionId, respectively, of a&lt;br&gt;
PriorCode in the list of PriorCodes. In this case, the PriorCode Type is&lt;br&gt;
set to "A".&lt;br&gt;
HL7:  OBR-4.4 : UniversalServiceIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-4.5 : UniversalServiceIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-4.6 : UniversalServiceIdentifier.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-4.8 : UniversalServiceIdentifier.AlternateCodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  OBR-4.9 : UniversalServiceIdentifier.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderCategory" type="OrderCategory">
            <s:annotation>
                <s:documentation>Can be used to group orders in the Clinical Viewer.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-24 is parsed to the OrderCategory Code. HL7ToSDA3 does not set the&lt;br&gt;
Description. The parsed value is converted to uppercase in the SDA.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For all Order types, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order has an OrderCategory, then the InfoSubType of the streamlet is&lt;br&gt;
set to the OrderCategory Code, converted to uppercase.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The OrderCategory is stored as a property of the ARCItmMast (OrderItem),&lt;br&gt;
which is itself a property of the OEOrderItem (Order).&lt;br&gt;&lt;br&gt;
HL7:  OBR-24 : DiagnosticServSectID&lt;br&gt;
SDATableName=OrderCategory, ViewerClass=User.HS.ARCItemCat&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMItemCatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderQuantity" type="s:string">
            <s:annotation>
                <s:documentation>Number of items ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderQuantity is parsed from (in order of precendence) TQ1-2.1, RXE-1.1.1,&lt;br&gt;
OBR-27.1.1, or ORC-7.1.1. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Quantity in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  OBR-27.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  RXE-1.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  TQ1-2.1   : Quantity.Quantity&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>Who placed the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderedBy is parsed from (in order of precendence) OBR-16, RXO-14, RXE-13,&lt;br&gt;
or ORC-12 and -24. Though each of these fields is repeating, for each one&lt;br&gt;
except ORC-24, HL7ToSDA3 will only parse the first non-null instance. For&lt;br&gt;
ORC-24, the instance corresponding to the first non-null instance of ORC-12&lt;br&gt;
will be parsed. ORC-12 and -24 are used in combination to set the&lt;br&gt;
provider's Name and Address in the SDA. Every other field only sets the&lt;br&gt;
Name. For Adress.City, .State, .Zip, .Country, and .County as well as NameTypeCode&lt;br&gt;
and IdentifierTypeCode, only the Code is parsed. HL7ToSDA3 does not set the&lt;br&gt;
Description. Note that an RDE_O11 message technically can contain both an&lt;br&gt;
RXO segment and an RXE, however HL7ToSDA3 does not parse the RXO segment&lt;br&gt;
from an RDE message.&lt;br&gt;&lt;br&gt;
HL7:  ORC-12 : OrderingProvider&lt;br&gt;
HL7:  ORC-24 : OrderingProviderAddress&lt;br&gt;
HL7:  RXE-13 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  RXO-14 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  OBR-16 : OrderingProvider&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDoctorDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-12.1 : OrderingProvider.IDNumber&lt;br&gt;
HL7:  RXE-13.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  RXO-14.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  OBR-16.1 : OrderingProvider.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-12.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
HL7:  RXE-13.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  RXO-14.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  OBR-16.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-12.4 : OrderingProvider.MiddleName&lt;br&gt;
HL7:  RXE-13.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  RXO-14.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  OBR-16.4 : OrderingProvider.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-12.6 : OrderingProvider.NamePrefix&lt;br&gt;
HL7:  RXE-13.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  RXO-14.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  OBR-16.6 : OrderingProvider.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-24.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-24.1.1.&lt;br&gt;
HL7:  ORC-24.1.1 : OrderingProviderAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-24.2 : OrderingProviderAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPStName)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-24.3 : OrderingProviderAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCityDR)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-24.4 : OrderingProviderAddress.StateorProvince&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-24.5 : OrderingProviderAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-24.6 : OrderingProviderAddress.Country&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-24.9 : OrderingProviderAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.NameTypeCode&lt;br&gt;
HL7:  OBR-16.10 : OrderingProvider.NameTypeCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.IdentifierTypeCode&lt;br&gt;
HL7:  OBR-16.13 : OrderingProvider.IdentifierTypeCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteringOrganization" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Entering Facility (Location)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-13 is only parsed if subfield 1 is not null. Only the Code is parsed.&lt;br&gt;
HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
HL7:  ORC-13.1 : EnterersLocation.PointofCare&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIOrdDeptDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Only the Code is parsed. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>VerifiedBy (CareProvider)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-32 will be used if present, else the first non-null instance of ORC-11&lt;br&gt;
will be used, if there is one.&lt;br&gt;&lt;br&gt;
HL7:  ORC-11 : VerifiedBy&lt;br&gt; 
HL7:  OBR-32 : PrincipalResultInterpreter&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthoriseClinicianDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-11.1 : VerifiedBy.IDNumber&lt;br&gt;
HL7:  OBR-32.1.1 : PrincipalResultInterpreter.Name.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields, the given and family names are concatenated together as&lt;br&gt;
"[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-11.9 : VerifiedBy.AssigningAuthority&lt;br&gt;
HL7:  OBR-32.1.9 : PrincipalResultInterpreter.Name.AssigningAuthorityNamespaceID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-11.4 : VerifiedBy.SecondandFurtherGivenNames&lt;br&gt;
HL7:  OBR-32.1.4 : PrincipalResultInterpreter.Name.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-11.6 : VerifiedBy.Prefix&lt;br&gt;
HL7:  OBR-32.1.6 : PrincipalResultInterpreter.Name.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  ORC-11.7 : VerifiedBy.Degree&lt;br&gt;
HL7:  OBR-32.1.5 : PrincipalResultInterpreter.Name.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  OBR-32.1.7 : PrincipalResultInterpreter.Name.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CallbackNumber">
            <s:annotation>
                <s:documentation>Callback number (who to contact with questions, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-17 is used if any regular (business), mobile, or fax numbers or e-mail&lt;br&gt;
addresses can be parsed from it, else ORC-14 is used. In either case, the&lt;br&gt;
format of CallbackNumber is: "[List of business #s], Mobile: [List of&lt;br&gt;
mobile #s], Fax: [List of fax #s], email: [List of e-mail addresses]". Each&lt;br&gt;
list is comma-delimited. Each tag (Mobile, Fax, email) will only be used if&lt;br&gt;
there are elements of that type. For each field, every instance will be&lt;br&gt;
parsed, if that field is used. Up to three numbers can be parsed from each&lt;br&gt;
instance of a field:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, a number is parsed from them&lt;br&gt;
as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-If subfield 12 is not null, it is parsed.&lt;br&gt;
-If subfield 1 is not null, it is parsed.&lt;br&gt;
-Additionally, if subfield 9 is not null, the first number parsed from that&lt;br&gt;
instance will have it appended to the end after a semicolon separator.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;
The logic to determine the type of the number is:&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 is in ["",PH], the&lt;br&gt;
number is a regular (business) number.&lt;br&gt;
-If subfield 2 = "BPN" and subfield 3 is in [CP,BP], the number is a mobile&lt;br&gt;
number.&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 = "FX", the number is&lt;br&gt;
a fax number.&lt;br&gt;
Finally, each non-null instance of subfield 4 is parsed as an e-mail&lt;br&gt;
address.&lt;br&gt;&lt;br&gt;
HL7:  OBR-17 : OrderCallbackPhoneNumber&lt;br&gt;
HL7:  ORC-14 : CallBackPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINotify)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ReassessmentTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>If the Order is not final, this is the date/time when it should be reviewed&lt;br&gt;
and perhaps finalized.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIReassessmentDate) + User.HS.OEOrdItem(OEORIReassessmentTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Frequency" type="Frequency">
            <s:annotation>
                <s:documentation>How often (e.g. Code=QID, Desc=QID, Factor=4)&lt;br&gt;
QID is Latin, meaning 4x a day.  BID means 2x day, etc.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though TQ1-3 is a repeating field, HL7ToSDA3 will only parse the first&lt;br&gt;
non-null instance.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Frequency, then that&lt;br&gt;
Frequency will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-3 : RepeatPattern&lt;br&gt;
SDATableName=Frequency, ViewerClass=User.HS.PHCFreq&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPHFreqDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  TQ1-3.1.1 : RepeatPattern.RepeatPatternCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-3.1.2 : RepeatPattern.RepeatPatternCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7:  TQ1-3.5 : RepeatPattern.PeriodQuantity&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRFactor)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Duration" type="Duration">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Duration is parsed from (in order of precedence) TQ1-6, RXE-1.3, OBR-27.3,&lt;br&gt;
or ORC-7.3. The RXE, OBR, and ORC fields will only set the Duration Code.&lt;br&gt;
TQ1-6 will populate the Code, Description, and Factor as described below.&lt;br&gt;
Though ORC-7 is a repeating field, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance. OBR-27 is also a repeating field, and HL7ToSDA3 parses every&lt;br&gt;
non-null instance of it. The last non-null instance of Duration in OBR-27&lt;br&gt;
is the one that takes precedence. Note that an RDE_O11 message may contain&lt;br&gt;
TQ1 segments in two different places. HL7ToSDA3 parses the one following&lt;br&gt;
the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Duration, then that Duration&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  TQ1-6 : ServiceDuration&lt;br&gt;
SDATableName=Duration, ViewerClass=User.HS.PHCDuration&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDuratDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
When parsing the TQ1-6 field, Code is initially parsed from subfield 2.1&lt;br&gt;
(Units.Identifier). If subfield 1 (Quantity) is not null, then if subfields&lt;br&gt;
2.1 and 2.2 (Units.Text) are null, Code will be parsed from Quantity. Then,&lt;br&gt;
if Quantity starts with a non-zero number and the parsed value for Code&lt;br&gt;
does not, the parsed value for Code is set to +[Quantity]_[Code]. For&lt;br&gt;
example, if Quantity="2" and Units.Identifier="D", the value parsed to Code&lt;br&gt;
is "2D". For the other segments that Duration Code may be parsed from (RXE,&lt;br&gt;
OBR, ORC), the value is simply parsed from the field listed below.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null and +[Quantity] is logically "true",&lt;br&gt;
and if TQ1-6.2.2 (Units.Text) is not null and +[Units.Text] is logically&lt;br&gt;
"false" (basically, if Quantity starts with a number and Units.Text&lt;br&gt;
doesn't), then the value parsed to Description is&lt;br&gt;
+[Quantity]_" "_[Units.Text]. For example, if Quantity="2" and&lt;br&gt;
Units.Text="Days", the value parsed to Description is "2 Days". If these&lt;br&gt;
conditions are not all met then the Description is simply parsed from&lt;br&gt;
TQ1-6.2.2.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null, then if +[Quantity] is logically "true",&lt;br&gt;
Factor is parsed as +[Quantity], otherwise Factor is parsed as null. If&lt;br&gt;
Quantity is null, then if +[TQ1-2.1/Units.Identifier] is logically "true",&lt;br&gt;
Factor is parsed as +[Units.Identifier], else if +[TQ1-2.2/Units.Text] is&lt;br&gt;
logically "true", Factor is parsed as +[Units.Text], else Factor is not&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUFactor)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status">
            <s:annotation>
                <s:documentation>The current status of the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The following values are mapped in the HL7 to SDA3 parsing:&lt;br&gt;
DC-&gt;D, CA-&gt;C, RP-&gt;R, HD-&gt;H, SC-&gt;IP, CM-&gt;E, [Other]-&gt;unchanged&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For any type of Order, in the OnValidate method of the streamlet class, if&lt;br&gt;
Status is null, it is defaulted to "V" for "Verified". Then, for Orders&lt;br&gt;
that can have results (LabOrder, RadOrder, OtherOrder), if the Order has a&lt;br&gt;
Result, Status is set to "E" for "Executed", unless it is "D", "C", "R", or&lt;br&gt;
"H" (for Discontinued, Cancelled, Replaced, or On Hold, respectively). The&lt;br&gt;
reasoning behind setting the Status to "E" is that if the Order has a&lt;br&gt;
Result, then it must have been executed. The reasoning behind the&lt;br&gt;
exceptions to this is that those particular statuses may have been entered&lt;br&gt;
after the Result was submitted. Also, for any type of Order, when Orders of&lt;br&gt;
of that type are inactivated with ActionCode="I", the Status of each will&lt;br&gt;
be set to "I".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Status is stored in the Viewer Cache as an OECOrderStatus with OSTATCode&lt;br&gt;
matching Status, ALPHAUP collated. If no such entry in OECOrderStatus&lt;br&gt;
exists, Status will be stored as V/Verified in the Viewer Cache only and an&lt;br&gt;
alert logged in the Ensemble Event Log. Note that the OECOrderStatus table&lt;br&gt;
is loaded from the SITE- or HS-Default-OrderStatus.txt file at the time the&lt;br&gt;
Access Gateway is reset.&lt;br&gt;&lt;br&gt;
HL7:  ORC-5 : OrderStatus&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.OECOrderStatus&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemStatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Priority" type="Priority">
            <s:annotation>
                <s:documentation>The Priority of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Priority is parsed from (in order of precendence) TQ1-9, RXE-1.6, OBR-27.6,&lt;br&gt;
OBR-5, or ORC-7.6. TQ1-9 may set the Code, Description, and&lt;br&gt;
SDACodingStandard. Every other field only sets the Code. Though TQ1-9 and&lt;br&gt;
ORC-7 are repeating fields, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance of each. OBR-27 is also a repeating field, and HL7ToSDA3 parses&lt;br&gt;
every non-null instance of it. The last non-null instance of Priority in&lt;br&gt;
OBR-27 is the one that takes precedence. Note that an RDE_O11 message may&lt;br&gt;
contain TQ1 segments in two different places. HL7ToSDA3 parses the one&lt;br&gt;
following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order contains no Priority, one is defaulted in with Code="N" and &lt;br&gt;
Description="Normal".&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9   : Priority&lt;br&gt;
SDATableName=Priority, ViewerClass=User.HS.OECPriority&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPriorityDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9.1  : Priority.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-9.2  : Priority.Text&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  TQ1-9.3  : Priority.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConfidentialityCode" type="Confidentiality">
            <s:annotation>
                <s:documentation>Confidentiality code (e.g. VIP, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-28 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-28 : ConfidentialtyCode&lt;br&gt;
SDATableName=Confidentiality, ViewerClass=User.HS.OECOverReasonNonConsent&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINoConsentOverrideReasDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-28.1 : ConfidentialtyCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-28.2 : ConfidentialtyCode.Text&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-28.3 : ConfidentialtyCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Condition">
            <s:annotation>
                <s:documentation>Condition, e.g. "keep BP below 110"&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Condition is parsed from (in order of precendence) TQ1-10, RXE-1.7,&lt;br&gt;
OBR-27.7, or ORC-7.7. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Condition in OBR-27 is the one that takes precendence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  OBR-27.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  RXE-1.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  TQ1-10  : ConditionText&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILtClinicalCondition)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="TextInstruction" type="s:string">
            <s:annotation>
                <s:documentation>Text instructions or directions, e.g. "After food", or if Duration etc.&lt;Br&gt;
isn't coded, "Take 3 twice a day"&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
TextInstruction is parsed from (in order of precendence) TQ1-11, RXE-1.8,&lt;br&gt;
OBR-27.8, or ORC-7.8. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Text in OBR-27 is the one that takes precendence. Note that an RDE_O11&lt;br&gt;
message may contain TQ1 segments in two different places. HL7ToSDA3 parses&lt;br&gt;
the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a TextInstruction, then that&lt;br&gt;
TextInstruction will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.8 : QuantityTiming.Text&lt;br&gt;
HL7:  OBR-27.8 : QuantityTiming.Text&lt;br&gt;
HL7:  RXE-1.8 : QuantityTimingText&lt;br&gt;
HL7:  TQ1-11  : TextInstruction&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDepProcNotes)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderGroup" type="s:string">
            <s:annotation>
                <s:documentation>This is a way to group related Orders together, such as a prescription&lt;br&gt;
chain.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemGroup)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Order Comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Order Comments are always parsed from NTE segments, though HL7 order&lt;br&gt;
messages may contain NTEs in different places, and only certain ones are&lt;br&gt;
parsed to Order Comments. For ORM and OMP messages, it is the first set of&lt;br&gt;
NTEs following the ORC (in the message schema, not necessarily in the&lt;br&gt;
message) that are parsed to Comments.  In an RDE message the set of NTEs&lt;br&gt;
following the RXE segment are parsed to Order Comments. Order Comments can&lt;br&gt;
only be parsed from an ORU message if it contains a text result (either&lt;br&gt;
ORC-29 is not "LAB", or all OBX-2 values = "FT", "TX", or "ED"). In this&lt;br&gt;
case the NTEs immediately following the OBR are parsed to Order Comments.&lt;br&gt;
In an ORU containing atomic lab results, the NTEs following the OBR are&lt;br&gt;
parsed to the Result Comments, and in an ORU containing Observations&lt;br&gt;
(ORC-29="OBS"), these NTEs are not parsed.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRemarks)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConsultationDepartment" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Department or facility that consulted&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIConsultDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AuthorizationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the order was authorized&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthorisedDate) + User.HS.OEOrdItem(OEORIAuthorisedTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReceivingLocation" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Location or facility receiving/performing the order&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRecDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedComments" type="s:string">
            <s:annotation>
                <s:documentation>Verified order comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthComments)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupId" type="s:string">
            <s:annotation>
                <s:documentation>If this item was ordered as part of a group, this is the identifier of that&lt;br&gt;
group. The SDA2-to-SDA3 transform populates this field with the SDA2&lt;br&gt;
ExternalId property.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.1 : PlacerGroupNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILab1)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupAssigningAuthority" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
GroupAssigningAuthority is composed of subfields 2, 3, and 4 concatenated&lt;br&gt;
together as "[.2]^[.3]^[.4]", but only if at least one of these is not&lt;br&gt;
null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.2: PlacerGroupNumber.NamespaceID&lt;br&gt;
HL7:  ORC-4.3: PlacerGroupNumber.UniversalID&lt;br&gt;
HL7:  ORC-4.4: PlacerGroupNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate all orders of this type (set Status="I")&lt;br&gt;
C = Clear/delete all orders of this type&lt;br&gt;
R = Replace - Applies only to Atomic Result Items.  Clears previous result items before storing all new items,
ignoring matching on test item code.  &lt;b&gt;Use ONLY when always receiving full updates.  Using this with
partial updates may cause a loss of test item data.&lt;/b&gt;&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation of the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in ORC-1 will be parsed as ActionCode="I", while&lt;br&gt;
four double quotes ("""") will be parsed as ActionCode="C". &lt;br&gt;
ActionCode="R" in ORC-1 will impact parsing of TestItemCode.  See the
TestItemCode property of HS.SDA3.LabResultItem for details.&lt;br&gt;
Any other value will not be parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-1 : OrderControl&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-10 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-10 : EnteredBy&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserUpdate)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-10.1 : EnteredBy.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-10.2.1 : EnteredBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-10.3 : EnteredBy.GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-10.9 : EnteredBy.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-21 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed. ORC-22 is also a repeating field, however HL7ToSDA3 will only parse&lt;br&gt;
the instance corresponding to the instance of ORC-21 parsed. For example,&lt;br&gt;
if the third instance of ORC-21 is parsed (because the first two are null),&lt;br&gt;
then the third instance of ORC-22 will be parsed as well. For Address.City,&lt;br&gt;
State, Zip, Country, and County only the Code is parsed. HL7ToSDA3 does not&lt;br&gt;
set the Description. Every instance of ORC-23 will be examined but may not&lt;br&gt;
be parsed to the SDA. The algorithm to parse a number out of one instance&lt;br&gt;
of ORC-23 is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else no number can be parsed from this instance.&lt;br&gt;
-Whichever number is parsed, if subfield 9 of that instance is not null, it&lt;br&gt;
will be appended to the number, delimited by a semicolon.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;&lt;br&gt;
HL7:  ORC-21 : OrderingFacilityName&lt;br&gt;
HL7:  ORC-22 : OrderingFacilityAddress&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserAddHospDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-21.10 will be parsed to the Code if present, else ORC-21.3 will.&lt;br&gt;
HL7:  ORC-21.10 : OrderingFacilityName.OrganizationIdentifier&lt;br&gt;
HL7:  ORC-21.3 : OrderingFacilityName.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-21.1 : OrderingFacilityName.OrganizationName&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-21.6 : OrderingFacilityName.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-22.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-22.1.1.&lt;br&gt;
HL7:  ORC-22.1.1 : OrderingFacilityAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-22.2 : OrderingFacilityAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPAddress)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-22.3 : OrderingFacilityAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCity)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-22.4 : OrderingFacilityAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPProvinceDR)&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-22.5 : OrderingFacilityAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-22.6 : OrderingFacilityAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountryDR)&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-22.9 : OrderingFacilityAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountyParishDR)&lt;br&gt;
.ContactInfo.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
WorkPhoneNumber is parsed from the first instance of ORC-23 with subfield 2&lt;br&gt;
in ["",WPN,ASN,EMR] and subfield 3 in ["",PH] and from which a phone number&lt;br&gt;
can be parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPPhone)&lt;br&gt;
.ContactInfo.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MobilePhoneNumber is parsed from the first instance of ORC-23 with subfield&lt;br&gt;
2 = "BPN" and subfield 3 in [CP,BP] and from which a phone number can be&lt;br&gt;
parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ContactInfo.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
EmailAddress is parsed from the first non-null instance of ORC-23.4.&lt;br&gt;
HL7:  ORC-23.4 : OrderingFacilityPhoneNumber.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPEmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. For Orders than can have&lt;br&gt;
Results (LabOrder, RadOrder, OtherOrder), if the Order actually has a&lt;br&gt;
Result and FromTime, EnteredOn, and Result.ResultTime are all null, an&lt;br&gt;
error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  ORC-9.1 : DateTimeofTransaction.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUpdateDate) + User.HS.OEOrdItem(OEORIUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
FromTime is parsed from (in order of precedence) TQ1-7.1, RXE-1.4,&lt;br&gt;
OBR-27.4, OBR-6.1, or ORC-7.4. Though ORC-7 is a repeating field, HL7ToSDA3&lt;br&gt;
only parses the first non-null instance. OBR-27 is also a repeating field,&lt;br&gt;
and HL7ToSDA3 parses every non-null instance of it. The last non-null&lt;br&gt;
instance of StartDateTime.Time in OBR-27 is the one that takes precedence.&lt;br&gt;
Note that an RDE_O11 message may contain TQ1 segments in two different&lt;br&gt;
places. HL7ToSDA3 parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. Then, if the Order has a&lt;br&gt;
Result and FromTime is still null, it is defaulted to Result.ResultTime.&lt;br&gt;
Finally, if the Order has a Result and FromTime is still null, an error&lt;br&gt;
will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a FromTime, then that FromTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  OBR-6.1 : RequestedDateTime.Time&lt;br&gt;
HL7:  OBR-27.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  RXE-1.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  TQ1-7.1 : StartDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORISttDat) + User.HS.OEOrdItem(OEORISttTim)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ToTime is parsed from (in order of precedence) TQ1-8, RXE-1.5, OBR-27.5,&lt;br&gt;
or ORC-7.5. Though ORC-7 is a repeating field, HL7ToSDA3 only parses the&lt;br&gt;
first non-null instance. OBR-27 is also a repeating field, and HL7ToSDA3&lt;br&gt;
parses every non-null instance of it. The last non-null instance of&lt;br&gt;
EndDateTime.Time in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a ToTime, then that ToTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  OBR-27.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  RXE-1.5.1 : QuantityTiming.EndDateTimeTime&lt;br&gt;
HL7:  TQ1-8.1   : EndDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEndDate) + User.HS.OEOrdItem(OEORIEndTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DrugProduct" type="DrugProduct">
            <s:annotation>
                <s:documentation>What was dispensed - commercial product name&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments, though RXO-6 does take precedence over RXO-1.&lt;br&gt;
For both RXO-1 and RXE-2, the field will only be parsed if subfield 1 or 2&lt;br&gt;
is not null. Though RXO-6 is a repeating field, only the first non-null&lt;br&gt;
instance will be parsed.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if the Order has no&lt;br&gt;
OrderItem but does have a DrugProduct, then a new OrderItem will be&lt;br&gt;
defaulted in with Code, Description, and SDACodingStandard copied from the&lt;br&gt;
DrugProduct.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The OEOrdItem (Order) in the Viewer Cache references an ARCItmMast (Order&lt;br&gt;
Item) via OEORIItmMastDR, which references a PHCDrgForm via ARCIMPHCDFDR,&lt;br&gt;
which references a PHCDrgMast (Drug Product) via PHCDFPHCDParRef.&lt;br&gt;
PHCDrgForm is a child of PHCDrgMast, and a PHCDrgMast may have more than&lt;br&gt;
one linked PHCDrgForm. When a DrugProduct is loaded into the Viewer Cache,&lt;br&gt;
it is matched to a PHCDrgMast based on Code, Description, and&lt;br&gt;
SDACodingStandard. Then, the existing child PHCDrgForms of that PHCDrgMast&lt;br&gt;
are examined to find one that matches the DrugProduct on Form, BaseQty,&lt;br&gt;
BaseUnits, Strength, StrengthQty, and StrengthUnits. Form, BaseQty,&lt;br&gt;
BaseUnits, and Strength are stored as properties of the PHCDrgForm.&lt;br&gt;
StrengthQty and StrengthUnits are stored as properties of a&lt;br&gt;
PHCFormDoseEquiv, which is a child of PHCDrgForm, though in the Viewer&lt;br&gt;
Cache a PHCDrgForm should only ever have one child PHCFormDoseEquiv. If no&lt;br&gt;
matching child PHCDrgForm can be found, a new one is created (along with a&lt;br&gt;
child PHCFormDoseEquiv) from the properties of the DrugProduct. Once a&lt;br&gt;
matching PHCDrgForm is found or a new one created, an attempt is made to&lt;br&gt;
link the ARCItmMast to it by setting the ARCIMPHCDFDR property of the&lt;br&gt;
ARCItmMast. If this fails for any reason (for example, if the ARCIMPHCDFDR&lt;br&gt;
property already references a different PHCDrgForm), then a new ARCItmMast&lt;br&gt;
will be created with the original OrderCategory of the Order, the&lt;br&gt;
SDACodingStandard of the DrugProduct, and Code and Description (referencing&lt;br&gt;
properties of the DrugProduct):&lt;br&gt;
"[Description]([Form.Code]:[BaseQty] [BaseUnits.Description]:[StrengthQty] [StrengthUnits.Description]:[Strength.Description])"&lt;br&gt;
Note that it is possible that such an ARCItmMast already exists in the&lt;br&gt;
Viewer Cache, in which case the "new" ARCItmMast will simply match the&lt;br&gt;
existing one. Finally, an attempt is made to link the new ARCItmMast to the&lt;br&gt;
new or matched PHCDrgForm. If this fails for any reason (for example, the&lt;br&gt;
"new" ARCItmMast was not new and was already linked to a different&lt;br&gt;
PHCDrgForm), then an error will be logged and the Order will not be stored&lt;br&gt;
in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  RXO-1 : RequestedGiveCode&lt;br&gt;
HL7:  RXO-6 : ProvidersPharmacyTreatmentInstructions&lt;br&gt;
HL7:  RXA-5 : AdministeredCode&lt;br&gt;
HL7:  RXE-2 : GiveCode&lt;br&gt;
SDATableName=DrugProduct, ViewerClass=User.HS.PHCDrgMast&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItmMastDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-1.1 : RequestedGiveCode.Identifier&lt;br&gt;
HL7:  RXO-6.1 : ProvidersPharmacyTreatmentInstructions.Identifier&lt;br&gt;
HL7:  RXA-5.1 : AdministeredCode.Identifier&lt;br&gt;
HL7:  RXE-2.1 : GiveCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-1.2 : RequestedGiveCode.Text&lt;br&gt;
HL7:  RXO-6.2 : ProvidersPharmacyTreatmentInstructions.Text&lt;br&gt;
HL7:  RXA-5.2 : AdministeredCode.Text&lt;br&gt;
HL7:  RXE-2.2 : GiveCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-1.3 : RequestedGiveCode.NameofCodingSystem&lt;br&gt;
HL7:  RXO-6.3 : ProvidersPharmacyTreatmentInstructions.NameofCodingSystem&lt;br&gt;
HL7:  RXA-5.3 : AdministeredCode.NameofCodingSystem&lt;br&gt;
HL7:  RXE-2.3 : GiveCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For each field, the logic to parse PriorCodes is the same: if subfield 4 or&lt;br&gt;
5 is not null, then subfields 4, 5, and 6 will be parsed into the Code,&lt;br&gt;
Description, and CodeSystem, respectively, of a PriorCode in the list of&lt;br&gt;
PriorCodes. In this case, the PriorCode Type is set to "A". Note that for&lt;br&gt;
RXO-1 and RXE-2, subfield 1 or 2 must still be non-null for anything in the&lt;br&gt;
field to be parsed.&lt;br&gt;
HL7:  RXO-1.4 : RequestedGiveCode.AlternateIdentifier&lt;br&gt;
HL7:  RXO-1.5 : RequestedGiveCode.AlternateText&lt;br&gt;
HL7:  RXO-1.6 : RequestedGiveCode.NameofAlternateCodingSystem&lt;br&gt;
HL7:  RXO-6.4 : ProvidersPharmacyTreatmentInstructions.AlternateIdentifier&lt;br&gt;
HL7:  RXO-6.5 : ProvidersPharmacyTreatmentInstructions.AlternateText&lt;br&gt;
HL7:  RXO-6.6 : ProvidersPharmacyTreatmentInstructions.NameofAlternateCodingSystem&lt;br&gt;
HL7:  RXA-5.4 : AdministeredCode.AlternateIdentifier&lt;br&gt;
HL7:  RXA-5.5 : AdministeredCode.AlternateText&lt;br&gt;
HL7:  RXA-5.6 : AdministeredCode.NameofAlternateCodingSystem&lt;br&gt;
HL7:  RXE-2.4 : GiveCode.AlternateIdentifier&lt;br&gt;
HL7:  RXE-2.5 : GiveCode.AlternateText&lt;br&gt;
HL7:  RXE-2.6 : GiveCode.NameofAlternateCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  RXO-1.9 : RequestedGiveCode.OriginalText&lt;br&gt;
HL7:  RXO-6.9 : ProvidersPharmacyTreatmentInstructions.OriginalText&lt;br&gt;
HL7:  RXA-5.9 : AdministeredCode.OriginalText&lt;br&gt;
HL7:  RXE-2.9 : GiveCode.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="StrengthVolume" type="Numeric">
            <s:annotation>
                <s:documentation>Strength volume (e.g. the "10" in 2mg/10ml)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments.&lt;br&gt;&lt;br&gt;
HL7:  RXO-25 : RequestedDrugStrengthVolume&lt;br&gt;
HL7:  RXA-23 : AdministeredDrugStrengthVolume&lt;br&gt;
HL7:  RXE-33 : GiveDrugStrengthVolume&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="StrengthVolumeUnits" type="s:string">
            <s:annotation>
                <s:documentation>Units for StrengthVolume (e.g. ml)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments. Each of these fields is coded, and the logic&lt;br&gt;
to parse each is the same: if subfield 2 is not null, parse that to&lt;br&gt;
StrengthVolumeUnits, else parse subfield 1.&lt;br&gt;&lt;br&gt;
HL7:  RXO-26 : RequestedDrugStrengthVolumeUnits&lt;br&gt;
HL7:  RXA-24 : AdministeredDrugStrengthUnits&lt;br&gt;
HL7:  RXE-34 : GiveDrugStrengthVolumeUnits&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RateAmount" type="Numeric">
            <s:annotation>
                <s:documentation>Rate (e.g. the 100 in 100 ml/hour)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO and RXE segments are mutually exclusive among the message types and&lt;br&gt;
segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between them.&lt;br&gt;&lt;br&gt;
HL7:  RXO-21 : RequestedGiveRateAmount&lt;br&gt;
HL7:  RXE-23 : GiveRateAmount&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORISpeedFlowRate)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RateUnits" type="RateUnits">
            <s:annotation>
                <s:documentation>Units for Rate (e.g. the ml in 100 ml/hour)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments. Each of these fields is coded and will only be&lt;br&gt;
parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  RXO-22 : RequestedGiveRateUnits&lt;br&gt;
HL7:  RXE-24 : GiveRateUnits&lt;br&gt;
SDATableName=RateUnits, ViewerClass=User.HS.OECSpeedFlowRate&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIFlowRateUnitDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-22.1 : RequestedGiveRateUnits.Identifier&lt;br&gt;
HL7:  RXE-24.1 : GiveRateUnits.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECSpeedFlowRate(SFRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-22.2 : RequestedGiveRateUnits.Text&lt;br&gt;
HL7:  RXE-24.2 : GiveRateUnits.Text&lt;br&gt;
VIEWERLIB: User.HS.OECSpeedFlowRate(SFRDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-22.3 : RequestedGiveRateUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXE-24.3 : GiveRateUnits.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RateTimeUnit" type="s:string">
            <s:annotation>
                <s:documentation>Time units (e.g. per hour, as in 100 ml per hour)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments.&lt;br&gt;&lt;br&gt;
HL7:  RXO-17 : RequestedGivePerTimeUnit&lt;br&gt;
HL7:  RXA-12 : AdministeredPerTimeUnit&lt;br&gt;
HL7:  RXE-22 : GivePerTimeUnit&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUnitHrs)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DoseQuantity" type="Numeric">
            <s:annotation>
                <s:documentation>Size of dose (e.g. the 20 in 20mg).&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments, however RXO-18 takes precedence over RXO-2,&lt;br&gt;
and RXE-25 takes precendence over RXE-3.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a DoseQuantity, then that&lt;br&gt;
DoseQuantity will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  RXO-2 : RequestedGiveAmountMinimum&lt;br&gt;
HL7:  RXO-18 : RequestedGiveStrength&lt;br&gt;
HL7:  RXA-13 : AdministeredStrength&lt;br&gt;
HL7:  RXE-3 : GiveAmountMinimum&lt;br&gt;
HL7:  RXE-25 : GiveStrength&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDoseQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DoseUoM" type="UoM">
            <s:annotation>
                <s:documentation>Units for DoseQuantity (e.g. the mg in 20mg)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO and RXE segments are mutually exclusive among the message types and&lt;br&gt;
segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between them, however RXO-19 takes precedence over RXO-4, and&lt;br&gt;
RXE-26 takes precedence over RXE-5. Each of the HL7 fields is coded, and&lt;br&gt;
each one will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a DoseUoM, then that DoseUoM&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  RXO-4 : RequestedGiveUnits&lt;br&gt;
HL7:  RXO-19 : RequestedGiveStrengthUnits&lt;br&gt;
HL7:  RXE-5 : GiveUnits&lt;br&gt;
HL7:  RXE-26 : GiveStrengthUnits&lt;br&gt;
HL7:  RXA-14 : AdministeredStrengthUnits&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUnitDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-4.1 : RequestedGiveUnits.Identifier&lt;br&gt;
HL7:  RXO-19.1 : RequestedGiveStrengthUnits.Identifier&lt;br&gt;
HL7:  RXE-5.1 : GiveUnits.Identifier&lt;br&gt;
HL7:  RXE-26.1 : GiveStrengthUnits.Identifier&lt;br&gt;
HL7:  RXA-14.1 : AdministeredStrengthUnits.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-4.2 : RequestedGiveUnits.Text&lt;br&gt;
HL7:  RXO-19.2 : RequestedGiveStrengthUnits.Text&lt;br&gt;
HL7:  RXE-5.2 : GiveUnits.Text&lt;br&gt;
HL7:  RXE-26.2 : GiveStrengthUnits.Text&lt;br&gt;
HL7:  RXA-14.2 : AdministeredStrengthUnits.Text&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-4.3 : RequestedGiveUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXO-19.3 : RequestedGiveStrengthUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXE-5.3 : GiveUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXE-26.3 : GiveStrengthUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXA-14.3 : AdministeredStrengthUnits.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="MaxDoseQuantity" type="Numeric">
            <s:annotation>
                <s:documentation>Maximum dose quantity&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO and RXE segments are mutually exclusive among the message types and&lt;br&gt;
segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between them.&lt;br&gt;&lt;br&gt;
HL7:  RXO-3 : RequestedGiveAmountMaximum&lt;br&gt;
HL7:  RXE-4 : GiveAmountMaximum&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPRNTotNumberDosesAll)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="NumberOfRefills" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
RXO and RXE segments are mutually exclusive among the message types and&lt;br&gt;
segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between them.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
The type of OEORIMaxRepeats is "%Float", so NumberOfRefills will only be&lt;br&gt;
loaded into OEORIMaxRepeats if it is a valid number according to&lt;br&gt;
$IsValidNum(). In the Viewer, the column of an Order Profile (component&lt;br&gt;
OEOrdItem.ListEMR) that displays OEORIMaxNumberOfRepeats is called&lt;br&gt;
"Repeats" by default. The component name as it appears in the properties&lt;br&gt;
of the column in the Layout Editor is "MaxRep". The column that displays&lt;br&gt;
OEORIMaxRepeats is called "Repeat" by default, component name "Repeat".&lt;br&gt;
The value actually displayed depends on OEORIMaxRepeats and&lt;br&gt;
OEORICurrRepeatNumber (populated by the RefillNumber property in SDA):&lt;br&gt;
-If OEORIMaxRepeats is null, no value is displayed.&lt;br&gt;
-Else if "+[OEORICurrRepeatNumber]" is 0, OEORIMaxRepeats is displayed.&lt;br&gt;
-Else the value displayed is "[OEORICurrRepeatNumber] / [OEORIMaxRepeats]",
 for example: "3 / 10".&lt;br&gt;&lt;br&gt;
HL7:  RXO-13 : NumberOfRefills&lt;br&gt;
HL7:  RXE-12 : NumberOfRefills&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIMaxNumberOfRepeats)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIMaxRepeats)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DosageForm" type="DosageForm">
            <s:annotation>
                <s:documentation>Dosage Form (e.g. Tablet, Capsule, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments. Each of the HL7 fields is coded, and each one&lt;br&gt;
will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  RXO-5 : RequestedDosageForm&lt;br&gt;
HL7:  RXA-8 : AdministeredDosageForm&lt;br&gt;
HL7:  RXE-6 : GiveDosageForm&lt;br&gt;
SDATableName=DosageForm, ViewerClass=User.HS.PHCDosage&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDosageDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-5.1 : RequestedDosageForm.Identifier&lt;br&gt;
HL7:  RXA-8.1 : AdministeredDosageForm.Identifier&lt;br&gt;
HL7:  RXE-6.1 : GiveDosageForm.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCDosage(PHCDOCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-5.2 : RequestedDosageForm.Text&lt;br&gt;
HL7:  RXA-8.2 : AdministeredDosageForm.Text&lt;br&gt;
HL7:  RXE-6.2 : GiveDosageForm.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDosage(PHCDODesc1)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-5.3 : RequestedDosageForm.NameofCodingSystem&lt;br&gt;
HL7:  RXA-8.3 : AdministeredDosageForm.NameofCodingSystem&lt;br&gt;
HL7:  RXE-6.3 : GiveDosageForm.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Route" type="Route">
            <s:annotation>
                <s:documentation>Instructions for administering drug (e.g. Oral)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO is mutually exclusive to both RXE and RXR segments among the message&lt;br&gt;
types and segments that HealthShare supports, however an RDE_O11 message&lt;br&gt;
can contain both an RXE and an RXR segment. In this case, RXR-1 takes&lt;br&gt;
precedence over RXE-7. Note that though RXO-7 and RXE-7 are repeating&lt;br&gt;
fields, HL7ToSDA3 will only parse the first non-null instance of each.&lt;br&gt;
RXR-1 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  RXO-7 : ProvidersAdministrationInstructions&lt;br&gt;
HL7:  RXE-7 : ProvidersAdministrationInstructions&lt;br&gt;
HL7:  RXR-1 : Route&lt;br&gt;
SDATableName=Route, ViewerClass=User.HS.OECRoute&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRouteDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-7.1 : ProvidersAdministrationInstructions.Identifier&lt;br&gt;
HL7:  RXE-7.1 : ProvidersAdministrationInstructions.Identifier&lt;br&gt;
HL7:  RXR-1.1 : Route.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECRoute(ROUTECode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-7.2 : ProvidersAdministrationInstructions.Text&lt;br&gt;
HL7:  RXE-7.2 : ProvidersAdministrationInstructions.Text&lt;br&gt;
HL7:  RXR-1.2 : Route.Text&lt;br&gt;
VIEWERLIB: User.HS.OECRoute(ROUTEDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-7.3 : ProvidersAdministrationInstructions.NameofCodingSystem&lt;br&gt;
HL7:  RXE-7.3 : ProvidersAdministrationInstructions.NameofCodingSystem&lt;br&gt;
HL7:  RXR-1.3 : Route.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Indication">
            <s:annotation>
                <s:documentation>The condition or problem for which the drug/treatment was prescribed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Each of the listed HL7 fields is coded and repeating. The logic to parse&lt;br&gt;
each is: only parse the first non-null instance, and within that instance,&lt;br&gt;
if subfield 2 is not null, parse the value from that, else parse the value&lt;br&gt;
from subfield 1.&lt;br&gt;&lt;br&gt;
HL7:  RXO-20 : Indication&lt;br&gt;
HL7:  RXA-19 : Indication&lt;br&gt;
HL7:  RXE-27 : Indication&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ITM2Indication)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="512"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PharmacyStatus" type="s:string">
            <s:annotation>
                <s:documentation>The status of this prescription&lt;br&gt;
For example, in Sweden, a prescription may go through up to 3 statuses: "O"&lt;br&gt;
for "Planned", "F" for "Prescribed", and "U" for "Refilled".&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Medications only, if ActionCode="I" or "C" and ActionScope is one of&lt;br&gt;
"ADMISSION", "DISCHARGE", "ADMINISTERED", or "MEDICATIONS", case-&lt;br&gt;
insensitive, then only Medications with PharmacyStatus matching ActionScope&lt;br&gt;
(case-insensitive) will be affected.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPharmacyStatus)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PrescriptionNumber">
            <s:annotation>
                <s:documentation>The number or ID assigned to the Prescription or Order&lt;br&gt;&lt;br&gt;
HL7:  RXE-15 : PrescriptionNumber&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPrescNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="RefillNumber" type="Numeric">
            <s:annotation>
                <s:documentation>The current refill repeat number&lt;br&gt;
This could be a sequence number or a full ID for the last refill, if any.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
In the Viewer, the column of an Order Profile (component OEOrdItem.ListEMR)&lt;br&gt;
that displays OEORICurrRepeatNumber is called "Repeat" by default. The&lt;br&gt;
component name as it appears in the properties of the column in the Layout&lt;br&gt;
Editor is "Repeat". The value actually displayed depends on&lt;br&gt;
OEORICurrRepeatNumber and OEORIMaxRepeats (populated by the NumberOfRefills&lt;br&gt;
property in SDA, but only if it is a valid number according to&lt;br&gt;
$IsValidNum()):&lt;br&gt;
-If OEORIMaxRepeats is null, no value is displayed.&lt;br&gt;
-Else if "+[OEORICurrRepeatNumber]" is 0, OEORIMaxRepeats is displayed.&lt;br&gt;
-Else the value displayed is "[OEORICurrRepeatNumber] / [OEORIMaxRepeats]",
 for example: "3 / 10".&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORICurrRepeatNumber)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RefillDescription">
            <s:annotation>
                <s:documentation>A description of when the order will be refilled&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRepeatDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="DosageSteps" type="ArrayOfDosageStep">
            <s:annotation>
                <s:documentation>Ordered Dosage Steps&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Every DosageStep is stored in the Viewer Cache as a child OEOrdExec to the&lt;br&gt;
parent OEOrdItem. This list is cleared every time a Medication or&lt;br&gt;
Vaccination is updated, and the inbound DosageSteps are inserted. However,&lt;br&gt;
the first DosageStep in the list (assuming there is at least one) will also&lt;br&gt;
populate several properties of the parent OEOrdItem, overriding any values&lt;br&gt;
that came from the containing Medication or Vaccination. These properties&lt;br&gt;
include FromTime, ToTime, TextInstruction, Frequency, DoseQuantity,&lt;br&gt;
DoseUoM, and Duration.&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.DosageStep&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Administrations" type="ArrayOfAdministration">
            <s:annotation>
                <s:documentation>Administration History&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
From HL7, at most one Administration can be parsed.&lt;br&gt;&lt;br&gt;
HL7:  RXA,RXR&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ComponentMeds" type="ArrayOfDrugProduct">
            <s:annotation>
                <s:documentation>The components of a compound medication&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXC, as it appears in an RDE_O11 message, is a repeating segment. Each RXC&lt;br&gt;
will be parsed to one DrugProduct in the ComponentMeds list. RXC-2, -6, and&lt;br&gt;
-9 are all coded fields.  Each will only be parsed if subfield 1 or 2 is&lt;br&gt;
not null.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
Each DrugProduct in the list of ComponentMeds will be loaded into the&lt;br&gt;
Viewer Cache as an OEOrdItem that references the main Order/OEOrdItem via&lt;br&gt;
the OEORIOEORIDR property and is linked to the PHCDrgMast created from the&lt;br&gt;
DrugProduct. The only exception to this is ComponentMed DrugProducts with&lt;br&gt;
Code matching the Code of the main Order DrugProduct. These will not be&lt;br&gt;
processed into the Viewer Cache as they are considered redundant. For those&lt;br&gt;
ComponentMed DrugProducts that are processed into the Viewer Cache, the&lt;br&gt;
OEORIPlacerNo will be populated with the PlacerId of the parent Order,&lt;br&gt;
OEORILabEpisodeNo with the FillerId, and OEORIFillerNo with&lt;br&gt;
"[FillerId]&amp;[sequential #]". The FromTime (OEORISttDat+OEORISttTim), ToTime&lt;br&gt;
(OEORIEndDate+OEORIEndTime), and Status (OEORIItemStatDR) are also copied&lt;br&gt;
from the main Order.&lt;br&gt;&lt;br&gt;
HL7:  RXC-2 : ComponentCode&lt;br&gt;
HL7:  RXC-5 : ComponentStrength&lt;br&gt;
HL7:  RXC-6 : ComponentStrengthUnits&lt;br&gt;
HL7:  RXC-8 : ComponentDrugStrengthVolume&lt;br&gt;
HL7:  RXC-9 : ComponentDrugStrengthVolumeUnits&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXC-2.1 : ComponentCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXC-2.2 : ComponentCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXC-2.3 : ComponentCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to RXC-2.1 or .2 not being null, if subfield 4 or 5 is not&lt;br&gt;
null, then subfields 4, 5, and 6 will be parsed into the Code, Description,&lt;br&gt;
and CodeSystem, respectively, of a PriorCode in the list of PriorCodes. In&lt;br&gt;
this case, the PriorCode Type is set to "A".&lt;br&gt;
HL7:  RXC-2.4 : ComponentCode.AlternateIdentifier&lt;br&gt;
HL7:  RXC-2.5 : ComponentCode.AlternateText&lt;br&gt;
HL7:  RXC-2.6 : ComponentCode.NameofAlternateCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  RXC-2.9 : ComponentCode.OriginalText&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.StrengthQty&lt;br&gt;
HL7:  RXC-5 : ComponentStrength&lt;br&gt;
VIEWERLIB: User.HS.PHCFormDoseEquiv(EQQty)&lt;br&gt;
.StrengthUnits&lt;br&gt;
HL7:  RXC-6 : ComponentStrengthUnits&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.PHCFormDoseEquiv(EQCTUOMDR)&lt;br&gt;
.StrengthUnits.Code&lt;br&gt;
HL7:  RXC-6.1 : ComponentStrengthUnits.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMCode)&lt;br&gt;
.StrengthUnits.Description&lt;br&gt;
HL7:  RXC-6.2 : ComponentStrengthUnits.Text&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMDesc)&lt;br&gt;
.StrengthUnits.SDACodingStandard&lt;br&gt;
HL7:  RXC-6.3 : ComponentStrengthUnits.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.BaseQty&lt;br&gt;
HL7:  RXC-8 : ComponentDrugStrengthVolume&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgForm(PHCDFBaseQty)&lt;br&gt;
.BaseUnits&lt;br&gt;
HL7:  RXC-9 : ComponentDrugStrengthVolumeUnits&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgForm(PHCDFCTUOMDR)&lt;br&gt;
.BaseUnits.Code&lt;br&gt;
HL7:  RXC-9.1 : ComponentDrugStrengthVolumeUnits.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMCode)&lt;br&gt;
.BaseUnits.Description&lt;br&gt;
HL7:  RXC-9.2 : ComponentDrugStrengthVolumeUnits.Text&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMDesc)&lt;br&gt;
.BaseUnits.SDACodingStandard&lt;br&gt;
HL7:  RXC-9.3 : ComponentDrugStrengthVolumeUnits.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultCopiesTo" type="ArrayOfCareProvider">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Specimen">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="SpecimenCollectedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenReceivedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="MedicationExtension"/>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Optional scope used to qualify ActionCode "I" or "C"&lt;br&gt;
May be "ADMISSION", "DISCHARGE", "ADMINISTERED", "MEDICATIONS", or null.&lt;br&gt;
For any other value, an error will be logged and the streamlet will not be&lt;br&gt;
processed. If a valid, non-null ActionScope is given, then only Medications&lt;br&gt;
with a matching (case-insensitive) value for PharmacyStatus will be&lt;br&gt;
inactivated or cleared. If ActionScope is null, then every matching&lt;br&gt;
Medication will be deleted. See the annotation on the superclass property&lt;br&gt;
for more information on how ActionScope is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DrugProduct">
    <s:annotation>
        <s:documentation>Despite having several extended properties, DrugProduct is still only&lt;br&gt;
matched on Code, Description, and SDACodingStandard in the Viewer Cache.&lt;br&gt;
Properties of the PHCDrgMast will only be set on add or if an inbound&lt;br&gt;
DrugProduct matches an existing PHCDrgMast, but not exactly (capitalization&lt;br&gt;
of Code or Description differs, for example). Properties of the PHCDrgForm&lt;br&gt;
(besides match properties) are always updated when a DrugProduct is&lt;br&gt;
inserted into the Viewer Cache. Properties of the PHCFormDoseEquiv are&lt;br&gt;
included in the matching on PHCDrgForm, so will never be updated, only&lt;br&gt;
inserted.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DrugProductExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCDrgMast(PHCDCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCDrgMast(PHCDName)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="BaseQty" type="Numeric">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as a Package, this is the quantity (per&lt;br&gt;
dispensing unit) that will be dispensed. For example, BaseQty=3,&lt;br&gt;
BaseUnits=ml, PackageSize=4, PackageSizeUnits=syringes could be a&lt;br&gt;
dispensing unit of a strip of 4x3ml syringes.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(PHCDFBaseQty)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="BaseUnits" type="UoM">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as a package, this is the units of the&lt;br&gt;
BaseQty that will be dispensed. For example, BaseQty=3, BaseUnits=ml,&lt;br&gt;
PackageSize=4, PackageSizeUnits=syringes could be a dispensing unit of a&lt;br&gt;
strip of 4x3ml syringes.&lt;br&gt;&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(PHCDFCTUOMDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ProductName">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as a package, this is the full name or&lt;br&gt;
description of the package.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDProductName)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OfficialCode">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as a package, this is the official (e.g.&lt;br&gt;
government or standard) ID of the package.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDOfficialCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PackageSize" type="Numeric">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as a package, this is the number of items&lt;br&gt;
in the package. For example, BaseQty=3, BaseUnits=ml, PackageSize=4,&lt;br&gt;
PackageSizeUnits=syringes could be a dispensing unit of a strip of 4x3ml&lt;br&gt;
syringes.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(PHCDFPackageSizeQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PackageSizeUnits" type="PackageSizeUoM">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as a package, this is the units of the&lt;br&gt;
items in the package. For example, BaseQty=3, BaseUnits=ml, PackageSize=4,&lt;br&gt;
PackageSizeUnits=syringes could be a dispensing unit of a strip of 4x3ml&lt;br&gt;
syringes.&lt;br&gt;&lt;br&gt;
SDATableName=PackageSizeUoM, ViewerClass=User.HS.PHCPack&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(PHCDFPHCPADR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Type" type="DrugProductType">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as an individual product, this is the type&lt;br&gt;
of product.&lt;br&gt;&lt;br&gt;
SDATableName=DrugProductType, ViewerClass=User.HS.PHCType&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDTypeDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Form" type="DrugProductForm">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as an individual product or as a&lt;br&gt;
substitute (generic) product, this is the form of the product.&lt;br&gt;&lt;br&gt;
SDATableName=DrugProductForm, ViewerClass=User.HS.PHCForm&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(PHCDFPHCFDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Identifier1">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as an individual product, this is an&lt;br&gt;
alternative identifier for the product.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(PHCDFOfficialCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Identifier2">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as an individual product, this is an&lt;br&gt;
alternative identifier for the product.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(PHCDFRegionCodeFDB)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ATCCode" type="ATCCode">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as an individual product, this is the ATC&lt;br&gt;
(Anatomic Therapeutic Chemical) code for the product.&lt;br&gt;&lt;br&gt;
SDATableName=ATCCode, ViewerClass=User.HS.PHCSubCat&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDPHCSCDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="StrengthQty" type="Numeric">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as an individual product, this is the&lt;br&gt;
quantity part of the strength of the product.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(ChildPHCFormDoseEquiv)-&gt;User.HS.PHCFormDoseEquiv(EQQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="StrengthUnits" type="UoM">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as an individual product, this is the&lt;br&gt;
units part of the strength of the product.&lt;br&gt;&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(ChildPHCFormDoseEquiv)-&gt;User.HS.PHCFormDoseEquiv(EQCTUOMDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Strength" type="Strength">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as a substitute (generic) product, this is&lt;br&gt;
the strength (group) of the product.&lt;br&gt;&lt;br&gt;
SDATableName=Strength, ViewerClass=User.HS.PHCStrength
VIEWERLIB: User.HS.PHCDrgMast(ChildPHCDrgForm)-&gt;User.HS.PHCDrgForm(PHCDFPHCSDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Generic" type="Generic">
            <s:annotation>
                <s:documentation>If the DrugProduct is dispensed as a substitute (generic) product, this is&lt;br&gt;
the active substance of the product.&lt;br&gt;&lt;br&gt;
SDATableName=Generic, ViewerClass=User.HS.PHCGeneric&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDGenericDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="LabelName">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCDrgMast(PHCDLabelName1)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="DispensedQuantity" type="Numeric">
            <s:annotation>
                <s:documentation>The quantity of the drug product that was dispensed</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DrugProductExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PackageSizeUoM">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PackageSizeUoMExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCPack(PHCPACode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCPack(PHCPADesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PackageSizeUoMExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DrugProductType">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DrugProductTypeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCType(PHCPTCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCType(PHCPTDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DrugProductTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DrugProductForm">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DrugProductFormExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCForm(PHCFCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCForm(PHCFDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DrugProductFormExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Strength">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="StrengthExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCStrength(PHCSCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCStrength(PHCSDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="StrengthExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Generic">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="GenericExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCGeneric(PHCGECode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCGeneric(PHCGEName)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="GenericExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="RateUnits">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="RateUnitsExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.OECSpeedFlowRate(SFRCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.OECSpeedFlowRate(SFRDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="RateUnitsExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DosageForm">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DosageFormExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCDosage(PHCDOCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.PHCDosage(PHCDODesc1)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DosageFormExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Route">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="RouteExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.OECRoute(ROUTECode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.OECRoute(ROUTEDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="RouteExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfDosageStep">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="DosageStep" nillable="true" type="DosageStep"/>
    </s:sequence>
</s:complexType>
<s:complexType name="DosageStep">
    <s:annotation>
        <s:documentation>This class represents each dosage step for a Medication or Vaccination.&lt;br&gt;
There may be only one step, where the drug is prescribed with just one&lt;br&gt;
dosage, or there can be several steps, such 20mg QID for 3 days, then 10mg&lt;br&gt;
BID for 5 days. DosageSteps are captured in snapshot mode.  This means that&lt;br&gt;
any time DosageSteps are passed in for a Medication or Vaccination, the&lt;br&gt;
existing list is cleared before the inbound DosageSteps are saved.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time updated or entered.  For labs, this represents when the order was&lt;br&gt;
placed.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="DosageStepExtension"/>
        <s:element minOccurs="0" name="TextInstruction" type="s:string">
            <s:annotation>
                <s:documentation>Text instructions/directions&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIDepProcNotes is also where the TextInstruction of the parent order is&lt;br&gt;
stored. However, if the TextInstruction of the first DosageStep in the list&lt;br&gt;
is not null, it will overwrite this value.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDepProcNotes)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ChildOEOrdExec)-&gt;User.HS.OEOrdExec(OEOREDesc)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Frequency" type="Frequency">
            <s:annotation>
                <s:documentation>How often (e.g. Code=QID, Desc=QID, Factor=4)&lt;br&gt;
QID is Latin, meaning 4x a day.  BID means 2x day, etc.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIPHFreqDR is also where the Frequency of the parent order is stored.&lt;br&gt;
However, if the Frequency of the first DosageStep in the list is not null,&lt;br&gt;
it will overwrite this value.&lt;br&gt;&lt;br&gt;
SDATableName=Frequency, ViewerClass=User.HS.PHCFreq&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPHFreqDR)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ChildOEOrdExec)-&gt;User.HS.OEOrdExec(OEOREPHCFreqDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DoseQuantity" type="Numeric">
            <s:annotation>
                <s:documentation>Size of dose (e.g. the 20 in 20mg)&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIDoseQty is also where the DoseQuantity of the parent order is stored.&lt;br&gt;
However, if the DoseQuantity of the first DosageStep in the list is not&lt;br&gt;
null, it will overwrite this value.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDoseQty)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ChildOEOrdExec)-&gt;User.HS.OEOrdExec(OEOREPhQtyOrd)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DoseUoM" type="UoM">
            <s:annotation>
                <s:documentation>Units for DoseQuantity (e.g. the mg in 20mg)&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIUnitDR is also where the DoseUoM of the parent order is stored.&lt;br&gt;
However, if the DoseUoM of the first DosageStep in the list is not null, it&lt;br&gt;
will overwrite this value.&lt;br&gt;&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUnitDR)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ChildOEOrdExec)-&gt;User.HS.OEOrdExec(OEORECTUOMDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Duration" type="Duration">
            <s:annotation>
                <s:documentation>Duration of the step (e.g. input could be start time and duration)&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIDuratDR is also where the Duration of the parent order is stored.&lt;br&gt;
However if the Duration of the first DosageStep in the list is not null, it&lt;br&gt;
will overwrite this value.&lt;br&gt;&lt;br&gt;
SDATableName=Duration, ViewerClass=User.HS.PHCDuration&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDuratDR)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ChildOEOrdExec)-&gt;User.HS.OEOrdExec(OEOREPHCDurationDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The Start Date/Time of the step&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORISttDat and OEORISttTim are where the FromTime of the parent order is&lt;br&gt;
stored. However if the FromTime of the first DosageStep in the list is not&lt;br&gt;
null, it will overwrite these values.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORISttDat) + User.HS.OEOrdItem(OEORISttTim)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ChildOEOrdExec)-&gt;User.HS.OEOrdExec(OEOREExSttDat)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ChildOEOrdExec)-&gt;User.HS.OEOrdExec(OEOREExSttTim)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The End Date/Time of the step&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIEndDat and OEORIEndTim are where the ToTime of the parent order is&lt;br&gt;
stored. However if the ToTime of the first DosageStep in the list is not&lt;br&gt;
null, it will overwrite these values.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEndDat) + User.HS.OEOrdItem(OEORIEndTim)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ChildOEOrdExec)-&gt;User.HS.OEOrdExec(OEOREExEnDat)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ChildOEOrdExec)-&gt;User.HS.OEOrdExec(OEOREExEnTim)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="DosageStepExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfAdministration">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Administration" nillable="true" type="Administration"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Administration">
    <s:annotation>
        <s:documentation>Administration appears in the SDA as a list property (Administrations) of&lt;br&gt;
HS.SDA3.Medication and HS.SDA3.Vaccination. Administrations are not loaded&lt;br&gt;
into the Viewer Cache.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AdministrationExtension"/>
        <s:element minOccurs="0" name="AdministrationNotes" type="s:string">
            <s:annotation>
                <s:documentation>Notes on the administration&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXA-9 is a coded, repeating field. For each non-null instance of the field,&lt;br&gt;
HL7ToSDA3 will parse Text (piece 2), or Identifier (piece 1) if Text is&lt;br&gt;
null, on a new, CRLF-delimited line.&lt;br&gt;&lt;br&gt;
HL7:  RXA-9 : AdministrationNotes&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AdministeringProvider" type="CareProvider">
            <s:annotation>
                <s:documentation>Care provider who did the administration&lt;br&gt;&lt;br&gt;
HL7:  RXA-10 : AdministeringProvider&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  RXA-10.2.1 : FamilyNameSurname&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  RXA-10.3 : GivenName&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  RXA-10.4 : MiddleName&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  RXA-10.6 : NamePrefix&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  RXA-10.7 : Degree&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AdministeredAtLocation" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>The location at which the administration took place.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXA-11.1 is parsed to the AdministeredAtLocation Code. HL7ToSDA3 does not&lt;br&gt;
set the Description.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
HL7:  RXA-11.1 : AdministeredatLocation.PointOfCare
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AdministrationStatus" type="AdministrationStatus">
            <s:annotation>
                <s:documentation>The completion status of the administration&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXA-20 is parsed to the AdministrationStatus Code. HL7ToSDA3 does not set&lt;br&gt;
the Description.&lt;br&gt;&lt;br&gt;
HL7:  RXA-20 : CompletionStatus&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AdministeredAmount" type="s:string">
            <s:annotation>
                <s:documentation>The amount of medication administered&lt;br&gt;&lt;br&gt;
HL7:  RXA-6 : AdministeredAmount&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AdministeredUnits" type="s:string">
            <s:annotation>
                <s:documentation>The number of units of medication administered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXA-7 is a coded field. HL7ToSDA3 will get the value from Text (subfield&lt;br&gt;
2), or Identifier (subfield 1) if Text is null.&lt;br&gt;&lt;br&gt;
HL7:  RXA-7 : AdministeredUnits&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="LotNumber" type="s:string">
            <s:annotation>
                <s:documentation>The lot number of the medication administered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though RXA-15 is a repeating field, HL7ToSDA3 will only use the first&lt;br&gt;
instance.&lt;br&gt;&lt;br&gt;
HL7:  RXA-15 : SubstanceLotNumber&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExpiryDate" type="TimeStamp">
            <s:annotation>
                <s:documentation>The expiry date of the medication administered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though RXA-16 is a repeating field, HL7ToSDA3 will only use the first&lt;br&gt;
instance.&lt;br&gt;&lt;br&gt;
HL7:  RXA-16.1 : SubstanceExpirationDate.Time&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ManufacturerName">
            <s:annotation>
                <s:documentation>The manufacturer of the medication administered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though RXA-17 is a repeating field, HL7ToSDA3 will only use the first&lt;br&gt;
non-null instance. RXA-17 is also a coded field. HL7ToSDA3 will use Text&lt;br&gt;
(piece 2), or Identifier (piece 1) if Text is null.&lt;br&gt;&lt;br&gt;
HL7:  RXA-17 : SubstanceManufacturerName&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="RefusalReason" type="RefusalReason">
            <s:annotation>
                <s:documentation>Substance/Treatment Refusal Reason&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXA-18 will only be parsed if subfield 1 is not null.&lt;br&gt;&lt;br&gt;
HL7:  RXA-18 : SubstanceTreatmentRefusalReason&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXA-18.1 : SubstanceTreatmentRefusalReason.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXA-18.2 : SubstanceTreatmentRefusalReason.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXA-18.3 : SubstanceTreatmentRefusalReason.NameofCodingSystem&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AdministrationSite" type="AdministrationSite">
            <s:annotation>
                <s:documentation>Location a vaccine was administered (e.g. Left Arm)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXR-2 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  RXR-2 : AdministrationSite&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXR-2.1 : AdministrationSite.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXR-2.2 : AdministrationSite.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXR-2.3 : AdministrationSite.NameofCodingSystem&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7:  RXA-22.1 : SystemEntryDateTime.Time&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start time of administration of medication&lt;br&gt;&lt;br&gt;
HL7:  RXA-3.1 : DateTimeStartofAdministration.Time&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End time of administration of medication&lt;br&gt;&lt;br&gt;
HL7:  RXA-4.1 : DateTimeEndofAdministration.Time&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AdministrationExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AdministrationStatus">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="AdministrationStatusExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="AdministrationStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="RefusalReason">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="RefusalReasonExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="RefusalReasonExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AdministrationSite">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="AdministrationSiteExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="AdministrationSiteExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfDrugProduct">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="DrugProduct" nillable="true" type="DrugProduct"/>
    </s:sequence>
</s:complexType>
<s:complexType name="MedicationExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfVaccination">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Vaccination" nillable="true" type="Vaccination"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Vaccination">
    <s:annotation>
        <s:documentation>HS.SDA3.Vaccination corresponds to the CDA Immunizations section.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="PlacerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the PlacerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId. If the PlacerId, FillerId, ExternalId, and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the LabOrder&lt;br&gt;
will not be processed. If the LabOrder has no OrderItem and does not match&lt;br&gt;
exactly 1 other LabOrder in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId, which itself may have been&lt;br&gt;
defaulted to the Result ExternalId. If PlacerId, FillerId, ExternalId and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the Order will&lt;br&gt;
not be processed. If the Order has no OrderItem and does not match exactly&lt;br&gt;
1 other Order of the same type in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the Order will not be processed.&lt;br&gt;
-MED,VXU:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId. If the Order has no OrderItem&lt;br&gt;
or DrugProduct and does not match exactly 1 other Order of the same type in&lt;br&gt;
the same Encounter on PlacerId (ALPHAUP collated), an error will be logged&lt;br&gt;
and the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPlacerNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-2 will be used if a value can be parsed from it, else ORC-2 will be&lt;br&gt;
used. In either case, PlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the FillerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId, then to PlacerId, which itself&lt;br&gt;
may have been defaulted to ExternalId. If FillerId, PlacerId, ExternalId,&lt;br&gt;
and Result.ExternalId are all null, an error will be logged and the&lt;br&gt;
LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId. If FillerId, PlacerId,&lt;br&gt;
ExternalId, and Result.ExternalId are all null, an error will be logged and&lt;br&gt;
the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId. Also for LabOrders only, the stored&lt;br&gt;
value for FillerId in the Viewer Cache is required to be unique. If an&lt;br&gt;
inbound LabOrder.FillerId matches one already in the Viewer Cache (if the&lt;br&gt;
same patient record has been loaded multiple times, for example), the&lt;br&gt;
inbound value is made unique by appending "x[OEORDId]" to it, where&lt;br&gt;
"[OEORDId]" is the ID of the parent OEOrder to the OEOrdItem that the&lt;br&gt;
LabOrder is stored as.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIFillerNo)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabEpisodeNo)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3 will be used if a value can be parsed from it, else ORC-3 will be&lt;br&gt;
used. In either case, FillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OrderItem" type="Order">
            <s:annotation>
                <s:documentation>What was ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-4 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Medications and Vaccinations, in the OnBeforeMatch method of the&lt;br&gt;
Streamlet class, if the Order has no OrderItem but does have a DrugProduct,&lt;br&gt;
then an OrderItem will be defaulted in with Code, Description, and&lt;br&gt;
SDACodingStandard copied from the DrugProduct. For all types of Orders (and&lt;br&gt;
for Medications and Vaccinations, following this defaulting), if the Order&lt;br&gt;
has no OrderItem and does not match exactly 1 other Order of the same type&lt;br&gt;
in the same Encounter on PlacerId (ALPHAUP collated), an error will be&lt;br&gt;
logged and the Order will not be processed. In the OnValidate method, if&lt;br&gt;
the Order does not have an OrderItem (if it was deleted in an update, for&lt;br&gt;
example), an error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7: OBR-4 : UniversalServiceIdentifier&lt;br&gt;
SDATableName=Order, ViewerClass=User.HS.ARCItmMast&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItmMastDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
Viewer cache:&lt;br&gt;
TRName is for text results only.&lt;br&gt;
HL7:  OBR-4.1 : UniversalServiceIdentifier.Identifier&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMCode)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRName)&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-4.2 : UniversalServiceIdentifier.Text&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-4.3 : UniversalServiceIdentifier.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-4.7 : UniversalServiceIdentifier.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to subfield 1 or 2 not being null, if subfield 4 or 5 is not&lt;br&gt;
null, then subfields 4, 5, 6, and 8 will be parsed into the Code,&lt;br&gt;
Description, CodeSystem, and CodeSystemVersionId, respectively, of a&lt;br&gt;
PriorCode in the list of PriorCodes. In this case, the PriorCode Type is&lt;br&gt;
set to "A".&lt;br&gt;
HL7:  OBR-4.4 : UniversalServiceIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-4.5 : UniversalServiceIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-4.6 : UniversalServiceIdentifier.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-4.8 : UniversalServiceIdentifier.AlternateCodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  OBR-4.9 : UniversalServiceIdentifier.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderCategory" type="OrderCategory">
            <s:annotation>
                <s:documentation>Can be used to group orders in the Clinical Viewer.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-24 is parsed to the OrderCategory Code. HL7ToSDA3 does not set the&lt;br&gt;
Description. The parsed value is converted to uppercase in the SDA.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For all Order types, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order has an OrderCategory, then the InfoSubType of the streamlet is&lt;br&gt;
set to the OrderCategory Code, converted to uppercase.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The OrderCategory is stored as a property of the ARCItmMast (OrderItem),&lt;br&gt;
which is itself a property of the OEOrderItem (Order).&lt;br&gt;&lt;br&gt;
HL7:  OBR-24 : DiagnosticServSectID&lt;br&gt;
SDATableName=OrderCategory, ViewerClass=User.HS.ARCItemCat&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMItemCatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderQuantity" type="s:string">
            <s:annotation>
                <s:documentation>Number of items ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderQuantity is parsed from (in order of precendence) TQ1-2.1, RXE-1.1.1,&lt;br&gt;
OBR-27.1.1, or ORC-7.1.1. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Quantity in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  OBR-27.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  RXE-1.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  TQ1-2.1   : Quantity.Quantity&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>Who placed the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderedBy is parsed from (in order of precendence) OBR-16, RXO-14, RXE-13,&lt;br&gt;
or ORC-12 and -24. Though each of these fields is repeating, for each one&lt;br&gt;
except ORC-24, HL7ToSDA3 will only parse the first non-null instance. For&lt;br&gt;
ORC-24, the instance corresponding to the first non-null instance of ORC-12&lt;br&gt;
will be parsed. ORC-12 and -24 are used in combination to set the&lt;br&gt;
provider's Name and Address in the SDA. Every other field only sets the&lt;br&gt;
Name. For Adress.City, .State, .Zip, .Country, and .County as well as NameTypeCode&lt;br&gt;
and IdentifierTypeCode, only the Code is parsed. HL7ToSDA3 does not set the&lt;br&gt;
Description. Note that an RDE_O11 message technically can contain both an&lt;br&gt;
RXO segment and an RXE, however HL7ToSDA3 does not parse the RXO segment&lt;br&gt;
from an RDE message.&lt;br&gt;&lt;br&gt;
HL7:  ORC-12 : OrderingProvider&lt;br&gt;
HL7:  ORC-24 : OrderingProviderAddress&lt;br&gt;
HL7:  RXE-13 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  RXO-14 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  OBR-16 : OrderingProvider&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDoctorDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-12.1 : OrderingProvider.IDNumber&lt;br&gt;
HL7:  RXE-13.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  RXO-14.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  OBR-16.1 : OrderingProvider.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-12.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
HL7:  RXE-13.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  RXO-14.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  OBR-16.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-12.4 : OrderingProvider.MiddleName&lt;br&gt;
HL7:  RXE-13.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  RXO-14.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  OBR-16.4 : OrderingProvider.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-12.6 : OrderingProvider.NamePrefix&lt;br&gt;
HL7:  RXE-13.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  RXO-14.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  OBR-16.6 : OrderingProvider.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-24.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-24.1.1.&lt;br&gt;
HL7:  ORC-24.1.1 : OrderingProviderAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-24.2 : OrderingProviderAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPStName)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-24.3 : OrderingProviderAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCityDR)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-24.4 : OrderingProviderAddress.StateorProvince&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-24.5 : OrderingProviderAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-24.6 : OrderingProviderAddress.Country&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-24.9 : OrderingProviderAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.NameTypeCode&lt;br&gt;
HL7:  OBR-16.10 : OrderingProvider.NameTypeCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.IdentifierTypeCode&lt;br&gt;
HL7:  OBR-16.13 : OrderingProvider.IdentifierTypeCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteringOrganization" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Entering Facility (Location)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-13 is only parsed if subfield 1 is not null. Only the Code is parsed.&lt;br&gt;
HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
HL7:  ORC-13.1 : EnterersLocation.PointofCare&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIOrdDeptDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Only the Code is parsed. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>VerifiedBy (CareProvider)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-32 will be used if present, else the first non-null instance of ORC-11&lt;br&gt;
will be used, if there is one.&lt;br&gt;&lt;br&gt;
HL7:  ORC-11 : VerifiedBy&lt;br&gt; 
HL7:  OBR-32 : PrincipalResultInterpreter&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthoriseClinicianDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-11.1 : VerifiedBy.IDNumber&lt;br&gt;
HL7:  OBR-32.1.1 : PrincipalResultInterpreter.Name.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields, the given and family names are concatenated together as&lt;br&gt;
"[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-11.9 : VerifiedBy.AssigningAuthority&lt;br&gt;
HL7:  OBR-32.1.9 : PrincipalResultInterpreter.Name.AssigningAuthorityNamespaceID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-11.4 : VerifiedBy.SecondandFurtherGivenNames&lt;br&gt;
HL7:  OBR-32.1.4 : PrincipalResultInterpreter.Name.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-11.6 : VerifiedBy.Prefix&lt;br&gt;
HL7:  OBR-32.1.6 : PrincipalResultInterpreter.Name.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  ORC-11.7 : VerifiedBy.Degree&lt;br&gt;
HL7:  OBR-32.1.5 : PrincipalResultInterpreter.Name.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  OBR-32.1.7 : PrincipalResultInterpreter.Name.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CallbackNumber">
            <s:annotation>
                <s:documentation>Callback number (who to contact with questions, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-17 is used if any regular (business), mobile, or fax numbers or e-mail&lt;br&gt;
addresses can be parsed from it, else ORC-14 is used. In either case, the&lt;br&gt;
format of CallbackNumber is: "[List of business #s], Mobile: [List of&lt;br&gt;
mobile #s], Fax: [List of fax #s], email: [List of e-mail addresses]". Each&lt;br&gt;
list is comma-delimited. Each tag (Mobile, Fax, email) will only be used if&lt;br&gt;
there are elements of that type. For each field, every instance will be&lt;br&gt;
parsed, if that field is used. Up to three numbers can be parsed from each&lt;br&gt;
instance of a field:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, a number is parsed from them&lt;br&gt;
as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-If subfield 12 is not null, it is parsed.&lt;br&gt;
-If subfield 1 is not null, it is parsed.&lt;br&gt;
-Additionally, if subfield 9 is not null, the first number parsed from that&lt;br&gt;
instance will have it appended to the end after a semicolon separator.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;
The logic to determine the type of the number is:&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 is in ["",PH], the&lt;br&gt;
number is a regular (business) number.&lt;br&gt;
-If subfield 2 = "BPN" and subfield 3 is in [CP,BP], the number is a mobile&lt;br&gt;
number.&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 = "FX", the number is&lt;br&gt;
a fax number.&lt;br&gt;
Finally, each non-null instance of subfield 4 is parsed as an e-mail&lt;br&gt;
address.&lt;br&gt;&lt;br&gt;
HL7:  OBR-17 : OrderCallbackPhoneNumber&lt;br&gt;
HL7:  ORC-14 : CallBackPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINotify)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ReassessmentTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>If the Order is not final, this is the date/time when it should be reviewed&lt;br&gt;
and perhaps finalized.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIReassessmentDate) + User.HS.OEOrdItem(OEORIReassessmentTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Frequency" type="Frequency">
            <s:annotation>
                <s:documentation>How often (e.g. Code=QID, Desc=QID, Factor=4)&lt;br&gt;
QID is Latin, meaning 4x a day.  BID means 2x day, etc.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though TQ1-3 is a repeating field, HL7ToSDA3 will only parse the first&lt;br&gt;
non-null instance.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Frequency, then that&lt;br&gt;
Frequency will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-3 : RepeatPattern&lt;br&gt;
SDATableName=Frequency, ViewerClass=User.HS.PHCFreq&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPHFreqDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  TQ1-3.1.1 : RepeatPattern.RepeatPatternCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-3.1.2 : RepeatPattern.RepeatPatternCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7:  TQ1-3.5 : RepeatPattern.PeriodQuantity&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRFactor)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Duration" type="Duration">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Duration is parsed from (in order of precedence) TQ1-6, RXE-1.3, OBR-27.3,&lt;br&gt;
or ORC-7.3. The RXE, OBR, and ORC fields will only set the Duration Code.&lt;br&gt;
TQ1-6 will populate the Code, Description, and Factor as described below.&lt;br&gt;
Though ORC-7 is a repeating field, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance. OBR-27 is also a repeating field, and HL7ToSDA3 parses every&lt;br&gt;
non-null instance of it. The last non-null instance of Duration in OBR-27&lt;br&gt;
is the one that takes precedence. Note that an RDE_O11 message may contain&lt;br&gt;
TQ1 segments in two different places. HL7ToSDA3 parses the one following&lt;br&gt;
the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Duration, then that Duration&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  TQ1-6 : ServiceDuration&lt;br&gt;
SDATableName=Duration, ViewerClass=User.HS.PHCDuration&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDuratDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
When parsing the TQ1-6 field, Code is initially parsed from subfield 2.1&lt;br&gt;
(Units.Identifier). If subfield 1 (Quantity) is not null, then if subfields&lt;br&gt;
2.1 and 2.2 (Units.Text) are null, Code will be parsed from Quantity. Then,&lt;br&gt;
if Quantity starts with a non-zero number and the parsed value for Code&lt;br&gt;
does not, the parsed value for Code is set to +[Quantity]_[Code]. For&lt;br&gt;
example, if Quantity="2" and Units.Identifier="D", the value parsed to Code&lt;br&gt;
is "2D". For the other segments that Duration Code may be parsed from (RXE,&lt;br&gt;
OBR, ORC), the value is simply parsed from the field listed below.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null and +[Quantity] is logically "true",&lt;br&gt;
and if TQ1-6.2.2 (Units.Text) is not null and +[Units.Text] is logically&lt;br&gt;
"false" (basically, if Quantity starts with a number and Units.Text&lt;br&gt;
doesn't), then the value parsed to Description is&lt;br&gt;
+[Quantity]_" "_[Units.Text]. For example, if Quantity="2" and&lt;br&gt;
Units.Text="Days", the value parsed to Description is "2 Days". If these&lt;br&gt;
conditions are not all met then the Description is simply parsed from&lt;br&gt;
TQ1-6.2.2.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null, then if +[Quantity] is logically "true",&lt;br&gt;
Factor is parsed as +[Quantity], otherwise Factor is parsed as null. If&lt;br&gt;
Quantity is null, then if +[TQ1-2.1/Units.Identifier] is logically "true",&lt;br&gt;
Factor is parsed as +[Units.Identifier], else if +[TQ1-2.2/Units.Text] is&lt;br&gt;
logically "true", Factor is parsed as +[Units.Text], else Factor is not&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUFactor)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status">
            <s:annotation>
                <s:documentation>The current status of the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The following values are mapped in the HL7 to SDA3 parsing:&lt;br&gt;
DC-&gt;D, CA-&gt;C, RP-&gt;R, HD-&gt;H, SC-&gt;IP, CM-&gt;E, [Other]-&gt;unchanged&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For any type of Order, in the OnValidate method of the streamlet class, if&lt;br&gt;
Status is null, it is defaulted to "V" for "Verified". Then, for Orders&lt;br&gt;
that can have results (LabOrder, RadOrder, OtherOrder), if the Order has a&lt;br&gt;
Result, Status is set to "E" for "Executed", unless it is "D", "C", "R", or&lt;br&gt;
"H" (for Discontinued, Cancelled, Replaced, or On Hold, respectively). The&lt;br&gt;
reasoning behind setting the Status to "E" is that if the Order has a&lt;br&gt;
Result, then it must have been executed. The reasoning behind the&lt;br&gt;
exceptions to this is that those particular statuses may have been entered&lt;br&gt;
after the Result was submitted. Also, for any type of Order, when Orders of&lt;br&gt;
of that type are inactivated with ActionCode="I", the Status of each will&lt;br&gt;
be set to "I".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Status is stored in the Viewer Cache as an OECOrderStatus with OSTATCode&lt;br&gt;
matching Status, ALPHAUP collated. If no such entry in OECOrderStatus&lt;br&gt;
exists, Status will be stored as V/Verified in the Viewer Cache only and an&lt;br&gt;
alert logged in the Ensemble Event Log. Note that the OECOrderStatus table&lt;br&gt;
is loaded from the SITE- or HS-Default-OrderStatus.txt file at the time the&lt;br&gt;
Access Gateway is reset.&lt;br&gt;&lt;br&gt;
HL7:  ORC-5 : OrderStatus&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.OECOrderStatus&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemStatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Priority" type="Priority">
            <s:annotation>
                <s:documentation>The Priority of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Priority is parsed from (in order of precendence) TQ1-9, RXE-1.6, OBR-27.6,&lt;br&gt;
OBR-5, or ORC-7.6. TQ1-9 may set the Code, Description, and&lt;br&gt;
SDACodingStandard. Every other field only sets the Code. Though TQ1-9 and&lt;br&gt;
ORC-7 are repeating fields, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance of each. OBR-27 is also a repeating field, and HL7ToSDA3 parses&lt;br&gt;
every non-null instance of it. The last non-null instance of Priority in&lt;br&gt;
OBR-27 is the one that takes precedence. Note that an RDE_O11 message may&lt;br&gt;
contain TQ1 segments in two different places. HL7ToSDA3 parses the one&lt;br&gt;
following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order contains no Priority, one is defaulted in with Code="N" and &lt;br&gt;
Description="Normal".&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9   : Priority&lt;br&gt;
SDATableName=Priority, ViewerClass=User.HS.OECPriority&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPriorityDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9.1  : Priority.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-9.2  : Priority.Text&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  TQ1-9.3  : Priority.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConfidentialityCode" type="Confidentiality">
            <s:annotation>
                <s:documentation>Confidentiality code (e.g. VIP, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-28 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-28 : ConfidentialtyCode&lt;br&gt;
SDATableName=Confidentiality, ViewerClass=User.HS.OECOverReasonNonConsent&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINoConsentOverrideReasDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-28.1 : ConfidentialtyCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-28.2 : ConfidentialtyCode.Text&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-28.3 : ConfidentialtyCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Condition">
            <s:annotation>
                <s:documentation>Condition, e.g. "keep BP below 110"&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Condition is parsed from (in order of precendence) TQ1-10, RXE-1.7,&lt;br&gt;
OBR-27.7, or ORC-7.7. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Condition in OBR-27 is the one that takes precendence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  OBR-27.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  RXE-1.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  TQ1-10  : ConditionText&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILtClinicalCondition)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="TextInstruction" type="s:string">
            <s:annotation>
                <s:documentation>Text instructions or directions, e.g. "After food", or if Duration etc.&lt;Br&gt;
isn't coded, "Take 3 twice a day"&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
TextInstruction is parsed from (in order of precendence) TQ1-11, RXE-1.8,&lt;br&gt;
OBR-27.8, or ORC-7.8. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Text in OBR-27 is the one that takes precendence. Note that an RDE_O11&lt;br&gt;
message may contain TQ1 segments in two different places. HL7ToSDA3 parses&lt;br&gt;
the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a TextInstruction, then that&lt;br&gt;
TextInstruction will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.8 : QuantityTiming.Text&lt;br&gt;
HL7:  OBR-27.8 : QuantityTiming.Text&lt;br&gt;
HL7:  RXE-1.8 : QuantityTimingText&lt;br&gt;
HL7:  TQ1-11  : TextInstruction&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDepProcNotes)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderGroup" type="s:string">
            <s:annotation>
                <s:documentation>This is a way to group related Orders together, such as a prescription&lt;br&gt;
chain.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemGroup)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Order Comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Order Comments are always parsed from NTE segments, though HL7 order&lt;br&gt;
messages may contain NTEs in different places, and only certain ones are&lt;br&gt;
parsed to Order Comments. For ORM and OMP messages, it is the first set of&lt;br&gt;
NTEs following the ORC (in the message schema, not necessarily in the&lt;br&gt;
message) that are parsed to Comments.  In an RDE message the set of NTEs&lt;br&gt;
following the RXE segment are parsed to Order Comments. Order Comments can&lt;br&gt;
only be parsed from an ORU message if it contains a text result (either&lt;br&gt;
ORC-29 is not "LAB", or all OBX-2 values = "FT", "TX", or "ED"). In this&lt;br&gt;
case the NTEs immediately following the OBR are parsed to Order Comments.&lt;br&gt;
In an ORU containing atomic lab results, the NTEs following the OBR are&lt;br&gt;
parsed to the Result Comments, and in an ORU containing Observations&lt;br&gt;
(ORC-29="OBS"), these NTEs are not parsed.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRemarks)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConsultationDepartment" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Department or facility that consulted&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIConsultDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AuthorizationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the order was authorized&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthorisedDate) + User.HS.OEOrdItem(OEORIAuthorisedTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReceivingLocation" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Location or facility receiving/performing the order&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRecDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedComments" type="s:string">
            <s:annotation>
                <s:documentation>Verified order comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthComments)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupId" type="s:string">
            <s:annotation>
                <s:documentation>If this item was ordered as part of a group, this is the identifier of that&lt;br&gt;
group. The SDA2-to-SDA3 transform populates this field with the SDA2&lt;br&gt;
ExternalId property.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.1 : PlacerGroupNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILab1)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupAssigningAuthority" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
GroupAssigningAuthority is composed of subfields 2, 3, and 4 concatenated&lt;br&gt;
together as "[.2]^[.3]^[.4]", but only if at least one of these is not&lt;br&gt;
null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.2: PlacerGroupNumber.NamespaceID&lt;br&gt;
HL7:  ORC-4.3: PlacerGroupNumber.UniversalID&lt;br&gt;
HL7:  ORC-4.4: PlacerGroupNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate all orders of this type (set Status="I")&lt;br&gt;
C = Clear/delete all orders of this type&lt;br&gt;
R = Replace - Applies only to Atomic Result Items.  Clears previous result items before storing all new items,
ignoring matching on test item code.  &lt;b&gt;Use ONLY when always receiving full updates.  Using this with
partial updates may cause a loss of test item data.&lt;/b&gt;&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation of the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in ORC-1 will be parsed as ActionCode="I", while&lt;br&gt;
four double quotes ("""") will be parsed as ActionCode="C". &lt;br&gt;
ActionCode="R" in ORC-1 will impact parsing of TestItemCode.  See the
TestItemCode property of HS.SDA3.LabResultItem for details.&lt;br&gt;
Any other value will not be parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-1 : OrderControl&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Only used for Medications, see the annotation in HS.SDA3.Medication.&lt;br&gt;
Otherwise ActionScope is not used for Orders.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-10 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-10 : EnteredBy&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserUpdate)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-10.1 : EnteredBy.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-10.2.1 : EnteredBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-10.3 : EnteredBy.GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-10.9 : EnteredBy.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-21 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed. ORC-22 is also a repeating field, however HL7ToSDA3 will only parse&lt;br&gt;
the instance corresponding to the instance of ORC-21 parsed. For example,&lt;br&gt;
if the third instance of ORC-21 is parsed (because the first two are null),&lt;br&gt;
then the third instance of ORC-22 will be parsed as well. For Address.City,&lt;br&gt;
State, Zip, Country, and County only the Code is parsed. HL7ToSDA3 does not&lt;br&gt;
set the Description. Every instance of ORC-23 will be examined but may not&lt;br&gt;
be parsed to the SDA. The algorithm to parse a number out of one instance&lt;br&gt;
of ORC-23 is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else no number can be parsed from this instance.&lt;br&gt;
-Whichever number is parsed, if subfield 9 of that instance is not null, it&lt;br&gt;
will be appended to the number, delimited by a semicolon.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;&lt;br&gt;
HL7:  ORC-21 : OrderingFacilityName&lt;br&gt;
HL7:  ORC-22 : OrderingFacilityAddress&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserAddHospDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-21.10 will be parsed to the Code if present, else ORC-21.3 will.&lt;br&gt;
HL7:  ORC-21.10 : OrderingFacilityName.OrganizationIdentifier&lt;br&gt;
HL7:  ORC-21.3 : OrderingFacilityName.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-21.1 : OrderingFacilityName.OrganizationName&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-21.6 : OrderingFacilityName.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-22.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-22.1.1.&lt;br&gt;
HL7:  ORC-22.1.1 : OrderingFacilityAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-22.2 : OrderingFacilityAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPAddress)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-22.3 : OrderingFacilityAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCity)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-22.4 : OrderingFacilityAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPProvinceDR)&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-22.5 : OrderingFacilityAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-22.6 : OrderingFacilityAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountryDR)&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-22.9 : OrderingFacilityAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountyParishDR)&lt;br&gt;
.ContactInfo.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
WorkPhoneNumber is parsed from the first instance of ORC-23 with subfield 2&lt;br&gt;
in ["",WPN,ASN,EMR] and subfield 3 in ["",PH] and from which a phone number&lt;br&gt;
can be parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPPhone)&lt;br&gt;
.ContactInfo.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MobilePhoneNumber is parsed from the first instance of ORC-23 with subfield&lt;br&gt;
2 = "BPN" and subfield 3 in [CP,BP] and from which a phone number can be&lt;br&gt;
parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ContactInfo.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
EmailAddress is parsed from the first non-null instance of ORC-23.4.&lt;br&gt;
HL7:  ORC-23.4 : OrderingFacilityPhoneNumber.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPEmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. For Orders than can have&lt;br&gt;
Results (LabOrder, RadOrder, OtherOrder), if the Order actually has a&lt;br&gt;
Result and FromTime, EnteredOn, and Result.ResultTime are all null, an&lt;br&gt;
error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  ORC-9.1 : DateTimeofTransaction.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUpdateDate) + User.HS.OEOrdItem(OEORIUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
FromTime is parsed from (in order of precedence) TQ1-7.1, RXE-1.4,&lt;br&gt;
OBR-27.4, OBR-6.1, or ORC-7.4. Though ORC-7 is a repeating field, HL7ToSDA3&lt;br&gt;
only parses the first non-null instance. OBR-27 is also a repeating field,&lt;br&gt;
and HL7ToSDA3 parses every non-null instance of it. The last non-null&lt;br&gt;
instance of StartDateTime.Time in OBR-27 is the one that takes precedence.&lt;br&gt;
Note that an RDE_O11 message may contain TQ1 segments in two different&lt;br&gt;
places. HL7ToSDA3 parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. Then, if the Order has a&lt;br&gt;
Result and FromTime is still null, it is defaulted to Result.ResultTime.&lt;br&gt;
Finally, if the Order has a Result and FromTime is still null, an error&lt;br&gt;
will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a FromTime, then that FromTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  OBR-6.1 : RequestedDateTime.Time&lt;br&gt;
HL7:  OBR-27.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  RXE-1.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  TQ1-7.1 : StartDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORISttDat) + User.HS.OEOrdItem(OEORISttTim)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ToTime is parsed from (in order of precedence) TQ1-8, RXE-1.5, OBR-27.5,&lt;br&gt;
or ORC-7.5. Though ORC-7 is a repeating field, HL7ToSDA3 only parses the&lt;br&gt;
first non-null instance. OBR-27 is also a repeating field, and HL7ToSDA3&lt;br&gt;
parses every non-null instance of it. The last non-null instance of&lt;br&gt;
EndDateTime.Time in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a ToTime, then that ToTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  OBR-27.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  RXE-1.5.1 : QuantityTiming.EndDateTimeTime&lt;br&gt;
HL7:  TQ1-8.1   : EndDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEndDate) + User.HS.OEOrdItem(OEORIEndTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DrugProduct" type="DrugProduct">
            <s:annotation>
                <s:documentation>What was dispensed - commercial product name&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments, though RXO-6 does take precedence over RXO-1.&lt;br&gt;
For both RXO-1 and RXE-2, the field will only be parsed if subfield 1 or 2&lt;br&gt;
is not null. Though RXO-6 is a repeating field, only the first non-null&lt;br&gt;
instance will be parsed.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if the Order has no&lt;br&gt;
OrderItem but does have a DrugProduct, then a new OrderItem will be&lt;br&gt;
defaulted in with Code, Description, and SDACodingStandard copied from the&lt;br&gt;
DrugProduct.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The OEOrdItem (Order) in the Viewer Cache references an ARCItmMast (Order&lt;br&gt;
Item) via OEORIItmMastDR, which references a PHCDrgForm via ARCIMPHCDFDR,&lt;br&gt;
which references a PHCDrgMast (Drug Product) via PHCDFPHCDParRef.&lt;br&gt;
PHCDrgForm is a child of PHCDrgMast, and a PHCDrgMast may have more than&lt;br&gt;
one linked PHCDrgForm. When a DrugProduct is loaded into the Viewer Cache,&lt;br&gt;
it is matched to a PHCDrgMast based on Code, Description, and&lt;br&gt;
SDACodingStandard. Then, the existing child PHCDrgForms of that PHCDrgMast&lt;br&gt;
are examined to find one that matches the DrugProduct on Form, BaseQty,&lt;br&gt;
BaseUnits, Strength, StrengthQty, and StrengthUnits. Form, BaseQty,&lt;br&gt;
BaseUnits, and Strength are stored as properties of the PHCDrgForm.&lt;br&gt;
StrengthQty and StrengthUnits are stored as properties of a&lt;br&gt;
PHCFormDoseEquiv, which is a child of PHCDrgForm, though in the Viewer&lt;br&gt;
Cache a PHCDrgForm should only ever have one child PHCFormDoseEquiv. If no&lt;br&gt;
matching child PHCDrgForm can be found, a new one is created (along with a&lt;br&gt;
child PHCFormDoseEquiv) from the properties of the DrugProduct. Once a&lt;br&gt;
matching PHCDrgForm is found or a new one created, an attempt is made to&lt;br&gt;
link the ARCItmMast to it by setting the ARCIMPHCDFDR property of the&lt;br&gt;
ARCItmMast. If this fails for any reason (for example, if the ARCIMPHCDFDR&lt;br&gt;
property already references a different PHCDrgForm), then a new ARCItmMast&lt;br&gt;
will be created with the original OrderCategory of the Order, the&lt;br&gt;
SDACodingStandard of the DrugProduct, and Code and Description (referencing&lt;br&gt;
properties of the DrugProduct):&lt;br&gt;
"[Description]([Form.Code]:[BaseQty] [BaseUnits.Description]:[StrengthQty] [StrengthUnits.Description]:[Strength.Description])"&lt;br&gt;
Note that it is possible that such an ARCItmMast already exists in the&lt;br&gt;
Viewer Cache, in which case the "new" ARCItmMast will simply match the&lt;br&gt;
existing one. Finally, an attempt is made to link the new ARCItmMast to the&lt;br&gt;
new or matched PHCDrgForm. If this fails for any reason (for example, the&lt;br&gt;
"new" ARCItmMast was not new and was already linked to a different&lt;br&gt;
PHCDrgForm), then an error will be logged and the Order will not be stored&lt;br&gt;
in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  RXO-1 : RequestedGiveCode&lt;br&gt;
HL7:  RXO-6 : ProvidersPharmacyTreatmentInstructions&lt;br&gt;
HL7:  RXA-5 : AdministeredCode&lt;br&gt;
HL7:  RXE-2 : GiveCode&lt;br&gt;
SDATableName=DrugProduct, ViewerClass=User.HS.PHCDrgMast&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItmMastDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-1.1 : RequestedGiveCode.Identifier&lt;br&gt;
HL7:  RXO-6.1 : ProvidersPharmacyTreatmentInstructions.Identifier&lt;br&gt;
HL7:  RXA-5.1 : AdministeredCode.Identifier&lt;br&gt;
HL7:  RXE-2.1 : GiveCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-1.2 : RequestedGiveCode.Text&lt;br&gt;
HL7:  RXO-6.2 : ProvidersPharmacyTreatmentInstructions.Text&lt;br&gt;
HL7:  RXA-5.2 : AdministeredCode.Text&lt;br&gt;
HL7:  RXE-2.2 : GiveCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-1.3 : RequestedGiveCode.NameofCodingSystem&lt;br&gt;
HL7:  RXO-6.3 : ProvidersPharmacyTreatmentInstructions.NameofCodingSystem&lt;br&gt;
HL7:  RXA-5.3 : AdministeredCode.NameofCodingSystem&lt;br&gt;
HL7:  RXE-2.3 : GiveCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For each field, the logic to parse PriorCodes is the same: if subfield 4 or&lt;br&gt;
5 is not null, then subfields 4, 5, and 6 will be parsed into the Code,&lt;br&gt;
Description, and CodeSystem, respectively, of a PriorCode in the list of&lt;br&gt;
PriorCodes. In this case, the PriorCode Type is set to "A". Note that for&lt;br&gt;
RXO-1 and RXE-2, subfield 1 or 2 must still be non-null for anything in the&lt;br&gt;
field to be parsed.&lt;br&gt;
HL7:  RXO-1.4 : RequestedGiveCode.AlternateIdentifier&lt;br&gt;
HL7:  RXO-1.5 : RequestedGiveCode.AlternateText&lt;br&gt;
HL7:  RXO-1.6 : RequestedGiveCode.NameofAlternateCodingSystem&lt;br&gt;
HL7:  RXO-6.4 : ProvidersPharmacyTreatmentInstructions.AlternateIdentifier&lt;br&gt;
HL7:  RXO-6.5 : ProvidersPharmacyTreatmentInstructions.AlternateText&lt;br&gt;
HL7:  RXO-6.6 : ProvidersPharmacyTreatmentInstructions.NameofAlternateCodingSystem&lt;br&gt;
HL7:  RXA-5.4 : AdministeredCode.AlternateIdentifier&lt;br&gt;
HL7:  RXA-5.5 : AdministeredCode.AlternateText&lt;br&gt;
HL7:  RXA-5.6 : AdministeredCode.NameofAlternateCodingSystem&lt;br&gt;
HL7:  RXE-2.4 : GiveCode.AlternateIdentifier&lt;br&gt;
HL7:  RXE-2.5 : GiveCode.AlternateText&lt;br&gt;
HL7:  RXE-2.6 : GiveCode.NameofAlternateCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  RXO-1.9 : RequestedGiveCode.OriginalText&lt;br&gt;
HL7:  RXO-6.9 : ProvidersPharmacyTreatmentInstructions.OriginalText&lt;br&gt;
HL7:  RXA-5.9 : AdministeredCode.OriginalText&lt;br&gt;
HL7:  RXE-2.9 : GiveCode.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="StrengthVolume" type="Numeric">
            <s:annotation>
                <s:documentation>Strength volume (e.g. the "10" in 2mg/10ml)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments.&lt;br&gt;&lt;br&gt;
HL7:  RXO-25 : RequestedDrugStrengthVolume&lt;br&gt;
HL7:  RXA-23 : AdministeredDrugStrengthVolume&lt;br&gt;
HL7:  RXE-33 : GiveDrugStrengthVolume&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="StrengthVolumeUnits" type="s:string">
            <s:annotation>
                <s:documentation>Units for StrengthVolume (e.g. ml)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments. Each of these fields is coded, and the logic&lt;br&gt;
to parse each is the same: if subfield 2 is not null, parse that to&lt;br&gt;
StrengthVolumeUnits, else parse subfield 1.&lt;br&gt;&lt;br&gt;
HL7:  RXO-26 : RequestedDrugStrengthVolumeUnits&lt;br&gt;
HL7:  RXA-24 : AdministeredDrugStrengthUnits&lt;br&gt;
HL7:  RXE-34 : GiveDrugStrengthVolumeUnits&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RateAmount" type="Numeric">
            <s:annotation>
                <s:documentation>Rate (e.g. the 100 in 100 ml/hour)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO and RXE segments are mutually exclusive among the message types and&lt;br&gt;
segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between them.&lt;br&gt;&lt;br&gt;
HL7:  RXO-21 : RequestedGiveRateAmount&lt;br&gt;
HL7:  RXE-23 : GiveRateAmount&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORISpeedFlowRate)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RateUnits" type="RateUnits">
            <s:annotation>
                <s:documentation>Units for Rate (e.g. the ml in 100 ml/hour)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments. Each of these fields is coded and will only be&lt;br&gt;
parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  RXO-22 : RequestedGiveRateUnits&lt;br&gt;
HL7:  RXE-24 : GiveRateUnits&lt;br&gt;
SDATableName=RateUnits, ViewerClass=User.HS.OECSpeedFlowRate&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIFlowRateUnitDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-22.1 : RequestedGiveRateUnits.Identifier&lt;br&gt;
HL7:  RXE-24.1 : GiveRateUnits.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECSpeedFlowRate(SFRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-22.2 : RequestedGiveRateUnits.Text&lt;br&gt;
HL7:  RXE-24.2 : GiveRateUnits.Text&lt;br&gt;
VIEWERLIB: User.HS.OECSpeedFlowRate(SFRDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-22.3 : RequestedGiveRateUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXE-24.3 : GiveRateUnits.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RateTimeUnit" type="s:string">
            <s:annotation>
                <s:documentation>Time units (e.g. per hour, as in 100 ml per hour)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments.&lt;br&gt;&lt;br&gt;
HL7:  RXO-17 : RequestedGivePerTimeUnit&lt;br&gt;
HL7:  RXA-12 : AdministeredPerTimeUnit&lt;br&gt;
HL7:  RXE-22 : GivePerTimeUnit&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUnitHrs)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DoseQuantity" type="Numeric">
            <s:annotation>
                <s:documentation>Size of dose (e.g. the 20 in 20mg).&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments, however RXO-18 takes precedence over RXO-2,&lt;br&gt;
and RXE-25 takes precendence over RXE-3.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a DoseQuantity, then that&lt;br&gt;
DoseQuantity will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  RXO-2 : RequestedGiveAmountMinimum&lt;br&gt;
HL7:  RXO-18 : RequestedGiveStrength&lt;br&gt;
HL7:  RXA-13 : AdministeredStrength&lt;br&gt;
HL7:  RXE-3 : GiveAmountMinimum&lt;br&gt;
HL7:  RXE-25 : GiveStrength&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDoseQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DoseUoM" type="UoM">
            <s:annotation>
                <s:documentation>Units for DoseQuantity (e.g. the mg in 20mg)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO and RXE segments are mutually exclusive among the message types and&lt;br&gt;
segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between them, however RXO-19 takes precedence over RXO-4, and&lt;br&gt;
RXE-26 takes precedence over RXE-5. Each of the HL7 fields is coded, and&lt;br&gt;
each one will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a DoseUoM, then that DoseUoM&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  RXO-4 : RequestedGiveUnits&lt;br&gt;
HL7:  RXO-19 : RequestedGiveStrengthUnits&lt;br&gt;
HL7:  RXE-5 : GiveUnits&lt;br&gt;
HL7:  RXE-26 : GiveStrengthUnits&lt;br&gt;
HL7:  RXA-14 : AdministeredStrengthUnits&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUnitDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-4.1 : RequestedGiveUnits.Identifier&lt;br&gt;
HL7:  RXO-19.1 : RequestedGiveStrengthUnits.Identifier&lt;br&gt;
HL7:  RXE-5.1 : GiveUnits.Identifier&lt;br&gt;
HL7:  RXE-26.1 : GiveStrengthUnits.Identifier&lt;br&gt;
HL7:  RXA-14.1 : AdministeredStrengthUnits.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-4.2 : RequestedGiveUnits.Text&lt;br&gt;
HL7:  RXO-19.2 : RequestedGiveStrengthUnits.Text&lt;br&gt;
HL7:  RXE-5.2 : GiveUnits.Text&lt;br&gt;
HL7:  RXE-26.2 : GiveStrengthUnits.Text&lt;br&gt;
HL7:  RXA-14.2 : AdministeredStrengthUnits.Text&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-4.3 : RequestedGiveUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXO-19.3 : RequestedGiveStrengthUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXE-5.3 : GiveUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXE-26.3 : GiveStrengthUnits.NameofCodingSystem&lt;br&gt;
HL7:  RXA-14.3 : AdministeredStrengthUnits.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="MaxDoseQuantity" type="Numeric">
            <s:annotation>
                <s:documentation>Maximum dose quantity&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO and RXE segments are mutually exclusive among the message types and&lt;br&gt;
segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between them.&lt;br&gt;&lt;br&gt;
HL7:  RXO-3 : RequestedGiveAmountMaximum&lt;br&gt;
HL7:  RXE-4 : GiveAmountMaximum&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPRNTotNumberDosesAll)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="NumberOfRefills" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
RXO and RXE segments are mutually exclusive among the message types and&lt;br&gt;
segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between them.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
The type of OEORIMaxRepeats is "%Float", so NumberOfRefills will only be&lt;br&gt;
loaded into OEORIMaxRepeats if it is a valid number according to&lt;br&gt;
$IsValidNum(). In the Viewer, the column of an Order Profile (component&lt;br&gt;
OEOrdItem.ListEMR) that displays OEORIMaxNumberOfRepeats is called&lt;br&gt;
"Repeats" by default. The component name as it appears in the properties&lt;br&gt;
of the column in the Layout Editor is "MaxRep". The column that displays&lt;br&gt;
OEORIMaxRepeats is called "Repeat" by default, component name "Repeat".&lt;br&gt;
The value actually displayed depends on OEORIMaxRepeats and&lt;br&gt;
OEORICurrRepeatNumber (populated by the RefillNumber property in SDA):&lt;br&gt;
-If OEORIMaxRepeats is null, no value is displayed.&lt;br&gt;
-Else if "+[OEORICurrRepeatNumber]" is 0, OEORIMaxRepeats is displayed.&lt;br&gt;
-Else the value displayed is "[OEORICurrRepeatNumber] / [OEORIMaxRepeats]",
 for example: "3 / 10".&lt;br&gt;&lt;br&gt;
HL7:  RXO-13 : NumberOfRefills&lt;br&gt;
HL7:  RXE-12 : NumberOfRefills&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIMaxNumberOfRepeats)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIMaxRepeats)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="DosageForm" type="DosageForm">
            <s:annotation>
                <s:documentation>Dosage Form (e.g. Tablet, Capsule, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO, RXA, and RXE segments are all mutually exclusive among the message&lt;br&gt;
types and segments that HealthShare supports, so there is no need to define&lt;br&gt;
precedence between segments. Each of the HL7 fields is coded, and each one&lt;br&gt;
will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  RXO-5 : RequestedDosageForm&lt;br&gt;
HL7:  RXA-8 : AdministeredDosageForm&lt;br&gt;
HL7:  RXE-6 : GiveDosageForm&lt;br&gt;
SDATableName=DosageForm, ViewerClass=User.HS.PHCDosage&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDosageDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-5.1 : RequestedDosageForm.Identifier&lt;br&gt;
HL7:  RXA-8.1 : AdministeredDosageForm.Identifier&lt;br&gt;
HL7:  RXE-6.1 : GiveDosageForm.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCDosage(PHCDOCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-5.2 : RequestedDosageForm.Text&lt;br&gt;
HL7:  RXA-8.2 : AdministeredDosageForm.Text&lt;br&gt;
HL7:  RXE-6.2 : GiveDosageForm.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDosage(PHCDODesc1)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-5.3 : RequestedDosageForm.NameofCodingSystem&lt;br&gt;
HL7:  RXA-8.3 : AdministeredDosageForm.NameofCodingSystem&lt;br&gt;
HL7:  RXE-6.3 : GiveDosageForm.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Route" type="Route">
            <s:annotation>
                <s:documentation>Instructions for administering drug (e.g. Oral)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXO is mutually exclusive to both RXE and RXR segments among the message&lt;br&gt;
types and segments that HealthShare supports, however an RDE_O11 message&lt;br&gt;
can contain both an RXE and an RXR segment. In this case, RXR-1 takes&lt;br&gt;
precedence over RXE-7. Note that though RXO-7 and RXE-7 are repeating&lt;br&gt;
fields, HL7ToSDA3 will only parse the first non-null instance of each.&lt;br&gt;
RXR-1 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  RXO-7 : ProvidersAdministrationInstructions&lt;br&gt;
HL7:  RXE-7 : ProvidersAdministrationInstructions&lt;br&gt;
HL7:  RXR-1 : Route&lt;br&gt;
SDATableName=Route, ViewerClass=User.HS.OECRoute&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRouteDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXO-7.1 : ProvidersAdministrationInstructions.Identifier&lt;br&gt;
HL7:  RXE-7.1 : ProvidersAdministrationInstructions.Identifier&lt;br&gt;
HL7:  RXR-1.1 : Route.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECRoute(ROUTECode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXO-7.2 : ProvidersAdministrationInstructions.Text&lt;br&gt;
HL7:  RXE-7.2 : ProvidersAdministrationInstructions.Text&lt;br&gt;
HL7:  RXR-1.2 : Route.Text&lt;br&gt;
VIEWERLIB: User.HS.OECRoute(ROUTEDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXO-7.3 : ProvidersAdministrationInstructions.NameofCodingSystem&lt;br&gt;
HL7:  RXE-7.3 : ProvidersAdministrationInstructions.NameofCodingSystem&lt;br&gt;
HL7:  RXR-1.3 : Route.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Indication">
            <s:annotation>
                <s:documentation>The condition or problem for which the drug/treatment was prescribed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Each of the listed HL7 fields is coded and repeating. The logic to parse&lt;br&gt;
each is: only parse the first non-null instance, and within that instance,&lt;br&gt;
if subfield 2 is not null, parse the value from that, else parse the value&lt;br&gt;
from subfield 1.&lt;br&gt;&lt;br&gt;
HL7:  RXO-20 : Indication&lt;br&gt;
HL7:  RXA-19 : Indication&lt;br&gt;
HL7:  RXE-27 : Indication&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(ITM2Indication)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="512"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PharmacyStatus" type="s:string">
            <s:annotation>
                <s:documentation>The status of this prescription&lt;br&gt;
For example, in Sweden, a prescription may go through up to 3 statuses: "O"&lt;br&gt;
for "Planned", "F" for "Prescribed", and "U" for "Refilled".&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Medications only, if ActionCode="I" or "C" and ActionScope is one of&lt;br&gt;
"ADMISSION", "DISCHARGE", "ADMINISTERED", or "MEDICATIONS", case-&lt;br&gt;
insensitive, then only Medications with PharmacyStatus matching ActionScope&lt;br&gt;
(case-insensitive) will be affected.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPharmacyStatus)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PrescriptionNumber">
            <s:annotation>
                <s:documentation>The number or ID assigned to the Prescription or Order&lt;br&gt;&lt;br&gt;
HL7:  RXE-15 : PrescriptionNumber&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPrescNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="RefillNumber" type="Numeric">
            <s:annotation>
                <s:documentation>The current refill repeat number&lt;br&gt;
This could be a sequence number or a full ID for the last refill, if any.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
In the Viewer, the column of an Order Profile (component OEOrdItem.ListEMR)&lt;br&gt;
that displays OEORICurrRepeatNumber is called "Repeat" by default. The&lt;br&gt;
component name as it appears in the properties of the column in the Layout&lt;br&gt;
Editor is "Repeat". The value actually displayed depends on&lt;br&gt;
OEORICurrRepeatNumber and OEORIMaxRepeats (populated by the NumberOfRefills&lt;br&gt;
property in SDA, but only if it is a valid number according to&lt;br&gt;
$IsValidNum()):&lt;br&gt;
-If OEORIMaxRepeats is null, no value is displayed.&lt;br&gt;
-Else if "+[OEORICurrRepeatNumber]" is 0, OEORIMaxRepeats is displayed.&lt;br&gt;
-Else the value displayed is "[OEORICurrRepeatNumber] / [OEORIMaxRepeats]",
 for example: "3 / 10".&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORICurrRepeatNumber)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="RefillDescription">
            <s:annotation>
                <s:documentation>A description of when the order will be refilled&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRepeatDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="DosageSteps" type="ArrayOfDosageStep">
            <s:annotation>
                <s:documentation>Ordered Dosage Steps&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Every DosageStep is stored in the Viewer Cache as a child OEOrdExec to the&lt;br&gt;
parent OEOrdItem. This list is cleared every time a Medication or&lt;br&gt;
Vaccination is updated, and the inbound DosageSteps are inserted. However,&lt;br&gt;
the first DosageStep in the list (assuming there is at least one) will also&lt;br&gt;
populate several properties of the parent OEOrdItem, overriding any values&lt;br&gt;
that came from the containing Medication or Vaccination. These properties&lt;br&gt;
include FromTime, ToTime, TextInstruction, Frequency, DoseQuantity,&lt;br&gt;
DoseUoM, and Duration.&lt;br&gt;&lt;br&gt;
VIEWERLIB: see HS.SDA3.DosageStep&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Administrations" type="ArrayOfAdministration">
            <s:annotation>
                <s:documentation>Administration History&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
From HL7, at most one Administration can be parsed.&lt;br&gt;&lt;br&gt;
HL7:  RXA,RXR&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ComponentMeds" type="ArrayOfDrugProduct">
            <s:annotation>
                <s:documentation>The components of a compound medication&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
RXC, as it appears in an RDE_O11 message, is a repeating segment. Each RXC&lt;br&gt;
will be parsed to one DrugProduct in the ComponentMeds list. RXC-2, -6, and&lt;br&gt;
-9 are all coded fields.  Each will only be parsed if subfield 1 or 2 is&lt;br&gt;
not null.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
Each DrugProduct in the list of ComponentMeds will be loaded into the&lt;br&gt;
Viewer Cache as an OEOrdItem that references the main Order/OEOrdItem via&lt;br&gt;
the OEORIOEORIDR property and is linked to the PHCDrgMast created from the&lt;br&gt;
DrugProduct. The only exception to this is ComponentMed DrugProducts with&lt;br&gt;
Code matching the Code of the main Order DrugProduct. These will not be&lt;br&gt;
processed into the Viewer Cache as they are considered redundant. For those&lt;br&gt;
ComponentMed DrugProducts that are processed into the Viewer Cache, the&lt;br&gt;
OEORIPlacerNo will be populated with the PlacerId of the parent Order,&lt;br&gt;
OEORILabEpisodeNo with the FillerId, and OEORIFillerNo with&lt;br&gt;
"[FillerId]&amp;[sequential #]". The FromTime (OEORISttDat+OEORISttTim), ToTime&lt;br&gt;
(OEORIEndDate+OEORIEndTime), and Status (OEORIItemStatDR) are also copied&lt;br&gt;
from the main Order.&lt;br&gt;&lt;br&gt;
HL7:  RXC-2 : ComponentCode&lt;br&gt;
HL7:  RXC-5 : ComponentStrength&lt;br&gt;
HL7:  RXC-6 : ComponentStrengthUnits&lt;br&gt;
HL7:  RXC-8 : ComponentDrugStrengthVolume&lt;br&gt;
HL7:  RXC-9 : ComponentDrugStrengthVolumeUnits&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  RXC-2.1 : ComponentCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  RXC-2.2 : ComponentCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgMast(PHCDName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  RXC-2.3 : ComponentCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to RXC-2.1 or .2 not being null, if subfield 4 or 5 is not&lt;br&gt;
null, then subfields 4, 5, and 6 will be parsed into the Code, Description,&lt;br&gt;
and CodeSystem, respectively, of a PriorCode in the list of PriorCodes. In&lt;br&gt;
this case, the PriorCode Type is set to "A".&lt;br&gt;
HL7:  RXC-2.4 : ComponentCode.AlternateIdentifier&lt;br&gt;
HL7:  RXC-2.5 : ComponentCode.AlternateText&lt;br&gt;
HL7:  RXC-2.6 : ComponentCode.NameofAlternateCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  RXC-2.9 : ComponentCode.OriginalText&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.StrengthQty&lt;br&gt;
HL7:  RXC-5 : ComponentStrength&lt;br&gt;
VIEWERLIB: User.HS.PHCFormDoseEquiv(EQQty)&lt;br&gt;
.StrengthUnits&lt;br&gt;
HL7:  RXC-6 : ComponentStrengthUnits&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.PHCFormDoseEquiv(EQCTUOMDR)&lt;br&gt;
.StrengthUnits.Code&lt;br&gt;
HL7:  RXC-6.1 : ComponentStrengthUnits.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMCode)&lt;br&gt;
.StrengthUnits.Description&lt;br&gt;
HL7:  RXC-6.2 : ComponentStrengthUnits.Text&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMDesc)&lt;br&gt;
.StrengthUnits.SDACodingStandard&lt;br&gt;
HL7:  RXC-6.3 : ComponentStrengthUnits.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.BaseQty&lt;br&gt;
HL7:  RXC-8 : ComponentDrugStrengthVolume&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgForm(PHCDFBaseQty)&lt;br&gt;
.BaseUnits&lt;br&gt;
HL7:  RXC-9 : ComponentDrugStrengthVolumeUnits&lt;br&gt;
SDATableName=UoM, ViewerClass=User.HS.CTUOM&lt;br&gt;
VIEWERLIB: User.HS.PHCDrgForm(PHCDFCTUOMDR)&lt;br&gt;
.BaseUnits.Code&lt;br&gt;
HL7:  RXC-9.1 : ComponentDrugStrengthVolumeUnits.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMCode)&lt;br&gt;
.BaseUnits.Description&lt;br&gt;
HL7:  RXC-9.2 : ComponentDrugStrengthVolumeUnits.Text&lt;br&gt;
VIEWERLIB: User.HS.CTUOM(CTUOMDesc)&lt;br&gt;
.BaseUnits.SDACodingStandard&lt;br&gt;
HL7:  RXC-9.3 : ComponentDrugStrengthVolumeUnits.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultCopiesTo" type="ArrayOfCareProvider">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Specimen">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="SpecimenCollectedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenReceivedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="VaccinationExtension"/>
        <s:element minOccurs="0" name="VXUObservations" type="ArrayOfObservation">
            <s:annotation>
                <s:documentation>List of observations made for this Vaccination&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Parsing of OBXs into VXUObservations is documented in depth in&lt;br&gt;
HS.SDA3.Observation. Note that Observation is also its own streamlet type.&lt;br&gt;
Instances where the parsing is different for independent Observations&lt;br&gt;
versus Vaccination Observations are noted in the annotations. Also, note&lt;br&gt;
that the parsing is sometimes dependent on the value of the&lt;br&gt;
ObservationCompatibilityMode setting of the HL7 Inbound Process operation&lt;br&gt;
of the Edge production. The details of this are documented in the&lt;br&gt;
Observation class as well.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The Streamlet Cache processing of VXUObservations is also documented in&lt;br&gt;
HS.SDA3.Observation but will be repeated here. In the OnBeforeMatch method&lt;br&gt;
of the Vaccination Streamlet class, if the ObservationTime of any&lt;br&gt;
Observation in the list is null, it will be defaulted to the last non-null&lt;br&gt;
ObservationTime in the list (that was originally non-null, not defaulted),&lt;br&gt;
then to the EnteredOn of the current Observation, then to the current&lt;br&gt;
date/time. In the OnValidate method of the Vaccination Streamlet class, if&lt;br&gt;
any of the Observations in VXUObservations has no ObservationCode, a warning&lt;br&gt;
will be logged and the Vaccination will be saved without the bad Observation.&lt;br&gt;&lt;br&gt;
HL7:  OBX&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="VaccinationExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfAppointment">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Appointment" nillable="true" type="Appointment"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Appointment">
    <s:sequence>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AppointmentExtension"/>
        <s:element minOccurs="0" name="Status" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Status will be set depending on the type of event received. Possible values&lt;br&gt;
are "CANCELLED" (SIU_S15, Notification of appointment cancellation), "DC"&lt;br&gt;
for "Discontinued" (SIU_S16, Notification of appointment discontinuation)&lt;br&gt;
and null for any other event.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The OnBeforeMatch method of the Streamlet class will default a null value&lt;br&gt;
to "BOOKED".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, a Status of "CANCELLED" will be stored as "X", "DC" as&lt;br&gt;
"D", and all other values as "P". The value that appears in the Viewer does&lt;br&gt;
not come from the DISPLAYLIST of the APPTStatus property, but rather the&lt;br&gt;
Description for the corresponding RBApptStatus Standard Type Item.  See the&lt;br&gt;
HS documentation for guidance on configuring this.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTStatus)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="NoShow" type="Boolean">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Will be set to 1 if an SIU_S26 (Notification that patient did not show up&lt;br&gt;
for scheduled appointment) is received.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The OnBeforeMatch method of the Streamlet class will default a null value&lt;br&gt;
to 0. Note that this means that if the value for an existing Appointment is&lt;br&gt;
1 and an update is applied that has no NoShow value, the saved value will&lt;br&gt;
become 0.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If NoShow is 1, the value stored in the Viewer Cache is the Description for the&lt;br&gt;
AppointmentStatus Standard Type Item with Code="N", "Not Attended" by default.&lt;br&gt;
See the HS documentation for guidance on configuring this.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTConfirmation)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Type" type="AppointmentType">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
SCH-7 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  SCH-7 : AppointmentReason&lt;br&gt;
SDATableName=AppointmentType, ViewerClass=User.HS.RBCSessionType&lt;br&gt;
VIEWERLIB: User.HS.RBApptSchedule(ASSessionTypeDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SCH-7.1 : AppointmentReason.Identifier&lt;br&gt;
VIEWERLIB: User.HS.RBCSessionType(SESSCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  SCH-7.2 : AppointmentReason.Text&lt;br&gt;
VIEWERLIB: User.HS.RBCSessionType(SESSDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SCH-7.3 : AppointmentReason.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PlacerApptId" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
If both Placer Appointment ID and Occurrence Number are given, PlacerApptId&lt;br&gt;
will be parsed as "[PlacerAppointmentID]:[OccurrenceNumber]".&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if both PlacerApptId&lt;br&gt;
and FillerApptId are null, an error will be logged and the Streamlet will&lt;br&gt;
not be processed.&lt;br&gt;&lt;br&gt;
HL7:  SCH-1.1 : PlacerAppointmentID.EntityIdentifier&lt;br&gt;
HL7:  SCH-3 : OccurrenceNumber&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTUBRN)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FillerApptId" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
If both Filler Appointment ID and Occurrence Number are given,&lt;br&gt;
FillerApptId will be parsed as "[FillerAppointmentID]:[OccurrenceNumber]".&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if both PlacerApptId&lt;br&gt;
and FillerApptId are null, an error will be logged and the Streamlet will&lt;br&gt;
not be processed.&lt;br&gt;&lt;br&gt;
HL7:  SCH-2.1 : FillerAppointmentID.EntityIdentifier&lt;br&gt;
HL7:  SCH-3 : OccurrenceNumber&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTUSRN)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="PlacerOrderId" type="s:string">
            <s:annotation>
                <s:documentation>Used to link an Appointment to an Order&lt;br&gt;&lt;br&gt;
HL7:  SCH-26.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FillerOrderId" type="s:string">
            <s:annotation>
                <s:documentation>Used to link an Appointment to an Order&lt;br&gt;&lt;br&gt;
HL7:  SCH-27.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderItem" type="Order">
            <s:annotation>
                <s:documentation>The service to be performed during the appointment.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
AIS-3 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  AIS-3 : UniversalServiceIdentifier&lt;br&gt;
SDATableName=Order, ViewerClass=User.HS.ARCItmMast&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTARCIMDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  AIS-3.1 : UniversalServiceIdentifier.Identifier&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  AIS-3.2 : UniversalServiceIdentifier.Text&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  AIS-3.3 : UniversalServiceIdentifier.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then a PriorCode will be parsed to the SDA&lt;br&gt;
with Code coming from subfield 4, Description from 5, and CodingSystem from&lt;br&gt;
6. The Type will be parsed as "A".&lt;br&gt;
HL7:  AIS-3.4 : UniversalServiceIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  AIS-3.5 : UniversalServiceIdentifier.AlternateText&lt;br&gt;
HL7:  AIS-3.6 : UniversalServiceIdentifier.NameofAlternateCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  AIS-3.9 : UniversalServiceIdentifier.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CareProvider" type="CareProvider">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though AIP-3 is a repeating field, HL7ToSDA3 will only parse the first&lt;br&gt;
non-null instance. AIP-4, if present, will be parsed as the&lt;br&gt;
CareProviderType of the AIP-3 CareProvider.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the Appointment&lt;br&gt;
does not have a CareProvider or Location, an error will be logged and&lt;br&gt;
the streamlet will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  AIP-3 : PersonnelResourceID&lt;br&gt;
HL7:  AIP-4 : ResourceType&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTRequestedCPDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  AIP-3.1 : IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  AIP-3.2.1 : FamilyName.Surname&lt;br&gt;
HL7:  AIP-3.3 : GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  AIP-3.9 : AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  AIP-3.2.1 : FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  AIP-3.3 : GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  AIP-3.4 : SecondandFurtherGivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  AIP-3.6 : Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  AIP-3.5 : Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  AIP-3.21 : ProfessionalSuffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;
.CareProviderType&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
AIP-4 will be parsed as the CareProviderType of the AIP-3 CareProvider, but&lt;br&gt;
only if subfield 1 or 2 is not null.&lt;br&gt;
HL7:  AIP-4 : ResourceType&lt;br&gt;
SDATableName=CareProviderType, ViewerClass=User.HS.CTCarPrvTp&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCarPrvTpDR)&lt;br&gt;
.CareProviderType.Code&lt;br&gt;
HL7:  AIP-4.1 : ResourceType.Identifier&lt;br&gt;
VIEWERLIB: User.HS.CTPCPCarPrvTpDR(CTCPTCode)&lt;br&gt;
.CareProviderType.Description&lt;br&gt;
HL7:  AIP-4.2 : ResourceType.Text&lt;br&gt;
VIEWERLIB: User.HS.CTPCPCarPrvTpDR(CTCPTDesc)&lt;br&gt;
.CareProviderType.SDACodingStandard&lt;br&gt;
HL7:  AIP-4.3 : ResourceType.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Location" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
AIL-3.9 is parsed to the Location Code. HL7ToSDA3 does not set the&lt;br&gt;
Description.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if the Appointment&lt;br&gt;
does not have a CareProvider or Location, an error will be logged and&lt;br&gt;
the streamlet will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  AIL-3.9 : LocationResourceID.LocationDescription&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.RBResource(RESCTLOCDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Notes" type="s:string">
            <s:annotation>
                <s:documentation>CRLF-delimited string&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Only the NTEs following the TQ1 segment (or the SCH if there is no&lt;br&gt;
TQ1) will be parsed.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTRemarks)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though SCH-20 is a repeating field, HL7ToSDA3 will only use the first&lt;br&gt;
non-null instance.&lt;br&gt;&lt;br&gt;
HL7:  SCH-20 : EnteredByPerson&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTLastStatusChangeUserDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  SCH-20.1 : EnteredByPerson.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The name is formatted as "[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  SCH-20.2.1 : EnteredByPerson.FamilyName.Surname&lt;br&gt;
HL7:  SCH-20.3 : EnteredByPerson.GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  SCH-20.9 : EnteredByPerson.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
SCH-22 is used if subfield 4.1 is not null, else MSH-4 is used.  In either&lt;br&gt;
case, the HL7 value is used as the EnteredAt Code. HL7ToSDA3 does not set&lt;br&gt;
the Description.&lt;br&gt;&lt;br&gt;
HL7:  SCH-22.4.1 : EnteredAtLocation.Facility.NamespaceID&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTLastStatusChangeHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if EnteredOn is null, it&lt;br&gt;
is defaulted to the current date/time.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTLastStatusChangeDate) + User.HS.RBAppointment(APPTLastStatusChangeTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
If a TQ1 is present, TQ1-7 will be used, else SCH-11.4 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, if FromTime is null, an error will&lt;br&gt;
be logged and the Appointment will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
ASDate and ASSession are date-only. ASSessStartTime and APPTETA are time-only.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-7 : StartDateTime&lt;br&gt;
HL7:  SCH-11.4 : AppointmentTimingQuantity.StartDateTime&lt;br&gt;
VIEWERLIB: User.HS.RBAppointment(APPTETA)&lt;br&gt;
VIEWERLIB: User.HS.RBApptSchedule(ASSessStartTime)&lt;br&gt;
VIEWERLIB: User.HS.RBApptSchedule(ASDate)&lt;br&gt;
VIEWERLIB: User.HS.RBApptSchedule(ASSession)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
If a TQ1 is present, only TQ1 fields will be used, else SCH fields will be&lt;br&gt;
used.&lt;br&gt;
If the HL7 contains a start time but no end time, and it contains a&lt;br&gt;
duration (TQ1-6.1 or SCH-9) and a duration units (TQ1-6.2.1 or SCH-10.1)&lt;br&gt;
equal to "MINUTES", "M", "HOURS", or "H" (case-insensitive),&lt;br&gt;
then ToTime will be calculated from the start time and duration.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
ASSessEndTime is time-only.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  TQ1-8 : EndDateTime&lt;br&gt;
HL7:  SCH-9 : AppointmentDuration&lt;br&gt;
HL7:  SCH-10.1 : AppointmentDurationUnits.Identifer&lt;br&gt;
HL7:  SCH-11.5 : AppointmentTimingQuantity.EndDateTime&lt;br&gt;
VIEWERLIB: User.HS.RBApptSchedule(ASSessEndTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.RBAppointment(APPTEBEI)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
C = Clear All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AppointmentExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="AppointmentType">
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="AppointmentTypeExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.RBCSessionType(SESSCode)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>VIEWERLIB: User.HS.RBCSessionType(SESSDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="AppointmentTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfReferral">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Referral" nillable="true" type="Referral"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Referral">
    <s:annotation>
        <s:documentation>At present, Referrals are not parsed from HL7. This class contains&lt;br&gt;
"possible" HL7 annotations, indicating that these mappings from HL7 do not&lt;br&gt;
yet exist, but potentially could someday. (prodlog 119135)</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Message action code&lt;br&gt;
Case-sensitive&lt;br&gt;
Supported values include:&lt;br&gt;
D = Delete&lt;br&gt;
E = Delete if empty (Encounters only)&lt;br&gt;
I = Inactivate all&lt;br&gt;
C = Clear/Delete all&lt;br&gt;
R = Replace (Patient and Encounter only)&lt;br&gt;
Any other value = Add or Update&lt;br&gt;&lt;br&gt;
ActionCode is only supported for SDA3 classes corresponding to Streamlet&lt;br&gt;
types (Allergy, Diagnosis, etc.). Not all of the above codes are supported&lt;br&gt;
for every class. Whether ActionCode is supported and what codes are&lt;br&gt;
supported is documented in each individual subclass. For codes "C" and "I",&lt;br&gt;
all streamlets of the given type belonging to the given Patient and in the&lt;br&gt;
given Encounter (or Encounter-less if the inbound SDA object has no&lt;br&gt;
EncounterNumber) will be cleared or inactivated. Otherwise (codes "D", "E",&lt;br&gt;
"R") only the matching streamlet will be affected.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="ReferralExtension"/>
        <s:element minOccurs="0" name="PlacerId">
            <s:annotation>
                <s:documentation>The originating application's permanent identifier for the referral&lt;br&gt;
Possible HL7:  RF1-6 : OriginatingReferralIdentifier&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerId">
            <s:annotation>
                <s:documentation>The identifier assigned to the referral by the referred-to provider&lt;br&gt;
Possible HL7:  RF1-11 : ExternalReferralIdentifier&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ReferralReason">
            <s:annotation>
                <s:documentation>The reason for which the referral will take place&lt;br&gt;
Possible HL7:  RF1-10 : ReferralReason&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32767"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ReferringProvider" type="CareProvider">
            <s:annotation>
                <s:documentation>The care provider initiating the referral&lt;br&gt;
From HL7, the ReferringProvider would be given by the PRD segment with&lt;br&gt;
PRD-1.1 (ProviderRole.Indentifier) = "RP" for "Referring Provider".&lt;br&gt;
Possible HL7:  PRD&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReferringOrganization" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>The facility from which the referral originated&lt;br&gt;
Possible HL7:  PRD-4 : ProviderLocation&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReferredToProvider" type="CareProvider">
            <s:annotation>
                <s:documentation>The care provider to whom the patient is referred&lt;br&gt;
From HL7, the ReferredToProvider would be given by the PRD segment with&lt;br&gt;
PRD-1.1 (ProviderRole.Indentifier) = "RT" for "Referred to Provider".&lt;br&gt;
Possible HL7:  PRD&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReferredToOrganization" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>The facility to which the patient is referred&lt;br&gt;
Possible HL7:  PRD-4 : ProviderLocation&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ValidityDuration" type="Duration">
            <s:annotation>
                <s:documentation>The length of time the referral is valid from the date of the first&lt;br&gt;
patient/referee encounter.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>The date on which the referral originated&lt;br&gt;
Possible HL7:  RF1-9 : ProcessDate&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The date on which the referral is effective&lt;br&gt;
Possible HL7:  RF1-7 : EffectiveDate&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>The date on which the referral expires&lt;br&gt;
Possible HL7:  RF1-8 : ExpirationDate&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ReferralExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfClinicalRelationship">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="ClinicalRelationship" nillable="true" type="ClinicalRelationship"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ClinicalRelationship">
    <s:annotation>
        <s:documentation>This is used to collect data from the clinician-patient relationships that&lt;br&gt;
are stored in the Registry (as  HS.Push.PatientClinicianRelationship), and&lt;br&gt;
return them as SDA. This should only ever come from the HealthShare&lt;br&gt;
Registry. It should not be submitted by a data provider.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Message action code&lt;br&gt;
Case-sensitive&lt;br&gt;
Supported values include:&lt;br&gt;
D = Delete&lt;br&gt;
E = Delete if empty (Encounters only)&lt;br&gt;
I = Inactivate all&lt;br&gt;
C = Clear/Delete all&lt;br&gt;
R = Replace (Patient and Encounter only)&lt;br&gt;
Any other value = Add or Update&lt;br&gt;&lt;br&gt;
ActionCode is only supported for SDA3 classes corresponding to Streamlet&lt;br&gt;
types (Allergy, Diagnosis, etc.). Not all of the above codes are supported&lt;br&gt;
for every class. Whether ActionCode is supported and what codes are&lt;br&gt;
supported is documented in each individual subclass. For codes "C" and "I",&lt;br&gt;
all streamlets of the given type belonging to the given Patient and in the&lt;br&gt;
given Encounter (or Encounter-less if the inbound SDA object has no&lt;br&gt;
EncounterNumber) will be cleared or inactivated. Otherwise (codes "D", "E",&lt;br&gt;
"R") only the matching streamlet will be affected.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time updated or entered.  For labs, this represents when the order was&lt;br&gt;
placed.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Clinician" type="CareProvider">
            <s:annotation>
                <s:documentation>If the relationship is between a patient and an individual clinician, this&lt;br&gt;
is that clinician. The Code will be populated by the ID of the&lt;br&gt;
HS.Push.PatientClinicianRelationship:Clinician, and the SDACodingStandard&lt;br&gt;
will be set to "HSClinician". Other properties from the User/Clinician&lt;br&gt;
Registry (NameParts, Addresses, Telecoms) will populate this Clinician as&lt;br&gt;
well. This property will only be populated for individual relationships.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If present, Clinician will populate CPCareProvDR, else ClinicianGroup will&lt;br&gt;
be used.&lt;br&gt;&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.PAPersonCareProvider(CPCareProvDR)&lt;br&gt;&lt;br&gt;
.CareProviderType&lt;br&gt;
The Code and Description come from the Name and Description of the&lt;br&gt;
HS.Push.PatientClinicianRelationship:Relationship. The SDACodingStandard is&lt;br&gt;
set to "HSRelationshipType".&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FacilityCode" type="s:string">
            <s:annotation>
                <s:documentation>For individual clinician relationships, this is the facility code for the&lt;br&gt;
clinician's primary facility.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
FacilityCode is stored in a code table in the Viewer Cache&lt;br&gt;
(User.HS.CTResponsibleUnit), but because it is not a CodeTableDetail, it is&lt;br&gt;
not subjected to CodeTableDetail matching. Instead, matching is simply done&lt;br&gt;
on RUCode, ALPHAUP collated. If no matching CTResponsibleUnit is found, a&lt;br&gt;
new one is created with RUCode and RUDesc = FacilityCode.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.PAPersonCareProvider(CPRespUnitDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ClinicianGroup" type="CareProvider">
            <s:annotation>
                <s:documentation>If the relationship is between a patient and a clinician group, this is&lt;br&gt;
that group. The Code and Description will be populated by the ID and Name&lt;br&gt;
of the HS.Push.PatientClinicianRelationship:ClinicianGroup, respectively.&lt;br&gt;
The SDACodingStandard will be set to "HSClinicianGroup". This property will&lt;br&gt;
only be populated for group relationships.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If present, Clinician will populate CPCareProvDR, else ClinicianGroup will&lt;br&gt;
be used.&lt;br&gt;&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.PAPersonCareProvider(CPCareProvDR)&lt;br&gt;&lt;br&gt;
.CareProviderType&lt;br&gt;
The Code and Description come from the Name and Description of the&lt;br&gt;
HS.Push.PatientClinicianRelationship:Relationship. The SDACodingStandard is&lt;br&gt;
set to "HSRelationshipType".&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExpirationDate" type="TimeStamp">
            <s:annotation>
                <s:documentation>Populated by the ExpirationDate of the&lt;br&gt;
HS.Push.PatientClinicianRelationship.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="StartDate" type="TimeStamp">
            <s:annotation>
                <s:documentation>Populated by the StartDate of the&lt;br&gt;
HS.Push.PatientClinicianRelationship.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Used for Encounter entities
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfProgramMembership">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="ProgramMembership" nillable="true" type="ProgramMembership"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ProgramMembership">
    <s:annotation>
        <s:documentation>This is used to collect data from the patient program memberships that are&lt;br&gt;
stored in the registry, and return them as SDA. This should only ever come&lt;br&gt;
from the HealthShare registry. It should not be submitted by a data&lt;br&gt;
provider.&lt;br&gt;&lt;br&gt;
In the Viewer Cache, because questionnaire.QPROGRAMS requires an Encounter,&lt;br&gt;
it is linked to the patient's silent encounter, creating one if it does not&lt;br&gt;
yet exist.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Message action code&lt;br&gt;
Case-sensitive&lt;br&gt;
Supported values include:&lt;br&gt;
D = Delete&lt;br&gt;
E = Delete if empty (Encounters only)&lt;br&gt;
I = Inactivate all&lt;br&gt;
C = Clear/Delete all&lt;br&gt;
R = Replace (Patient and Encounter only)&lt;br&gt;
Any other value = Add or Update&lt;br&gt;&lt;br&gt;
ActionCode is only supported for SDA3 classes corresponding to Streamlet&lt;br&gt;
types (Allergy, Diagnosis, etc.). Not all of the above codes are supported&lt;br&gt;
for every class. Whether ActionCode is supported and what codes are&lt;br&gt;
supported is documented in each individual subclass. For codes "C" and "I",&lt;br&gt;
all streamlets of the given type belonging to the given Patient and in the&lt;br&gt;
given Encounter (or Encounter-less if the inbound SDA object has no&lt;br&gt;
EncounterNumber) will be cleared or inactivated. Otherwise (codes "D", "E",&lt;br&gt;
"R") only the matching streamlet will be affected.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ProgramName" type="s:string">
            <s:annotation>
                <s:documentation>VIEWERLIB: questionnaire.QPROGRAMS(QProgramName)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ProgramDescription">
            <s:annotation>
                <s:documentation>VIEWERLIB: questionnaire.QPROGRAMS(QProgramDescription)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ProgramID" type="s:string"/>
        <s:element minOccurs="0" name="Clinician" type="CareProvider"/>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Effective time of the membership&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Termination time of the membership&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>VIEWERLIB: questionnaire.QPROGRAMS(QUESUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: questionnaire.QPROGRAMS(QUESDate) + questionnaire.QPROGRAMS(QUESTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Active" type="s:boolean"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfMemberEnrollment">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="MemberEnrollment" nillable="true" type="MemberEnrollment"/>
    </s:sequence>
</s:complexType>
<s:complexType name="MemberEnrollment">
    <s:annotation>
        <s:documentation>MemberEnrollment is neither parsed from HL7, nor is it stored to the Viewer Cache.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="MemberEnrollmentExtension"/>
                <s:element minOccurs="0" name="MemberEnrollmentNumber" type="s:string">
                    <s:annotation>
                        <s:documentation>A unique string to identify Member Enrollment &lt;br&gt;
For 834, it takes the form  payerIdCode_subscriberId_memberId_coveragePeriod: &lt;br&gt;
payerIdCode: loop1000B.N1 &lt;br&gt;
subscriberId: loop2000.REF():RefId &lt;br&gt;
memberId: loop2000.REF():RefId &lt;br&gt;
coveragePeriod: loop2000.loop2300().DTP() &lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Source" type="s:string">
                    <s:annotation>
                        <s:documentation>The source, e.g., 834 etc.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="CarrierSpecificMemberID" type="s:string">
                    <s:annotation>
                        <s:documentation>Unique, internal identification assigned by the carrier or its designee to the Member.&lt;br&gt;
This can be used to link Claim Lines to eligibility segments.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="SuffixOrSequenceNumber" type="s:string"/>
                <s:element minOccurs="0" name="Business" type="Business"/>
                <s:element minOccurs="0" name="InsuranceTypeOrProductCode" type="InsuranceType">
                    <s:annotation>
                        <s:documentation>A code that defines the type of insurance applied to the claim line.  &lt;br&gt;
This value can be derived from the claim as submitted by the provider or reassigned by the carrier or its designee. &lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="CoverageLevelCode" type="CoverageLevel">
                    <s:annotation>
                        <s:documentation>A code that reports relationships which are covered under the benefits during the time-period of this eligibility segment.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="IndividualRelationshipCode" type="Relationship">
                    <s:annotation>
                        <s:documentation>Numeric indicator to define the Member's relationship to the Subscriber.&lt;br&gt;
834:	loop2000().INS:IndividualRelationshipCode&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="InsuredGroupOrPolicyNumber" type="s:string">
                    <s:annotation>
                        <s:documentation>&lt;p&gt;
Deprecated. Use either the InsuredGroup property, or the PolicyPlan property.
&lt;/p&gt;&lt;p&gt;
Deprecated property description:
The carrier assigned group / policy number for this claim line.&lt;br&gt; 
This information is often filed as reported by the provider.&lt;br&gt;
834:	loop2000().REF():RefId&lt;br&gt;
&lt;/p&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="MedicalCoverage">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if the Member has medical coverage as a benefit during the time-period of this eligibility segment.&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="DentalCoverage">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if the Member has dental coverage as a benefit during the time-period of this eligibility segment.&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="PrescriptionCoverage">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if the Member has prescription drug coverage as a benefit during the time-period of this eligibility segment.&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="PrimaryInsuranceIndicator">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if the Member's eligibility is for primary insurance during the time-period of this eligibility segment.&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="CoverageType" type="CoverageType">
                    <s:annotation>
                        <s:documentation>A code that reports the risk-type of the carrier the Member is covered under during the time-period stated on this eligibility segment.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="MarketCategoryCode" type="MarketCategory">
                    <s:annotation>
                        <s:documentation>A code that reports the market the policy is sold into by the carrier or its designee during the time-period of this eligibility segment.&lt;br&gt;
Use this code to map to individuals and group sizes.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="SpecialCoverage" type="SpecialCoverage">
                    <s:annotation>
                        <s:documentation>A code that reports special coverage type under Commonwealth Care or the Health Safety Net during the time-period of this eligibility segment.&lt;br&gt;
Value of N/A indicates any other type of coverage.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PlanSpecificSubscriberID" type="s:string">
                    <s:annotation>
                        <s:documentation>Unique, internal identification assigned by the carrier or its designee to the Subscriber.&lt;br&gt;
This can be used to link Claim Lines to eligibility segments.&lt;br&gt;
834:	loop2000().REF():RefId&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="SubscriberSSNOrProxy" type="s:string">
                    <s:annotation>
                        <s:documentation>Tax ID of the Subscriber.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="NationalPlanID" type="s:string">
                    <s:annotation>
                        <s:documentation>This is a unique identifier as outlined
by Centers for Medicare and
Medicaid Services (CMS) for Plans
or Sub plans
834:	loop2000().loop2300().REF(1):RefId&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Guarantor" type="Guarantor"/>
                <s:element minOccurs="0" name="HealthFund" type="HealthFund"/>
                <s:element minOccurs="0" name="PrimaryCareProvider" type="CareProvider">
                    <s:annotation>
                        <s:documentation>Primary Care Provider
834: loop2000().loop2300().loop2310()</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PrimaryCareFacility" type="HealthCareFacility">
                    <s:annotation>
                        <s:documentation>Primary Care Facility</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="InsuredGroup" type="InsuredGroup">
                    <s:annotation>
                        <s:documentation>Employer account identifier.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PolicyPlan" type="PolicyPlan">
                    <s:annotation>
                        <s:documentation>Business concept used by a health plan to describe its benefit offerings.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Status" type="FinancialResourceStatus">
                    <s:annotation>
                        <s:documentation>&lt;p&gt;
Identifies the status of the coverage information for the FHIR Coverage resource.
&lt;/p&gt;&lt;p&gt;
To conform to the FHIR CARIN Blue Button Implementation Profiles, 
the Status.Code property requires the value set defined at http://hl7.org/fhir/ValueSet/fm-status. 
Refer to the HealthShare documentation for information on translating local codes into defined value sets.
&lt;/p&gt;&lt;p&gt;
When no value is supplied, the default is "active".
&lt;/p&gt;</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SuperClass">
    <s:annotation>
        <s:documentation>Base for SDA objects</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="ActionCode" type="s:string">
                    <s:annotation>
                        <s:documentation>Message action code&lt;br&gt;
Case-sensitive&lt;br&gt;
Supported values include:&lt;br&gt;
D = Delete&lt;br&gt;
E = Delete if empty (Encounters only)&lt;br&gt;
I = Inactivate all&lt;br&gt;
C = Clear/Delete all&lt;br&gt;
R = Replace (Patient and Encounter only)&lt;br&gt;
Any other value = Add or Update&lt;br&gt;&lt;br&gt;
ActionCode is only supported for SDA3 classes corresponding to Streamlet&lt;br&gt;
types (Allergy, Diagnosis, etc.). Not all of the above codes are supported&lt;br&gt;
for every class. Whether ActionCode is supported and what codes are&lt;br&gt;
supported is documented in each individual subclass. For codes "C" and "I",&lt;br&gt;
all streamlets of the given type belonging to the given Patient and in the&lt;br&gt;
given Encounter (or Encounter-less if the inbound SDA object has no&lt;br&gt;
EncounterNumber) will be cleared or inactivated. Otherwise (codes "D", "E",&lt;br&gt;
"R") only the matching streamlet will be affected.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ActionScope" type="s:string">
                    <s:annotation>
                        <s:documentation>Optional ActionCode qualifier&lt;br&gt;
For selected SDA classes, this qualifies ActionCodes "I" (if it is&lt;br&gt;
supported) and "C" by giving them a scope. Ex: for Problems, ActionCode="C"&lt;br&gt;
and ActionScope="PAST" will only delete past problems. (The meaning of&lt;br&gt;
"past" is explained in HS.SDA3.Problem.) Whether ActionScope is supported&lt;br&gt;
and what values are supported is documented in each individual subclass.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="EnteredBy" type="User">
                    <s:annotation>
                        <s:documentation>User who updated source system&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="EnteredAt" type="Organization">
                    <s:annotation>
                        <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>Date/time updated or entered.  For labs, this represents when the order was&lt;br&gt;
placed.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="FromTime" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>Start of time range</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ToTime" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>End of time range</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ExternalId">
                    <s:annotation>
                        <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="EncounterNumber">
                    <s:annotation>
                        <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="220"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
                    <s:annotation>
                        <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="MemberEnrollmentExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="Business">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="BusinessExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="BusinessExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="InsuranceType">
    <s:annotation>
        <s:documentation>09	Self-pay
10	Central Certification
11	Other Non-Federal Programs
12	Preferred Provider Organization (PPO)
13	Point of Service (POS)
14	Exclusive Provider Organization (EPO)
15	Indemnity Insurance
16	Health Maintenance Organization (HMO) Medicare Risk
AM	Automobile Medical
BL	Blue Cross / Blue Shield
CC	Commonwealth Care
CE	Commonwealth Choice 
CH	Champus
CI	Commercial Insurance Co.
DS	Disability
HM	Health Maintenance Organization
LI	Liability
LM	Liability Medical
MA	Medicare Part A
MB	Medicare Part B
MC	Medicaid
OF	Other Federal Program
TV	Title V
VA	Veterans Administration Plan
WC	Workers' Compensation</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="InsuranceTypeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="InsuranceTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="CoverageLevel">
    <s:annotation>
        <s:documentation>CHD Children Only 
DEP Dependents Only 
ECH Employee and Children 
ELF Employee and Life Partner 
EMP Employee Only 
ESP Employee and Spouse 
FAM Family 
IND Individual 
SPC Spouse and Children 
SPO Spouse Only</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="CoverageLevelExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="CoverageLevelExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="CoverageType">
    <s:annotation>
        <s:documentation>ASW	self-funded plans that are administered by a third-party administrator, where the employer has purchased stop-loss, or group excess, insurance coverage
ASO	self-funded plans that are administered by a third-party administrator, where the employer has not purchased stop-loss, or group excess, insurance coverage
STN	short-term, non-renewable health insurance
UND	plans underwritten by the insurer
OTH	Any other plan. Insurers using this code shall obtain prior approval.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="CoverageTypeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="CoverageTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="MarketCategory">
    <s:annotation>
        <s:documentation>IND	Policies sold and issued directly to individuals (non-group)
FCH	Policies sold and issued directly to individuals on a franchise basis
GCV	Policies sold and issued directly to individuals as group conversion Policies
GS1	Policies sold and issued directly to employers having exactly one employee
GS2	Policies sold and issued directly to employers having between two and nine employees
GS3	Policies sold and issued directly to employers having between 10 and 25 employees
GS4	Policies sold and issued directly to employers having between 26 and 50 employees
GLG1	Policies sold and issued directly to employers having between 51 and 99 employees
GLG2	Policies sold and issued directly to employers having between 100 and 249 employees
GLG3	Policies sold and issued directly to employers having between 250 and 499 employees
GLG4	Policies sold and issued directly to employers having 500 or more employees
GSA	Policies sold and issued directly to small employers through a qualified association trust
OTH	Policies sold to other types of entities. Insurers using this market code shall obtain prior approval.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="MarketCategoryExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="MarketCategoryExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecialCoverage">
    <s:annotation>
        <s:documentation>CC	Commonwealth Care
HSN	Health Safety Net
N/A	Not Applicable</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SpecialCoverageExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SpecialCoverageExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="InsuredGroup">
    <s:annotation>
        <s:documentation>This code table class supports properties added to SDA3 for Coverage and Claims.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="InsuredGroupExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>Employer account identifier.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>Name of the Employer account.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="InsuredGroupExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PolicyPlan">
    <s:annotation>
        <s:documentation>This code table class supports properties added to SDA3 for Coverage and Claims.</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="PolicyPlanExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>Business concept used by a health plan to describe its benefit offerings.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>Name of the health plan benefit offering assigned to the Plan Identifier used by a health plan.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="PolicyPlanExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="FinancialResourceStatus">
    <s:annotation>
        <s:documentation>&lt;p&gt;
Identifies the status of a financial resource.
&lt;/p&gt;&lt;p&gt;
To conform to the FHIR CARIN Blue Button Implementation Profiles, 
the Code property in this class requires the value set defined at http://hl7.org/fhir/ValueSet/fm-status. 
Refer to the HealthShare documentation for information on translating local codes into defined value sets.
&lt;/p&gt;&lt;p&gt;
Examples of FHIR financial resources that use the FHIR ValueSet
http://hl7.org/fhir/fm-status to supply values for their "code" property:
&lt;/p&gt;&lt;p&gt;
Resource: EnrollmentRequest.status (code / Required) &lt;br/&gt;
Resource: CoverageEligibilityResponse.status (code / Required) &lt;br/&gt;
Resource: PaymentNotice.status (code / Required) &lt;br/&gt;
Resource: VisionPrescription.status (code / Required) &lt;br/&gt;
Resource: EnrollmentResponse.status (code / Required) &lt;br/&gt;
Resource: ClaimResponse.status (code / Required) &lt;br/&gt;
Resource: PaymentReconciliation.status (code / Required) &lt;br/&gt;
Resource: Coverage.status (code / Required) &lt;br/&gt;
Resource: CoverageEligibilityRequest.status (code / Required) &lt;br/&gt;
Resource: Claim.status (code / Required) &lt;br/&gt;
&lt;/p&gt;</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="SDACodingStandard">
            <s:annotation>
                <s:documentation>The coding standard. e.g. "3.2.45.7.34", "LOINC", etc.&lt;br&gt;
SDACodingStandard may not contain the caret ("^") symbol as this is&lt;br&gt;
reserved for internal use.&lt;br&gt;
If the SDA is being loaded into the Streamlet Cache via the ECR Manager&lt;br&gt;
operation or the Aggregation Cache via the Access Manager operation, then&lt;br&gt;
if the operation specifies an InboundCodeSystemProfile (referring to a Code&lt;br&gt;
System Profile in the Terminology Registry), and that profile specifies a&lt;br&gt;
default code system for this code table, and if SDACodingStandard is null,&lt;br&gt;
then SDACodingStandard will be defaulted to the default code system for&lt;br&gt;
this code table. If the code table will be transformed to or from FHIR,&lt;br&gt;
SDACodingStandard may be one of the CodeSystems in the FHIR ValueSet.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CodeSystemVersionId">
            <s:annotation>
                <s:documentation>The coding system version ID, e.g. piece 7 from an HL7v2.5 CNE or CWE&lt;br&gt;
structure</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OriginalText">
            <s:annotation>
                <s:documentation>The original text that was available to an automated process or a human&lt;br&gt;
before a specific code was assigned. When parsed from HL7 in HL7ToSDA3,&lt;br&gt;
this will always come from piece 9 of a coded field (data structure CNE or&lt;br&gt;
CWE).&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PriorCodes" type="ArrayOfPriorCode">
            <s:annotation>
                <s:documentation>A list of alternate codes or codes that may have been previously assigned&lt;br&gt;
to this property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="FinancialResourceStatusExtension"/>
        <s:element minOccurs="0" name="Code">
            <s:annotation>
                <s:documentation>&lt;p&gt;
Identifies the status of a financial FHIR resource. 
&lt;/p&gt;&lt;p&gt;
To conform to the FHIR CARIN Blue Button Implementation Profiles, 
this property requires the value set defined at http://hl7.org/fhir/ValueSet/fm-status. 
Refer to the HealthShare documentation for information on translating local codes into defined value sets.
&lt;/p&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Description">
            <s:annotation>
                <s:documentation>&lt;p&gt;
Display text for the status of a financial FHIR resource. 
&lt;/p&gt;&lt;p&gt;
As is normal behavior for HS.SDA3.CodeTableDetail subclasses,
if no Description is provided, the Code value is displayed.
&lt;/p&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="FinancialResourceStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfMedicalClaim">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="MedicalClaim" nillable="true" type="MedicalClaim"/>
    </s:sequence>
</s:complexType>
<s:complexType name="MedicalClaim">
    <s:annotation>
        <s:documentation>MedicalClaim is neither parsed from HL7, nor is it stored to the Viewer Cache.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="ClaimProcessedDate" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>The date the claim was processed by the carrier or its designee for adjudication.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="FormerClaimNumber" type="s:string">
                    <s:annotation>
                        <s:documentation>The Payer Claim Control Number previously assigned to this claim line in a prior reporting period.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ReceivedDate" type="TimeStamp"/>
                <s:element minOccurs="0" name="MedicalClaimLines" type="ArrayOfMedicalClaimLine"/>
                <s:element minOccurs="0" name="Extension" type="MedicalClaimExtension"/>
                <s:element minOccurs="0" name="MedicalClaimNumber" type="s:string">
                    <s:annotation>
                        <s:documentation>Unique identifier within the payer's system that applies to the entire claim. &lt;br&gt;
837apP:	loop2300().CLM:ClaimSubmittersIdentifier&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="RecordType" type="s:string">
                    <s:annotation>
                        <s:documentation>The APCD filing-type identifier that defines the data contained within the file.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="SubmissionDate" type="TimeStamp"/>
                <s:element minOccurs="0" name="Version" type="Numeric">
                    <s:annotation>
                        <s:documentation>Incrementing counter for a claim line that is reprocessed for any reason over the course of time.&lt;br&gt;
Highest value should indicate latest reprocessing of line by the carrier/submitter.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="AdmissionSource" type="AdmissionSource">
                    <s:annotation>
                        <s:documentation>A standardized code that reports the admission source of the Patient into an inpatient setting/facility &lt;br&gt;
and indicates how the Patient was referred into the inpatient setting.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="AdmissionType" type="AdmissionType">
                    <s:annotation>
                        <s:documentation>A standardized, numeric code that reports the type of admission into an inpatient setting.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="AdmissionDate" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>The date that the Patient was admitted into an inpatient setting at the facility.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="GlobalPaymentFlag">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if a claim line was processed / paid under a global payment arrangement.&lt;br&gt;
837apP:	loop2300().CN1:ContractTypeCode&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="CapitatedEncounterFlag">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if a claim line is covered under a capitation arrangement.&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="ClaimStatus" type="ClaimStatus">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if the claim line was paid by the carrier or its designee, and the COB order of the payment.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DelegatedBenefitAdminOrgID" type="s:string"/>
                <s:element minOccurs="0" name="DischargeStatus" type="DischargeStatus">
                    <s:annotation>
                        <s:documentation>A standardized, numeric code that reports the discharge status of the Patient.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DRG" type="s:string">
                    <s:annotation>
                        <s:documentation>CMS methodology when available.&lt;br&gt;
When the CMS methodology for DRGs is not available, but the All Payer DRG system is used,&lt;br&gt;
the insurer shall format the DRG and the complexity level within the same field with an "A" prefix,&lt;br&gt; 
and with a hyphen separating the DRG and the complexity level (e.g. AXXX-XX).&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DRGLevel" type="s:string">
                    <s:annotation>
                        <s:documentation>Severity adjustment level when applicable.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DRGVersion" type="s:string">
                    <s:annotation>
                        <s:documentation>Version identifier of the DRG Grouper used.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="AdmissionDiagnosis" type="DiagnosisCode">
                    <s:annotation>
                        <s:documentation>Diagnostic code assigned by the provider to support admission into an inpatient setting at the facility&lt;br&gt;
reported in Plan Rendering Provider ID and Provider Location.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DischargeDiagnosis" type="DiagnosisCode">
                    <s:annotation>
                        <s:documentation>The ICD9 diagnosis code assigned to the Patient upon discharge.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PrincipalDiagnosis" type="DiagnosisCode">
                    <s:annotation>
                        <s:documentation>Primary ICD9 Diagnosis Code.&lt;br&gt;
837apP: loop2300().HI():HealthCareCodeInformation2&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="OtherDiagnoses" type="ArrayOfDiagnosisDiagnosisCode">
                    <s:annotation>
                        <s:documentation>Other ICD9 Diagnosis Codes.&lt;br&gt; 
837apP: loop2300().HI():HealthCareCodeInformation2&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="MedicareIndicator">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if the claim line has any Medicare payments applied towards it as a Prior Payer on the claim.&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="AccidentIndicator">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if the claim line procedure was performed due to an accident (not employment based).&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="PatientAccount" type="s:string"/>
                <s:element minOccurs="0" name="SiteNumber" type="s:string"/>
                <s:element minOccurs="0" name="AttendingProvider" type="CareProvider"/>
                <s:element minOccurs="0" name="Submitter" type="s:string">
                    <s:annotation>
                        <s:documentation>Report CHIA defined, unique
Submitter ID here. TR002 must
match the Submitter ID reported
here. This ID is linked to other
elements in the file for quality control
837apP:	loop1000A.NM1:IdentificationCode&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="TypeOfBillInstitutional" type="s:string">
                    <s:annotation>
                        <s:documentation>For Institutional Claims: a standardized code that reports the type of facility where the claim line service occurred. &lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="EmploymentRelatedIndicator">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if the claim line procedure was performed due to an employment related accident.&lt;br&gt;
837apP:	loop2300().CLM:RelatedCausesInformation.RelatedCausesCode&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="Subscriber" type="Guarantor">
                    <s:annotation>
                        <s:documentation>Subscriber
837apP:	loop2000A().loop2000B()&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfMedicalClaimLine">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="MedicalClaimLine" nillable="true" type="MedicalClaimLine"/>
    </s:sequence>
</s:complexType>
<s:complexType name="MedicalClaimLine">
    <s:annotation>
        <s:documentation>MedicalClaim is neither parsed from HL7, nor is it stored to the Viewer&lt;br&gt;
Cache. It appears in the SDA as a list property of HS.SDA3.MedicalClaim.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="MedicalClaimLineExtension"/>
                <s:element minOccurs="0" name="LineCounter" type="s:string">
                    <s:annotation>
                        <s:documentation>The line number for this service on the claim. &lt;br&gt;
First line should start with 1 and each additional line incremented by 1. &lt;br&gt;
837apP: loop2300().loop2400().LX:AssignedNumber&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PaymentReason" type="PaymentReason"/>
                <s:element minOccurs="0" name="AllowedAmount" type="Numeric">
                    <s:annotation>
                        <s:documentation>The maximum amount contractually allowed and payable for this claim line as defined by the carrier or its designee.&lt;br&gt;
837apP:	loop2300().loop2400().HCP:MonetaryAmount&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ChargedAmount" type="Numeric">
                    <s:annotation>
                        <s:documentation>The amount the provider charged for the claim line service.&lt;br&gt;
837apP:	loop2300().loop2400().SV1:MonetaryAmount&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PaidAmount" type="Numeric">
                    <s:annotation>
                        <s:documentation>The amount paid to the provider for this claim line.&lt;br&gt;
837apP:	loop2300().loop2400().loop2430(1).SVD:MonetaryAmount&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="APC" type="s:string">
                    <s:annotation>
                        <s:documentation>CMS APC methodology expected.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="APCVersion" type="s:string">
                    <s:annotation>
                        <s:documentation>Version identifier of the APC Grouper used.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PrepaidAmount" type="Numeric">
                    <s:annotation>
                        <s:documentation>The amount the carrier or its designee has pre-paid towards a claim line.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="CopayAmount" type="Numeric">
                    <s:annotation>
                        <s:documentation>The copay amount applied to a claim line or full claim as calculated by the carrier or its designee.&lt;br&gt;
837apP:	loop2300().loop2400().loop2430(1).CAS(1):MonetaryAmount&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="CoinsuranceAmount" type="Numeric">
                    <s:annotation>
                        <s:documentation>The coinsurance amount applied to a claim line or full claim as calculated by the carrier or its designee.&lt;br&gt;
837apP:	loop2300().loop2400().loop2430(1).CAS(1):MonetaryAmount2&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="AuthorizationNumber" type="s:string"/>
                <s:element minOccurs="0" name="AuthorizationNeeded">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if a claim line requires an authorization by the carrier or its designee.&lt;br&gt;
837apP:	loop2300().loop2400().REF(1):RefIdQualifier&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="ClaimLineType" type="ClaimLineType">
                    <s:annotation>
                        <s:documentation>A code that reports the final outcome of the claim line during the submission period of the carrier or its designee.&lt;br&gt;
Example: Original, Void, Replacement, Back Out, Amendment.Mbr&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="COBAmount" type="Numeric"/>
                <s:element minOccurs="0" name="CoInsuranceDays" type="Numeric"/>
                <s:element minOccurs="0" name="CoveredDays" type="Numeric">
                    <s:annotation>
                        <s:documentation>Amount of inpatient days paid for by the carrier.&lt;br&gt;
If not available, the number of days authorized by the carrier for the admission.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DischargeDate" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>The date the Member was discharged from the inpatient facility.&lt;br&gt;
 Inpatient claims may or may not repeat this date on all lines.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DeniedFlag">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if the claim line was denied by the claims processor.&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="DeniedReasonCode" type="DeniedReasonCode">
                    <s:annotation>
                        <s:documentation>The Claim Line denial reason as assigned by the carrier or its designee.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DiagnosticPointer" type="Numeric">
                    <s:annotation>
                        <s:documentation>A numeric indicator that aligns each claim line service to a diagnosis:&lt;br&gt;
1 for Principal Diagnosis;  2 for Other Diagnosis-1;  3 for Other Diagnosis-2, etc.&lt;br&gt;
837apP:	loop2300().loop2400().SV1:CompositeDiagnosisCodePointe&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DrugCode" type="DrugProduct">
                    <s:annotation>
                        <s:documentation>A standard NDC Code as defined by the FDA in 5-4-2 format without hyphenation.&lt;br&gt;
837apP:	loop2300().loop2400().loop2410.LIN:ProductServiceID&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ECode" type="DiagnosisCode">
                    <s:annotation>
                        <s:documentation>The ICD9 External Injury code for Patients with trauma or accidents.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="EPSDTIndicator">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports the claim line service's relation to EPSDT services.&lt;br&gt;
837apP:	loop2300().loop2400().SV1:YesNoConditionorResponseCode2&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="0"/>
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="ExcludeExpense" type="Numeric">
                    <s:annotation>
                        <s:documentation>The amount that a carrier or its designee has determined to be over the plan limitations for Patient utilization.&lt;br&gt;
837apP:	loop2300().loop2400().loop2430(1).CAS(1):MonetaryAmount&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="FamilyPlanningIndicator" type="FamilyPlanning">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports the claim line service's relation to family planning.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DeductibleAmount" type="Numeric">
                    <s:annotation>
                        <s:documentation>The deductible amount applied to a claim line or full claim as calculated by the carrier or its designee.&lt;br&gt;
837apP:	loop2300().loop2400().loop2430(1).CAS(1):MonetaryAmount&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="MedicarePaidAmount" type="Numeric">
                    <s:annotation>
                        <s:documentation>The amount that Medicare paid towards this claim line prior to carrier adjudication.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="WithholdAmount" type="Numeric">
                    <s:annotation>
                        <s:documentation>The amount paid to the provider for this service if the provider qualifies / meets performance guarantees.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PatientOutOfPocketAmount" type="Numeric"/>
                <s:element minOccurs="0" name="OtherInsurancePaid" type="Numeric"/>
                <s:element minOccurs="0" name="FinancialClaimNumber" type="s:string"/>
                <s:element minOccurs="0" name="LOINCCode" type="Order">
                    <s:annotation>
                        <s:documentation>The Logical Observation Identifiers, Names and Code for laboratory test / results for the claim line.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="NonCoveredDays" type="Numeric">
                    <s:annotation>
                        <s:documentation>Amount of inpatient days that were not paid for by the plan for the inpatient event.&lt;br&gt;
Enter 0 when not applicable.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ActualPaidDate" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>The date that appears on the check and/or remit and/or explanation of benefits
and corresponds to any and all types of payment for this claim line (Claims paid in full, partial or zero paid).&lt;br&gt;
837apP:	loop2300().loop2400().loop2430(1).DTP:DateTimePeriod&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PCPIndicator">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if a claim line was performed by the Patient's assigned Primary Care Provider.&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="FacilityTypeProfessional" type="s:string"/>
                <s:element minOccurs="0" name="PrimaryProcedureCode" type="ProcedureCode">
                    <s:annotation>
                        <s:documentation>Primary ICD-9 procedure code.  The Integer point is not coded.  
The ICD-9 procedure must be repeated for all lines of the claim if necessary.  
Required for inpatient institutional claims.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ProcedureCodeType" type="ProcedureCodeType">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports the type of procedure code expected on this claim line.&lt;br&gt;
837apP:	loop2300().loop2400().HCP:ProductServiceIDQualifier&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ProcedureCode" type="ProcedureCode">
                    <s:annotation>
                        <s:documentation>The procedure code reported for this claim line.&lt;br&gt;
837apP:	loop2300().loop2400().HCP:ProductServiceID2&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ProcedureModifiers" type="ArrayOfProcedureModifiersItemString">
                    <s:annotation>
                        <s:documentation>The modifiers for the procedure code reported on this claim line.&lt;br&gt;
837apP:	loop2300().loop2400().loop2430(1).SVD:CompositeMedicalProcedureIde.ProcedureModifier&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="OtherProcedures" type="ArrayOfProcedureProcedureCode">
                    <s:annotation>
                        <s:documentation>Other ICD-9 procedure codes.&lt;br&gt;
The Integer point is not coded.&lt;br&gt; 
The ICD-9 procedure must be repeated for all lines of the claim if necessary.&lt;br&gt;  
Required for inpatient institutional claims.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ReferralIndicator">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if a claim line requires a referral by the carrier or its designee.&lt;br&gt;
837apP:	loop2300().loop2400().REF(1).RefIdQualifier&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="RevenueCode" type="Revenue">
                    <s:annotation>
                        <s:documentation>A standardized code that reports the revenue center of a facility where the claim line service occurred.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="SurgicalPx" type="ArrayOfProcedureProcedureCode"/>
                <s:element minOccurs="0" name="Quantity" type="Numeric">
                    <s:annotation>
                        <s:documentation>Count of services/units performed.&lt;br&gt;
837apP:	loop2300().loop2400().HCP:Quantity&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="InNetworkIndicator">
                    <s:annotation>
                        <s:documentation>Numeric indicator that reports if a claim line was processed / paid at In-Network rates.&lt;br&gt;
837apP:	loop2300().loop2400().HCP:PolicyComplianceCode&lt;br&gt;</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:enumeration value="1"/>
                            <s:enumeration value="2"/>
                            <s:enumeration value="3"/>
                            <s:enumeration value="4"/>
                            <s:enumeration value="5"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="ReferringProvider" type="CareProvider">
                    <s:annotation>
                        <s:documentation>837apP:	loop2300().loop2400().loop2420F(1).REF(1):RefIdQualifier&lt;br&gt;
837apP:	loop2300().loop2400().loop2420F(1).REF(1):RefId&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ServiceProvider" type="CareProvider"/>
                <s:element minOccurs="0" name="HealthFunds" type="ArrayOfHealthFund">
                    <s:annotation>
                        <s:documentation>List of health funds associated with the claim line&lt;br&gt;&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="MedicalClaimLineExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PaymentReason">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="PaymentReasonExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="PaymentReasonExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ClaimLineType">
    <s:annotation>
        <s:documentation>O	Original
V	Void
R	Replacement
B	Back Out
A	Amendment</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ClaimLineTypeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ClaimLineTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DeniedReasonCode">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="DeniedReasonCodeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="DeniedReasonCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="FamilyPlanning">
    <s:annotation>
        <s:documentation>0	Unknown / Not Applicable / Not Avail
1	Family planning services provided
2	Abortion services provided
3	Sterilization services provided
4	No family planning services provided</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="FamilyPlanningExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="FamilyPlanningExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ProcedureCodeType">
    <s:annotation>
        <s:documentation>0	Carrier Custom Code
1	CPT or HCPCS Level 1 Code
2	HCPCS Level II Code
3	HCPCS Level III Code (State Medicare code).
4	American Dental Association (ADA) Procedure Code (Also referred to as CDT code.)
5	State defined Procedure Code</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ProcedureCodeTypeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ProcedureCodeTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfProcedureModifiersItemString">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="ProcedureModifiersItem" nillable="true" type="s:string"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfProcedureProcedureCode">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Procedure" nillable="true" type="ProcedureCode"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Revenue">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="RevenueExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="RevenueExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="MedicalClaimExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ClaimStatus">
    <s:annotation>
        <s:documentation>01	Processed as primary
02	Processed as secondary
03	Processed as tertiary
04	Denied
19	Processed as primary, forwarded to additional payer(s)
20	Processed as secondary, forwarded to additional payer(s)
21	Processed as tertiary, forwarded to additional payer(s)
22	Reversal of previous payment</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ClaimStatusExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ClaimStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DischargeStatus">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="DischargeStatusExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="DischargeStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfDiagnosisDiagnosisCode">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Diagnosis" nillable="true" type="DiagnosisCode"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfPharmacyClaim">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="PharmacyClaim" nillable="true" type="PharmacyClaim"/>
    </s:sequence>
</s:complexType>
<s:complexType name="PharmacyClaim">
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="ClaimProcessedDate" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>The date the claim was processed by the carrier or its designee for adjudication.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="FormerClaimNumber" type="s:string">
                    <s:annotation>
                        <s:documentation>The Payer Claim Control Number previously assigned to this claim line in a prior reporting period.&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ReceivedDate" type="TimeStamp"/>
                <s:element minOccurs="0" name="MedicalClaimLines" type="ArrayOfMedicalClaimLine"/>
                <s:element minOccurs="0" name="Extension" type="PharmacyClaimExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="PharmacyClaimExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfMedicalExplanationOfBenefit">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="MedicalExplanationOfBenefit" nillable="true" type="MedicalExplanationOfBenefit"/>
    </s:sequence>
</s:complexType>
<s:complexType name="MedicalExplanationOfBenefit">
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="AdjudicatedCoverage">
                    <s:annotation>
                        <s:documentation>
ExternalId of the MemberEnrollment with the focal coverage for this claim. 
To generate a valid ExplanationOfBenefit FHIR resource, there must be a corresponding 
MemberEnrollmentNumber in the MemberEnrollment streamlet.</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="450"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="AdjudicationStatus" type="AdjudicationStatus">
                    <s:annotation>
                        <s:documentation>The outcome of the claim.
The corresponding FHIR ValueSet is http://hl7.org/fhir/ValueSet/remittance-outcome</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="BillingProvider" type="Organization">
                    <s:annotation>
                        <s:documentation>Party responsible for the claim.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ClaimProcessedDate" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>The date the claim was processed by the carrier or its designee for adjudication.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ClaimType" type="ClaimType">
                    <s:annotation>
                        <s:documentation>The category of claim, e.g. oral, pharmacy, vision, institutional, professional.
The corresponding FHIR ValueSet is http://hl7.org/fhir/ValueSet/claim-type</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="InOutNetwork" type="BenefitPaymentStatus">
                    <s:annotation>
                        <s:documentation>Indicates the in network or out of network payment status of the claim.
The corresponding FHIR ValueSet is http://hl7.org/fhir/us/carin-bb/ValueSet/BenefitPaymentStatus</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="OtherCoverage" type="ArrayOfOtherCoverageItemString">
                    <s:annotation>
                        <s:documentation>ExternalIds of other MemberEnrollments that represent non-primary coverages for this claim.  
To generate a valid ExplanationOfBenefit FHIR resource, each number must match to a corresponding 
MemberEnrollmentNumber in the MemberEnrollment streamlet.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Payer" type="Organization">
                    <s:annotation>
                        <s:documentation>Party responsible for reimbursement.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Status" type="EOBStatus">
                    <s:annotation>
                        <s:documentation>The status of the Explanation Of Benefit. In FHIR, used to track the status of the resource as 'draft' 
resources may undergo further edits while 'active' resources are immutable and may only have their status 
changed to 'cancelled'.
The corresponding FHIR ValueSet is http://hl7.org/fhir/ValueSet/explanationofbenefit-status</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Use" type="ClaimUse">
                    <s:annotation>
                        <s:documentation>A code to indicate whether the nature of the request is: 
to request adjudication of products and services previously rendered; 
or requesting authorization and adjudication for provision in the future; 
or requesting the non-binding adjudication of the listed products and 
services which could be provided in the future.
The corresponding FHIR ValueSet is http://hl7.org/fhir/ValueSet/claim-use</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Extension" type="MedicalExplanationOfBenefitExtension"/>
                <s:element minOccurs="0" name="Diagnoses" type="ArrayOfDiagnosis">
                    <s:annotation>
                        <s:documentation>Information about diagnoses relevant to the claim items. ICD-10 or ICD-9.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="MedicalClaimNumber">
                    <s:annotation>
                        <s:documentation>Unique identifier within the payer's system that applies to the entire claim.</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="450"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="MedicalEOBLines" type="ArrayOfMedicalEOBLine">
                    <s:annotation>
                        <s:documentation>Details of the products or services provided.</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="AdjudicationStatus">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="AdjudicationStatusExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="AdjudicationStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ClaimType">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ClaimTypeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ClaimTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="BenefitPaymentStatus">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="BenefitPaymentStatusExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="BenefitPaymentStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfOtherCoverageItemString">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="OtherCoverageItem" nillable="true">
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="450"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="EOBStatus">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="EOBStatusExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="EOBStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ClaimUse">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ClaimUseExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ClaimUseExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="MedicalExplanationOfBenefitExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfMedicalEOBLine">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="MedicalEOBLine" nillable="true" type="MedicalEOBLine"/>
    </s:sequence>
</s:complexType>
<s:complexType name="MedicalEOBLine">
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="Quantity" type="Numeric">
                    <s:annotation>
                        <s:documentation>The number of repetitions of a service or product.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DeniedReasonCode" type="DeniedReasonCode">
                    <s:annotation>
                        <s:documentation>A code supporting the understanding of the adjudication result and explaining variance from expected amount.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="InOutNetwork" type="BenefitPaymentStatus">
                    <s:annotation>
                        <s:documentation>Indicates the in network or out of network payment status of the Explanation Of Benefit item.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="LineCounter" type="Numeric">
                    <s:annotation>
                        <s:documentation>The line number for this service on the claim.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Extension" type="MedicalEOBLineExtension"/>
                <s:element minOccurs="0" name="RevenueCode" type="Revenue">
                    <s:annotation>
                        <s:documentation>Revenue or cost center code.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ProcedureCode" type="ProcedureCode">
                    <s:annotation>
                        <s:documentation>Medical procedure a patient received from a health care provider.
Coding methods include: CPT-4 and HCFA Common Procedure Coding System Level II - (HCPCSII).</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ProcedureModifiers" type="ArrayOfProcedureModifier">
                    <s:annotation>
                        <s:documentation>Modifier(s) for the procedure represented on this line.
Identifies special circumstances related to the performance of the service.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="AllowedUnits" type="Numeric">
                    <s:annotation>
                        <s:documentation>Allowed number of units.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PlaceOfService" type="PlaceOfService">
                    <s:annotation>
                        <s:documentation>Place of service or where product was supplied.</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="MedicalEOBLineExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfProcedureModifier">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="ProcedureModifier" nillable="true" type="ProcedureModifier"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ProcedureModifier">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="ProcedureModifierExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ProcedureModifierExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PlaceOfService">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="PlaceOfServiceExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="PlaceOfServiceExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfPharmacyExplanationOfBenefit">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="PharmacyExplanationOfBenefit" nillable="true" type="PharmacyExplanationOfBenefit"/>
    </s:sequence>
</s:complexType>
<s:complexType name="PharmacyExplanationOfBenefit">
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="AdjudicatedCoverage">
                    <s:annotation>
                        <s:documentation>
ExternalId of the MemberEnrollment with the focal coverage for this claim. 
To generate a valid ExplanationOfBenefit FHIR resource, there must be a corresponding 
MemberEnrollmentNumber in the MemberEnrollment streamlet.</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="450"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="AdjudicationStatus" type="AdjudicationStatus">
                    <s:annotation>
                        <s:documentation>The outcome of the claim.
The corresponding FHIR ValueSet is http://hl7.org/fhir/ValueSet/remittance-outcome</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="BillingProvider" type="Organization">
                    <s:annotation>
                        <s:documentation>Party responsible for the claim.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ClaimProcessedDate" type="TimeStamp">
                    <s:annotation>
                        <s:documentation>The date the claim was processed by the carrier or its designee for adjudication.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ClaimType" type="ClaimType">
                    <s:annotation>
                        <s:documentation>The category of claim, e.g. oral, pharmacy, vision, institutional, professional.
The corresponding FHIR ValueSet is http://hl7.org/fhir/ValueSet/claim-type</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="InOutNetwork" type="BenefitPaymentStatus">
                    <s:annotation>
                        <s:documentation>Indicates the in network or out of network payment status of the claim.
The corresponding FHIR ValueSet is http://hl7.org/fhir/us/carin-bb/ValueSet/BenefitPaymentStatus</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="OtherCoverage" type="ArrayOfOtherCoverageItemString">
                    <s:annotation>
                        <s:documentation>ExternalIds of other MemberEnrollments that represent non-primary coverages for this claim.  
To generate a valid ExplanationOfBenefit FHIR resource, each number must match to a corresponding 
MemberEnrollmentNumber in the MemberEnrollment streamlet.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Payer" type="Organization">
                    <s:annotation>
                        <s:documentation>Party responsible for reimbursement.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Status" type="EOBStatus">
                    <s:annotation>
                        <s:documentation>The status of the Explanation Of Benefit. In FHIR, used to track the status of the resource as 'draft' 
resources may undergo further edits while 'active' resources are immutable and may only have their status 
changed to 'cancelled'.
The corresponding FHIR ValueSet is http://hl7.org/fhir/ValueSet/explanationofbenefit-status</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Use" type="ClaimUse">
                    <s:annotation>
                        <s:documentation>A code to indicate whether the nature of the request is: 
to request adjudication of products and services previously rendered; 
or requesting authorization and adjudication for provision in the future; 
or requesting the non-binding adjudication of the listed products and 
services which could be provided in the future.
The corresponding FHIR ValueSet is http://hl7.org/fhir/ValueSet/claim-use</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Extension" type="PharmacyExplanationOfBenefitExtension"/>
                <s:element minOccurs="0" name="PharmacyClaimNumber">
                    <s:annotation>
                        <s:documentation>Unique identifier within the payer's system that applies to the entire claim.</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="450"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="DaysSupply" type="Numeric">
                    <s:annotation>
                        <s:documentation>Number of days supply of medication dispensed by the pharmacy.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DispensedAsWritten" type="DispensedAsWritten">
                    <s:annotation>
                        <s:documentation>Prescriber's instruction regarding substitution of generic equivalents
or order to dispense the specific prescribed medication.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="RefillNumber" type="Numeric">
                    <s:annotation>
                        <s:documentation>The number fill of the current dispensed supply (0, 1, 2, etc.)</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PrescriptionOrigin" type="PrescriptionOrigin">
                    <s:annotation>
                        <s:documentation>Whether the prescription was transmitted as an electronic prescription, 
by phone, by fax, or as a written paper copy.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="BrandGenericIndicator" type="BrandGenericIndicator">
                    <s:annotation>
                        <s:documentation>Whether the plan adjudicated the claim as a brand or generic drug.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="CompoundCode" type="CompoundCode">
                    <s:annotation>
                        <s:documentation>NCPDP Compound Code.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="PharmacyEOBLines" type="ArrayOfPharmacyEOBLine">
                    <s:annotation>
                        <s:documentation>Details of the drugs provided.</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="PharmacyExplanationOfBenefitExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="DispensedAsWritten">
    <s:annotation>
        <s:documentation>Prescriber's instruction regarding substitution of generic equivalents
or order to dispense the specific prescribed medication.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="DispensedAsWrittenExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="DispensedAsWrittenExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="PrescriptionOrigin">
    <s:annotation>
        <s:documentation>Whether the prescription was transmitted as an electronic prescription, 
by phone, by fax, or as a written paper copy.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="PrescriptionOriginExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="PrescriptionOriginExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="BrandGenericIndicator">
    <s:annotation>
        <s:documentation>Whether the plan adjudicated the claim as a brand or generic drug.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="BrandGenericIndicatorExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="BrandGenericIndicatorExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="CompoundCode">
    <s:annotation>
        <s:documentation>NCPDP Compound Code.</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="CompoundCodeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="CompoundCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfPharmacyEOBLine">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="PharmacyEOBLine" nillable="true" type="PharmacyEOBLine"/>
    </s:sequence>
</s:complexType>
<s:complexType name="PharmacyEOBLine">
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="Quantity" type="Numeric">
                    <s:annotation>
                        <s:documentation>The number of repetitions of a service or product.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="DeniedReasonCode" type="DeniedReasonCode">
                    <s:annotation>
                        <s:documentation>A code supporting the understanding of the adjudication result and explaining variance from expected amount.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="InOutNetwork" type="BenefitPaymentStatus">
                    <s:annotation>
                        <s:documentation>Indicates the in network or out of network payment status of the Explanation Of Benefit item.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="LineCounter" type="Numeric">
                    <s:annotation>
                        <s:documentation>The line number for this service on the claim.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Extension" type="PharamacyEOBLineExtension"/>
                <s:element minOccurs="0" name="DrugCode" type="DrugProduct">
                    <s:annotation>
                        <s:documentation>NDC Code for a non-compound drug.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="CompoundMedication" type="ArrayOfDrugProduct">
                    <s:annotation>
                        <s:documentation>The list of ingredients in the compound medication.</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="PharamacyEOBLineExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfCustomObject">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="CustomObject" nillable="true" type="CustomObject"/>
    </s:sequence>
</s:complexType>
<s:complexType name="CustomObject">
    <s:annotation>
        <s:documentation>Generic SDA3 custom object, to hold a collection of NVPairs&lt;br&gt;&lt;br&gt;
To display CustomObjects in the Clinical Viewer:&lt;br&gt;
1. In [install-dir]\distlib\trak\misc\, create a file&lt;br&gt;
SITE-Default-CustomObject.txt. Copy to it the single entry from the&lt;br&gt;
HS-Default file:&lt;br&gt;
PROGRAMS^Program Membership^ProgramName,ProgramDescription&lt;br&gt;
2. Add an entry for each type of CustomObject in the form:&lt;br&gt;
Code^Description^Fields&lt;br&gt;
Where "Fields" is a comma-delimited list of fields (NVPair Names) the&lt;br&gt;
CustomObject can have. "Code" is the CustomType of the CustomObjects to&lt;br&gt;
be displayed. "Description" is what will appear in the viewer.&lt;br&gt;
3. Load this data into the Access Gateway by doing a reset:&lt;br&gt;
do ##class(HS.Util.Installer.AccessGateway).Reset()&lt;br&gt;
4. Log in to Trak to edit the viewer.&lt;br&gt;
5. The CustomObjects will be displayed via a Questionnaire Profile. Either&lt;br&gt;
create a new chart to display the profile or pick an existing one to add it&lt;br&gt;
to.&lt;br&gt;
6. On the Chart Setup screen, click "Add/Edit Questionnaire Profile".&lt;br&gt;
7. Fill in a name for the Questionnaire Profile, and under Questionnaire&lt;br&gt;
Group, select the option corresponding to the desired CustomType. (This&lt;br&gt;
list is populated by the Codes and Descriptions from either the HS- or&lt;br&gt;
SITE-Default-CustomObject.txt file.)  Click "Update".&lt;br&gt;
8. Add the newly created Questionnaire Profile to the chart and click&lt;br&gt;
"Update".&lt;br&gt;
9. On the chart, the columns that will contain the Values from CustomPairs&lt;br&gt;
will initially be called "Significant Answer 1", "Significant Answer 2",&lt;br&gt;
etc. The Column Editor may be used to control which columns are displayed,&lt;br&gt;
and the Layout Editor may be used to set the names of the columns.&lt;br&gt;</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Source System name&lt;br&gt;&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End of time range</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomType" type="s:string">
            <s:annotation>
                <s:documentation>A short string classifying this custom object&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
In the OnValidate method of the Streamlet class, the InfoSubType property&lt;br&gt;
of the streamlet is set to the value of the CustomType, converted to&lt;br&gt;
uppercase. Also, ActionScope matches on CustomType. See the ActionScope&lt;br&gt;
property for more info.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Clinical Viewer is configured to display CustomObjects (see above),&lt;br&gt;
they will be grouped by CustomType.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CustomMatchKey">
            <s:annotation>
                <s:documentation>In addition to CustomType, this is one of the match properties used to&lt;br&gt;
determine if an inbound CustomObject matches an existing one.  This will&lt;br&gt;
probably be computed from some concatenation of Values from CustomPairs.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
When the Access Gateway is reset and the HS- or SITE-Default-&lt;br&gt;
CustomObject.txt file is loaded, a class will be generated in the Access&lt;br&gt;
namespace for each entry in the file. The name of the class will be&lt;br&gt;
"questionnaire.Q[ShortUpperCode]", where [ShortUpperCode] is the first 10&lt;br&gt;
characters of the Code from the file, converted to uppercase. A property&lt;br&gt;
will be generated in this class for each field named in the entry. The name&lt;br&gt;
of the property will be "Q[field]", where [field] is the field from the&lt;br&gt;
entry.&lt;br&gt;
When attempting to load a CustomObject into the Viewer Cache, first a check&lt;br&gt;
is made to see if there is a class for the object's CustomType. If there&lt;br&gt;
is, the CustomPairs list is iterated over and every NVPair whose Name&lt;br&gt;
corresponds to a property of the class will have its Value stored in that&lt;br&gt;
property.&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.Qxxx(Qyyy)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
For this property to be stored in the Viewer Cache, there must be an entry&lt;br&gt;
in the HS- or SITE-Default-CustomObject.txt file with Code=CustomType of&lt;br&gt;
this object. The class it is stored to will be&lt;br&gt;
"questionnaire.Q[ShortUpperCode]", where [ShortUpperCode] is the first 10&lt;br&gt;
characters of the Code from the file, converted to uppercase.&lt;br&gt;&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: questionnaire.Qxxx(QUESUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Viewer cache:&lt;br&gt;
For this property to be stored in the Viewer Cache, there must be an entry&lt;br&gt;
in the HS- or SITE-Default-CustomObject.txt file with Code=CustomType of&lt;br&gt;
this object. The class it is stored to will be&lt;br&gt;
"questionnaire.Q[ShortUpperCode]", where [ShortUpperCode] is the first 10&lt;br&gt;
characters of the Code from the file, converted to uppercase.&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.Qxxx(QUESDate) + questionnaire.Qxxx(QUESTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
C = Clear All&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation on the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>See the annotation on the superclass property for more information on how&lt;br&gt;
ActionScope is used.&lt;br&gt;
If the ActionCode of an inbound CustomObject is "C" and ActionScope is not&lt;br&gt;
null, then only CustomObjects with CustomType = ActionScope&lt;br&gt;
(case-insensitive) will be deleted.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfGenomicsOrder">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="GenomicsOrder" nillable="true" type="GenomicsOrder"/>
    </s:sequence>
</s:complexType>
<s:complexType name="GenomicsOrder">
    <s:annotation>
        <s:documentation>For genetics orders</s:documentation>
    </s:annotation>
    <s:sequence>
        <s:element minOccurs="0" name="PlacerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the PlacerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId. If the PlacerId, FillerId, ExternalId, and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the LabOrder&lt;br&gt;
will not be processed. If the LabOrder has no OrderItem and does not match&lt;br&gt;
exactly 1 other LabOrder in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId, which itself may have been&lt;br&gt;
defaulted to the Result ExternalId. If PlacerId, FillerId, ExternalId and&lt;br&gt;
Result.ExternalId are all null, an error will be logged and the Order will&lt;br&gt;
not be processed. If the Order has no OrderItem and does not match exactly&lt;br&gt;
1 other Order of the same type in the same Encounter on PlacerId (ALPHAUP&lt;br&gt;
collated), an error will be logged and the Order will not be processed.&lt;br&gt;
-MED,VXU:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if PlacerId is null, it&lt;br&gt;
is defaulted to ExternalId, then to FillerId. If the Order has no OrderItem&lt;br&gt;
or DrugProduct and does not match exactly 1 other Order of the same type in&lt;br&gt;
the same Encounter on PlacerId (ALPHAUP collated), an error will be logged&lt;br&gt;
and the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-2.1 : PlacerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPlacerNo)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="PlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-2 will be used if a value can be parsed from it, else ORC-2 will be&lt;br&gt;
used. In either case, PlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-2.2 : PlacerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-2.3 : PlacerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-2.4 : PlacerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerId">
            <s:annotation>
                <s:documentation>The ID assigned to the order when it was filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3.1 will be used if present, else ORC-3.1 will be used.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
The processing the FillerId undergoes in the Streamlet Cache is dependent&lt;br&gt;
on the type of Order being processed:&lt;br&gt;
-LAB:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId, then to PlacerId, which itself&lt;br&gt;
may have been defaulted to ExternalId. If FillerId, PlacerId, ExternalId,&lt;br&gt;
and Result.ExternalId are all null, an error will be logged and the&lt;br&gt;
LabOrder will not be processed.&lt;br&gt;
-RAD,OTH:&lt;br&gt;
In the OnBeforeMatch method of the Streamlet class, if FillerId is null, it&lt;br&gt;
will be defaulted to the Result ExternalId. If FillerId, PlacerId,&lt;br&gt;
ExternalId, and Result.ExternalId are all null, an error will be logged and&lt;br&gt;
the Order will not be processed.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For LabOrders only, if FillerId is null and Result.ResultType = "AT", then&lt;br&gt;
FillerId will be defaulted to PlacerId. Also for LabOrders only, the stored&lt;br&gt;
value for FillerId in the Viewer Cache is required to be unique. If an&lt;br&gt;
inbound LabOrder.FillerId matches one already in the Viewer Cache (if the&lt;br&gt;
same patient record has been loaded multiple times, for example), the&lt;br&gt;
inbound value is made unique by appending "x[OEORDId]" to it, where&lt;br&gt;
"[OEORDId]" is the ID of the parent OEOrder to the OEOrdItem that the&lt;br&gt;
LabOrder is stored as.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
HL7:  OBR-3.1 : FillerOrderNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIFillerNo)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabEpisodeNo)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="FillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-3 will be used if a value can be parsed from it, else ORC-3 will be&lt;br&gt;
used. In either case, FillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  ORC-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  ORC-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
HL7:  OBR-3.2 : FillerOrderNumber.NamespaceID&lt;br&gt;
HL7:  OBR-3.3 : FillerOrderNumber.UniversalID&lt;br&gt;
HL7:  OBR-3.4 : FillerOrderNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="OrderItem" type="Order">
            <s:annotation>
                <s:documentation>What was ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-4 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Medications and Vaccinations, in the OnBeforeMatch method of the&lt;br&gt;
Streamlet class, if the Order has no OrderItem but does have a DrugProduct,&lt;br&gt;
then an OrderItem will be defaulted in with Code, Description, and&lt;br&gt;
SDACodingStandard copied from the DrugProduct. For all types of Orders (and&lt;br&gt;
for Medications and Vaccinations, following this defaulting), if the Order&lt;br&gt;
has no OrderItem and does not match exactly 1 other Order of the same type&lt;br&gt;
in the same Encounter on PlacerId (ALPHAUP collated), an error will be&lt;br&gt;
logged and the Order will not be processed. In the OnValidate method, if&lt;br&gt;
the Order does not have an OrderItem (if it was deleted in an update, for&lt;br&gt;
example), an error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7: OBR-4 : UniversalServiceIdentifier&lt;br&gt;
SDATableName=Order, ViewerClass=User.HS.ARCItmMast&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItmMastDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
Viewer cache:&lt;br&gt;
TRName is for text results only.&lt;br&gt;
HL7:  OBR-4.1 : UniversalServiceIdentifier.Identifier&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMCode)&lt;br&gt;
VIEWERLIB: User.HS.OETextResult(TRName)&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-4.2 : UniversalServiceIdentifier.Text&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-4.3 : UniversalServiceIdentifier.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-4.7 : UniversalServiceIdentifier.CodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
In addition to subfield 1 or 2 not being null, if subfield 4 or 5 is not&lt;br&gt;
null, then subfields 4, 5, 6, and 8 will be parsed into the Code,&lt;br&gt;
Description, CodeSystem, and CodeSystemVersionId, respectively, of a&lt;br&gt;
PriorCode in the list of PriorCodes. In this case, the PriorCode Type is&lt;br&gt;
set to "A".&lt;br&gt;
HL7:  OBR-4.4 : UniversalServiceIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-4.5 : UniversalServiceIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-4.6 : UniversalServiceIdentifier.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-4.8 : UniversalServiceIdentifier.AlternateCodingSystemVersionID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.OriginalText&lt;br&gt;
HL7:  OBR-4.9 : UniversalServiceIdentifier.OriginalText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderCategory" type="OrderCategory">
            <s:annotation>
                <s:documentation>Can be used to group orders in the Clinical Viewer.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-24 is parsed to the OrderCategory Code. HL7ToSDA3 does not set the&lt;br&gt;
Description. The parsed value is converted to uppercase in the SDA.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For all Order types, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order has an OrderCategory, then the InfoSubType of the streamlet is&lt;br&gt;
set to the OrderCategory Code, converted to uppercase.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
The OrderCategory is stored as a property of the ARCItmMast (OrderItem),&lt;br&gt;
which is itself a property of the OEOrderItem (Order).&lt;br&gt;&lt;br&gt;
HL7:  OBR-24 : DiagnosticServSectID&lt;br&gt;
SDATableName=OrderCategory, ViewerClass=User.HS.ARCItemCat&lt;br&gt;
VIEWERLIB: User.HS.ARCItmMast(ARCIMItemCatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderQuantity" type="s:string">
            <s:annotation>
                <s:documentation>Number of items ordered&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderQuantity is parsed from (in order of precendence) TQ1-2.1, RXE-1.1.1,&lt;br&gt;
OBR-27.1.1, or ORC-7.1.1. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Quantity in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  OBR-27.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  RXE-1.1.1 : QuantityTiming.Quantity.Quantity&lt;br&gt;
HL7:  TQ1-2.1   : Quantity.Quantity&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIQty)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>Who placed the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OrderedBy is parsed from (in order of precendence) OBR-16, RXO-14, RXE-13,&lt;br&gt;
or ORC-12 and -24. Though each of these fields is repeating, for each one&lt;br&gt;
except ORC-24, HL7ToSDA3 will only parse the first non-null instance. For&lt;br&gt;
ORC-24, the instance corresponding to the first non-null instance of ORC-12&lt;br&gt;
will be parsed. ORC-12 and -24 are used in combination to set the&lt;br&gt;
provider's Name and Address in the SDA. Every other field only sets the&lt;br&gt;
Name. For Adress.City, .State, .Zip, .Country, and .County as well as NameTypeCode&lt;br&gt;
and IdentifierTypeCode, only the Code is parsed. HL7ToSDA3 does not set the&lt;br&gt;
Description. Note that an RDE_O11 message technically can contain both an&lt;br&gt;
RXO segment and an RXE, however HL7ToSDA3 does not parse the RXO segment&lt;br&gt;
from an RDE message.&lt;br&gt;&lt;br&gt;
HL7:  ORC-12 : OrderingProvider&lt;br&gt;
HL7:  ORC-24 : OrderingProviderAddress&lt;br&gt;
HL7:  RXE-13 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  RXO-14 : OrderingProvidersDEANumber&lt;br&gt;
HL7:  OBR-16 : OrderingProvider&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDoctorDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-12.1 : OrderingProvider.IDNumber&lt;br&gt;
HL7:  RXE-13.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  RXO-14.1 : OrderingProvidersDEANumber.IDNumber&lt;br&gt;
HL7:  OBR-16.1 : OrderingProvider.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-12.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
HL7:  RXE-13.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  RXO-14.9 : OrderingProvidersDEANumber.AssigningAuthority&lt;br&gt;
HL7:  OBR-16.9 : OrderingProvider.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-12.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
HL7:  RXE-13.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  RXO-14.2.1 : OrderingProvidersDEANumber.FamilyName.Surname&lt;br&gt;
HL7:  OBR-16.2.1 : OrderingProvider.FamilyName.Surname&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-12.3 : OrderingProvider.GivenName&lt;br&gt;
HL7:  RXE-13.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  RXO-14.3 : OrderingProvidersDEANumber.GivenName&lt;br&gt;
HL7:  OBR-16.3 : OrderingProvider.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-12.4 : OrderingProvider.MiddleName&lt;br&gt;
HL7:  RXE-13.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  RXO-14.4 : OrderingProvidersDEANumber.MiddleName&lt;br&gt;
HL7:  OBR-16.4 : OrderingProvider.MiddleName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-12.6 : OrderingProvider.NamePrefix&lt;br&gt;
HL7:  RXE-13.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  RXO-14.6 : OrderingProvidersDEANumber.NamePrefix&lt;br&gt;
HL7:  OBR-16.6 : OrderingProvider.NamePrefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-24.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-24.1.1.&lt;br&gt;
HL7:  ORC-24.1.1 : OrderingProviderAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-24.2 : OrderingProviderAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPStName)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-24.3 : OrderingProviderAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCityDR)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-24.4 : OrderingProviderAddress.StateorProvince&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-24.5 : OrderingProviderAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-24.6 : OrderingProviderAddress.Country&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-24.9 : OrderingProviderAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.NameTypeCode&lt;br&gt;
HL7:  OBR-16.10 : OrderingProvider.NameTypeCode&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.IdentifierTypeCode&lt;br&gt;
HL7:  OBR-16.13 : OrderingProvider.IdentifierTypeCode&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteringOrganization" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Entering Facility (Location)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-13 is only parsed if subfield 1 is not null. Only the Code is parsed.&lt;br&gt;
HL7ToSDA3 does not set the Description.&lt;br&gt;&lt;br&gt;
HL7:  ORC-13.1 : EnterersLocation.PointofCare&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIOrdDeptDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Only the Code is parsed. HL7ToSDA3 does not set the Description.&lt;br&gt;
HL7:  MSH-4.1 : SendingFacility.NamespaceID&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedBy" type="CareProvider">
            <s:annotation>
                <s:documentation>VerifiedBy (CareProvider)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-32 will be used if present, else the first non-null instance of ORC-11&lt;br&gt;
will be used, if there is one.&lt;br&gt;&lt;br&gt;
HL7:  ORC-11 : VerifiedBy&lt;br&gt; 
HL7:  OBR-32 : PrincipalResultInterpreter&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthoriseClinicianDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-11.1 : VerifiedBy.IDNumber&lt;br&gt;
HL7:  OBR-32.1.1 : PrincipalResultInterpreter.Name.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
For both fields, the given and family names are concatenated together as&lt;br&gt;
"[Family], [Given]" to make the Description.&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-11.9 : VerifiedBy.AssigningAuthority&lt;br&gt;
HL7:  OBR-32.1.9 : PrincipalResultInterpreter.Name.AssigningAuthorityNamespaceID&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  ORC-11.2.1 : VerifiedBy.FamilyName.Surname&lt;br&gt;
HL7:  OBR-32.1.2 : PrincipalResultInterpreter.Name.FamilyName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPSurname)&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  ORC-11.3 : VerifiedBy.GivenName&lt;br&gt;
HL7:  OBR-32.1.3 : PrincipalResultInterpreter.Name.GivenName&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPFirstName)&lt;br&gt;
.Name.MiddleName&lt;br&gt;
HL7:  ORC-11.4 : VerifiedBy.SecondandFurtherGivenNames&lt;br&gt;
HL7:  OBR-32.1.4 : PrincipalResultInterpreter.Name.SecondandFurtherGivenNames&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPOtherName)&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  ORC-11.6 : VerifiedBy.Prefix&lt;br&gt;
HL7:  OBR-32.1.6 : PrincipalResultInterpreter.Name.Prefix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTitle)&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  ORC-11.7 : VerifiedBy.Degree&lt;br&gt;
HL7:  OBR-32.1.5 : PrincipalResultInterpreter.Name.Suffix&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextTwo)&lt;br&gt;
.Name.ProfessionalSuffix&lt;br&gt;
HL7:  OBR-32.1.7 : PrincipalResultInterpreter.Name.Degree&lt;br&gt;
VIEWERLIB: User.HS.CTCareProv(CTPCPTextThree)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CallbackNumber">
            <s:annotation>
                <s:documentation>Callback number (who to contact with questions, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-17 is used if any regular (business), mobile, or fax numbers or e-mail&lt;br&gt;
addresses can be parsed from it, else ORC-14 is used. In either case, the&lt;br&gt;
format of CallbackNumber is: "[List of business #s], Mobile: [List of&lt;br&gt;
mobile #s], Fax: [List of fax #s], email: [List of e-mail addresses]". Each&lt;br&gt;
list is comma-delimited. Each tag (Mobile, Fax, email) will only be used if&lt;br&gt;
there are elements of that type. For each field, every instance will be&lt;br&gt;
parsed, if that field is used. Up to three numbers can be parsed from each&lt;br&gt;
instance of a field:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, a number is parsed from them&lt;br&gt;
as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-If subfield 12 is not null, it is parsed.&lt;br&gt;
-If subfield 1 is not null, it is parsed.&lt;br&gt;
-Additionally, if subfield 9 is not null, the first number parsed from that&lt;br&gt;
instance will have it appended to the end after a semicolon separator.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;
The logic to determine the type of the number is:&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 is in ["",PH], the&lt;br&gt;
number is a regular (business) number.&lt;br&gt;
-If subfield 2 = "BPN" and subfield 3 is in [CP,BP], the number is a mobile&lt;br&gt;
number.&lt;br&gt;
-If subfield 2 is in ["",WPN,ASN,EMR] and subfield 3 = "FX", the number is&lt;br&gt;
a fax number.&lt;br&gt;
Finally, each non-null instance of subfield 4 is parsed as an e-mail&lt;br&gt;
address.&lt;br&gt;&lt;br&gt;
HL7:  OBR-17 : OrderCallbackPhoneNumber&lt;br&gt;
HL7:  ORC-14 : CallBackPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINotify)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Specimen">
            <s:annotation>
                <s:documentation>Specimen code or description as a string&lt;br&gt;
Not to be confused with the Specimens property of LabOrder, RadOrder, and&lt;br&gt;
OtherOrder, which is of type List of HS.SDA3.Specimen.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-15.1.2 will be used if not null, else OBR-15.1.1 will be used.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Specimen is inserted into the Viewer Cache as a CTSpecimen with SPECCode&lt;br&gt;
and SPECDesc=[Specimen]. The CTSpecimen is the linked to the ARCItmMast&lt;br&gt;
(OrderItem) via an ARCItemSpecimen. Specimen is also inserted as an&lt;br&gt;
OEOrdSpecimen (with SPECCode=[Specimen]) that is linked to the OEOrdItem&lt;br&gt;
(Order). Note that backslash ("\") is a reserved character for the&lt;br&gt;
CTSpecimen table, so Specimen should not contain a backslash.&lt;br&gt;&lt;br&gt;
HL7: OBR-15 : SpecimenSource&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.CTSpecimen&lt;br&gt;
VIEWERLIB: User.HS.OEOrdSpecimen(SPECCode)&lt;br&gt;
VIEWERLIB: User.HS.CTSpecimen(SPECCode) + User.HS.CTSpecimen(SPECDesc)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="SpecimenCollectedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the specimen was collected&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-7.1 and SPM-17.1 represent the same value and therefore should contain&lt;br&gt;
the same value if both are present, however HealthShare does not enforce&lt;br&gt;
this. SPM-17.1 is parsed to Specimen.FromTime.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORIEpisArriveDate and OEORIEpisArriveTime are only set for Lab, Rad, and&lt;br&gt;
Other Orders, not Medications or Vaccinations. SPECDate and SPECTime are&lt;br&gt;
only set if the Order contains a Specimen (the string property, not an&lt;br&gt;
HS.SDA3.Specimen). The properties of lab.HS.EPVisitNumber and&lt;br&gt;
EPVisitTestSet are set for atomic results only. Note that while&lt;br&gt;
VISTSTimeOfCollection is a %Time, EPVISTimeOfCollection is not. It is a&lt;br&gt;
%String value containing the time as a number of minutes since midnight.&lt;br&gt;&lt;br&gt;
HL7:  OBR-7.1 : ObservationDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEpisArriveDate) + User.HS.OEOrdItem(OEORIEpisArriveTime)&lt;br&gt;
VIEWERLIB: User.HS.OEOrdSpecimen(SPECDate) + User.HS.OEOrdSpecimen(SPECTime)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitNumber(EPVISDateOfCollection) + lab.HS.EPVisitNumber(EPVISTimeOfCollection)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitTestSet(VISTSDateOfCollection) + lab.HS.EPVisitTestSet(VISTSDateOfCollection)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SpecimenReceivedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the specimen was received&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
OEORILabReceiveDate and OEORILabReceiveTime are only set for Lab, Rad, and&lt;br&gt;
Other Orders, not Medications or Vaccinations. The properties of&lt;br&gt;
lab.HS.EPVisitNumber are set for atomic results only. Note that&lt;br&gt;
EPVISTimeOfReceiving is not a %Time but rather a %String value containing&lt;br&gt;
the time as a number of minutes since midnight.&lt;br&gt;&lt;br&gt;
HL7: OBR-14.1 : SpecimenReceivedDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILabReceiveDate) + User.HS.OEOrdItem(OEORILabReceiveTime)&lt;br&gt;
VIEWERLIB: lab.HS.EPVisitNumber(EPVISDateOfReceiving) + lab.HS.EPVisitNumber(EPVISTimeOfReceiving)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReassessmentTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>If the Order is not final, this is the date/time when it should be reviewed&lt;br&gt;
and perhaps finalized.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIReassessmentDate) + User.HS.OEOrdItem(OEORIReassessmentTime)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Frequency" type="Frequency">
            <s:annotation>
                <s:documentation>How often (e.g. Code=QID, Desc=QID, Factor=4)&lt;br&gt;
QID is Latin, meaning 4x a day.  BID means 2x day, etc.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Though TQ1-3 is a repeating field, HL7ToSDA3 will only parse the first&lt;br&gt;
non-null instance.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Frequency, then that&lt;br&gt;
Frequency will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-3 : RepeatPattern&lt;br&gt;
SDATableName=Frequency, ViewerClass=User.HS.PHCFreq&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPHFreqDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  TQ1-3.1.1 : RepeatPattern.RepeatPatternCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-3.1.2 : RepeatPattern.RepeatPatternCode.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7:  TQ1-3.5 : RepeatPattern.PeriodQuantity&lt;br&gt;
VIEWERLIB: User.HS.PHCFreq(PHCFRFactor)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Duration" type="Duration">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Duration is parsed from (in order of precedence) TQ1-6, RXE-1.3, OBR-27.3,&lt;br&gt;
or ORC-7.3. The RXE, OBR, and ORC fields will only set the Duration Code.&lt;br&gt;
TQ1-6 will populate the Code, Description, and Factor as described below.&lt;br&gt;
Though ORC-7 is a repeating field, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance. OBR-27 is also a repeating field, and HL7ToSDA3 parses every&lt;br&gt;
non-null instance of it. The last non-null instance of Duration in OBR-27&lt;br&gt;
is the one that takes precedence. Note that an RDE_O11 message may contain&lt;br&gt;
TQ1 segments in two different places. HL7ToSDA3 parses the one following&lt;br&gt;
the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a Duration, then that Duration&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  TQ1-6 : ServiceDuration&lt;br&gt;
SDATableName=Duration, ViewerClass=User.HS.PHCDuration&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDuratDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
When parsing the TQ1-6 field, Code is initially parsed from subfield 2.1&lt;br&gt;
(Units.Identifier). If subfield 1 (Quantity) is not null, then if subfields&lt;br&gt;
2.1 and 2.2 (Units.Text) are null, Code will be parsed from Quantity. Then,&lt;br&gt;
if Quantity starts with a non-zero number and the parsed value for Code&lt;br&gt;
does not, the parsed value for Code is set to +[Quantity]_[Code]. For&lt;br&gt;
example, if Quantity="2" and Units.Identifier="D", the value parsed to Code&lt;br&gt;
is "2D". For the other segments that Duration Code may be parsed from (RXE,&lt;br&gt;
OBR, ORC), the value is simply parsed from the field listed below.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  RXE-1.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  OBR-27.3 : QuantityTiming.Duration&lt;br&gt;
HL7:  ORC-7.3 : QuantityTiming.Duration&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUCode)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null and +[Quantity] is logically "true",&lt;br&gt;
and if TQ1-6.2.2 (Units.Text) is not null and +[Units.Text] is logically&lt;br&gt;
"false" (basically, if Quantity starts with a number and Units.Text&lt;br&gt;
doesn't), then the value parsed to Description is&lt;br&gt;
+[Quantity]_" "_[Units.Text]. For example, if Quantity="2" and&lt;br&gt;
Units.Text="Days", the value parsed to Description is "2 Days". If these&lt;br&gt;
conditions are not all met then the Description is simply parsed from&lt;br&gt;
TQ1-6.2.2.&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUDesc1)&lt;br&gt;
.Factor&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If TQ1-6.1 (Quantity) is not null, then if +[Quantity] is logically "true",&lt;br&gt;
Factor is parsed as +[Quantity], otherwise Factor is parsed as null. If&lt;br&gt;
Quantity is null, then if +[TQ1-2.1/Units.Identifier] is logically "true",&lt;br&gt;
Factor is parsed as +[Units.Identifier], else if +[TQ1-2.2/Units.Text] is&lt;br&gt;
logically "true", Factor is parsed as +[Units.Text], else Factor is not&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  TQ1-6.1 : ServiceDuration.Quantity&lt;br&gt;
HL7:  TQ1-6.2.1 : ServiceDuration.Units.Identifier&lt;br&gt;
HL7:  TQ1-6.2.2 : ServiceDuration.Units.Text&lt;br&gt;
VIEWERLIB: User.HS.PHCDuration(PHCDUFactor)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status">
            <s:annotation>
                <s:documentation>The current status of the order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The following values are mapped in the HL7 to SDA3 parsing:&lt;br&gt;
DC-&gt;D, CA-&gt;C, RP-&gt;R, HD-&gt;H, SC-&gt;IP, CM-&gt;E, [Other]-&gt;unchanged&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For any type of Order, in the OnValidate method of the streamlet class, if&lt;br&gt;
Status is null, it is defaulted to "V" for "Verified". Then, for Orders&lt;br&gt;
that can have results (LabOrder, RadOrder, OtherOrder), if the Order has a&lt;br&gt;
Result, Status is set to "E" for "Executed", unless it is "D", "C", "R", or&lt;br&gt;
"H" (for Discontinued, Cancelled, Replaced, or On Hold, respectively). The&lt;br&gt;
reasoning behind setting the Status to "E" is that if the Order has a&lt;br&gt;
Result, then it must have been executed. The reasoning behind the&lt;br&gt;
exceptions to this is that those particular statuses may have been entered&lt;br&gt;
after the Result was submitted. Also, for any type of Order, when Orders of&lt;br&gt;
of that type are inactivated with ActionCode="I", the Status of each will&lt;br&gt;
be set to "I".&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
Status is stored in the Viewer Cache as an OECOrderStatus with OSTATCode&lt;br&gt;
matching Status, ALPHAUP collated. If no such entry in OECOrderStatus&lt;br&gt;
exists, Status will be stored as V/Verified in the Viewer Cache only and an&lt;br&gt;
alert logged in the Ensemble Event Log. Note that the OECOrderStatus table&lt;br&gt;
is loaded from the SITE- or HS-Default-OrderStatus.txt file at the time the&lt;br&gt;
Access Gateway is reset.&lt;br&gt;&lt;br&gt;
HL7:  ORC-5 : OrderStatus&lt;br&gt;
SDATableName=None, ViewerClass=User.HS.OECOrderStatus&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemStatDR)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Priority" type="Priority">
            <s:annotation>
                <s:documentation>The Priority of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Priority is parsed from (in order of precendence) TQ1-9, RXE-1.6, OBR-27.6,&lt;br&gt;
OBR-5, or ORC-7.6. TQ1-9 may set the Code, Description, and&lt;br&gt;
SDACodingStandard. Every other field only sets the Code. Though TQ1-9 and&lt;br&gt;
ORC-7 are repeating fields, HL7ToSDA3 only parses the first non-null&lt;br&gt;
instance of each. OBR-27 is also a repeating field, and HL7ToSDA3 parses&lt;br&gt;
every non-null instance of it. The last non-null instance of Priority in&lt;br&gt;
OBR-27 is the one that takes precedence. Note that an RDE_O11 message may&lt;br&gt;
contain TQ1 segments in two different places. HL7ToSDA3 parses the one&lt;br&gt;
following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
the Order contains no Priority, one is defaulted in with Code="N" and &lt;br&gt;
Description="Normal".&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9   : Priority&lt;br&gt;
SDATableName=Priority, ViewerClass=User.HS.OECPriority&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIPriorityDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-7.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  OBR-5 : PriorityOBR&lt;br&gt;
HL7:  OBR-27.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  RXE-1.6 : QuantityTiming.Priority&lt;br&gt;
HL7:  TQ1-9.1  : Priority.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  TQ1-9.2  : Priority.Text&lt;br&gt;
VIEWERLIB: User.HS.OECPriority(OECPRDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  TQ1-9.3  : Priority.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConfidentialityCode" type="Confidentiality">
            <s:annotation>
                <s:documentation>Confidentiality code (e.g. VIP, etc.)&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-28 will only be parsed if subfield 1 or 2 is not null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-28 : ConfidentialtyCode&lt;br&gt;
SDATableName=Confidentiality, ViewerClass=User.HS.OECOverReasonNonConsent&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORINoConsentOverrideReasDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-28.1 : ConfidentialtyCode.Identifier&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-28.2 : ConfidentialtyCode.Text&lt;br&gt;
VIEWERLIB: User.HS.OECOverReasonNonConsent(ORNCDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-28.3 : ConfidentialtyCode.NameofCodingSystem&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Condition">
            <s:annotation>
                <s:documentation>Condition, e.g. "keep BP below 110"&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Condition is parsed from (in order of precendence) TQ1-10, RXE-1.7,&lt;br&gt;
OBR-27.7, or ORC-7.7. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Condition in OBR-27 is the one that takes precendence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  OBR-27.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  RXE-1.7 : QuantityTiming.Condition&lt;br&gt;
HL7:  TQ1-10  : ConditionText&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILtClinicalCondition)&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="TextInstruction" type="s:string">
            <s:annotation>
                <s:documentation>Text instructions or directions, e.g. "After food", or if Duration etc.&lt;Br&gt;
isn't coded, "Take 3 twice a day"&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
TextInstruction is parsed from (in order of precendence) TQ1-11, RXE-1.8,&lt;br&gt;
OBR-27.8, or ORC-7.8. Though ORC-7 is a repeating field, HL7ToSDA3 only&lt;br&gt;
parses the first non-null instance. OBR-27 is also a repeating field, and&lt;br&gt;
HL7ToSDA3 parses every non-null instance of it. The last non-null instance&lt;br&gt;
of Text in OBR-27 is the one that takes precendence. Note that an RDE_O11&lt;br&gt;
message may contain TQ1 segments in two different places. HL7ToSDA3 parses&lt;br&gt;
the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a TextInstruction, then that&lt;br&gt;
TextInstruction will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.8 : QuantityTiming.Text&lt;br&gt;
HL7:  OBR-27.8 : QuantityTiming.Text&lt;br&gt;
HL7:  RXE-1.8 : QuantityTimingText&lt;br&gt;
HL7:  TQ1-11  : TextInstruction&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIDepProcNotes)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="OrderGroup" type="s:string">
            <s:annotation>
                <s:documentation>This is a way to group related Orders together, such as a prescription&lt;br&gt;
chain.&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIItemGroup)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Order Comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Order Comments are always parsed from NTE segments, though HL7 order&lt;br&gt;
messages may contain NTEs in different places, and only certain ones are&lt;br&gt;
parsed to Order Comments. For ORM and OMP messages, it is the first set of&lt;br&gt;
NTEs following the ORC (in the message schema, not necessarily in the&lt;br&gt;
message) that are parsed to Comments.  In an RDE message the set of NTEs&lt;br&gt;
following the RXE segment are parsed to Order Comments. Order Comments can&lt;br&gt;
only be parsed from an ORU message if it contains a text result (either&lt;br&gt;
ORC-29 is not "LAB", or all OBX-2 values = "FT", "TX", or "ED"). In this&lt;br&gt;
case the NTEs immediately following the OBR are parsed to Order Comments.&lt;br&gt;
In an ORU containing atomic lab results, the NTEs following the OBR are&lt;br&gt;
parsed to the Result Comments, and in an ORU containing Observations&lt;br&gt;
(ORC-29="OBS"), these NTEs are not parsed.&lt;br&gt;&lt;br&gt;
HL7:  NTE-3 : Comment&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRemarks)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ConsultationDepartment" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Department or facility that consulted&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIConsultDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="AuthorizationTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Date/time the order was authorized&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthorisedDate) + User.HS.OEOrdItem(OEORIAuthorisedTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ReceivingLocation" type="HealthCareFacility">
            <s:annotation>
                <s:documentation>Location or facility receiving/performing the order&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
If no Organization is given, one will be defaulted in with Code and&lt;br&gt;
Description = SendingFacility of the SDA Container.&lt;br&gt;&lt;br&gt;
SDATableName=HealthCareFacility, ViewerClass=User.HS.CTLoc&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIRecDepDR)&lt;br&gt;&lt;br&gt;
.Organization&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.CTLoc(CTLOCHospitalDR)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="VerifiedComments" type="s:string">
            <s:annotation>
                <s:documentation>Verified order comments and notes&lt;br&gt;
Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIAuthComments)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ResultCopiesTo" type="ArrayOfCareProvider">
            <s:annotation>
                <s:documentation>Who to send copies of results to&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-28 is a repeating field, and HL7ToSDA3 will parse each instance with a&lt;br&gt;
non-null value in subfield 1.&lt;br&gt;&lt;br&gt;
HL7:  OBR-28  : ResultCopiesTo&lt;br&gt;
SDATableName=CareProvider, ViewerClass=User.HS.CTCareProv&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-28.1 : ResultCopiesTo.Code&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  OBR-28.2.1 : ResultCopiesTo.FamilyName.Surname&lt;br&gt;
HL7:  OBR-28.3 : ResultCopiesTo.GivenName&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-28.9 : ResultCopiesTo.AssigningAuthority&lt;br&gt;
.Name.FamilyName&lt;br&gt;
HL7:  OBR-28.2.1 : ResultCopiesTo.FamilyName.Surname&lt;br&gt;
.Name.GivenName&lt;br&gt;
HL7:  OBR-28.3 : ResultCopiesTo.GivenName&lt;br&gt;
.Name.NamePrefix&lt;br&gt;
HL7:  OBR-28.6 : ResultCopiesTo.Prefix&lt;br&gt;
.Name.NameSuffix&lt;br&gt;
HL7:  OBR-28.7 : ResultCopiesTo.Degree&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupId" type="s:string">
            <s:annotation>
                <s:documentation>If this item was ordered as part of a group, this is the identifier of that&lt;br&gt;
group. The SDA2-to-SDA3 transform populates this field with the SDA2&lt;br&gt;
ExternalId property.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.1 : PlacerGroupNumber.EntityIdentifier&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORILab1)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GroupAssigningAuthority" type="s:string">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
GroupAssigningAuthority is composed of subfields 2, 3, and 4 concatenated&lt;br&gt;
together as "[.2]^[.3]^[.4]", but only if at least one of these is not&lt;br&gt;
null.&lt;br&gt;&lt;br&gt;
HL7:  ORC-4.2: PlacerGroupNumber.NamespaceID&lt;br&gt;
HL7:  ORC-4.3: PlacerGroupNumber.UniversalID&lt;br&gt;
HL7:  ORC-4.4: PlacerGroupNumber.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Supported values:&lt;br&gt;
D = Delete&lt;br&gt;
I = Inactivate all orders of this type (set Status="I")&lt;br&gt;
C = Clear/delete all orders of this type&lt;br&gt;
R = Replace - Applies only to Atomic Result Items.  Clears previous result items before storing all new items,
ignoring matching on test item code.  &lt;b&gt;Use ONLY when always receiving full updates.  Using this with
partial updates may cause a loss of test item data.&lt;/b&gt;&lt;br&gt;
Any other value = Add or Update&lt;br&gt;
See the annotation of the superclass property for more information on how&lt;br&gt;
ActionCode is used.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
Two double quotes ("") in ORC-1 will be parsed as ActionCode="I", while&lt;br&gt;
four double quotes ("""") will be parsed as ActionCode="C". &lt;br&gt;
ActionCode="R" in ORC-1 will impact parsing of TestItemCode.  See the
TestItemCode property of HS.SDA3.LabResultItem for details.&lt;br&gt;
Any other value will not be parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-1 : OrderControl&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Only used for Medications, see the annotation in HS.SDA3.Medication.&lt;br&gt;
Otherwise ActionScope is not used for Orders.&lt;br&gt;&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-10 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed.&lt;br&gt;&lt;br&gt;
HL7:  ORC-10 : EnteredBy&lt;br&gt;
SDATableName=User, ViewerClass=User.HS.SSUser&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserUpdate)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  ORC-10.1 : EnteredBy.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRInitials)&lt;br&gt;
.Description&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
The family and given names are concatenated together as "[Family], [Given]"&lt;br&gt;
to make the Description.&lt;br&gt;
HL7:  ORC-10.2.1 : EnteredBy.FamilyName.Surname&lt;br&gt;
HL7:  ORC-10.3 : EnteredBy.GivenName&lt;br&gt;
VIEWERLIB: User.HS.SSUser(SSUSRName)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-10.9 : EnteredBy.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>HL7ToSDA3:&lt;br&gt;
Though ORC-21 is a repeating field, only the first non-null instance is&lt;br&gt;
parsed. ORC-22 is also a repeating field, however HL7ToSDA3 will only parse&lt;br&gt;
the instance corresponding to the instance of ORC-21 parsed. For example,&lt;br&gt;
if the third instance of ORC-21 is parsed (because the first two are null),&lt;br&gt;
then the third instance of ORC-22 will be parsed as well. For Address.City,&lt;br&gt;
State, Zip, Country, and County only the Code is parsed. HL7ToSDA3 does not&lt;br&gt;
set the Description. Every instance of ORC-23 will be examined but may not&lt;br&gt;
be parsed to the SDA. The algorithm to parse a number out of one instance&lt;br&gt;
of ORC-23 is:&lt;br&gt;
-If subfields 5, 6, 7, and 8 are not all null, compose the number out of&lt;br&gt;
them as "+[.5] ([.6]) [.7] x[.8]".&lt;br&gt;
-Else if subfield 12 is not null, use that.&lt;br&gt;
-Else if subfield 1 is not null, use that.&lt;br&gt;
-Else no number can be parsed from this instance.&lt;br&gt;
-Whichever number is parsed, if subfield 9 of that instance is not null, it&lt;br&gt;
will be appended to the number, delimited by a semicolon.&lt;br&gt;
Ex: "###-###-####;Main Number"&lt;br&gt;&lt;br&gt;
HL7:  ORC-21 : OrderingFacilityName&lt;br&gt;
HL7:  ORC-22 : OrderingFacilityAddress&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
SDATableName=Organization, ViewerClass=User.HS.CTHospital&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUserAddHospDR)&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ORC-21.10 will be parsed to the Code if present, else ORC-21.3 will.&lt;br&gt;
HL7:  ORC-21.10 : OrderingFacilityName.OrganizationIdentifier&lt;br&gt;
HL7:  ORC-21.3 : OrderingFacilityName.IDNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCode)&lt;br&gt;
.Description&lt;br&gt;
HL7:  ORC-21.1 : OrderingFacilityName.OrganizationName&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPDesc)&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  ORC-21.6 : OrderingFacilityName.AssigningAuthority&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.Address.Street&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If ORC-22.2 is not null, Street will be parsed as "[.1.1]; [.2]". Otherwise&lt;br&gt;
Street will simply be parsed from ORC-22.1.1.&lt;br&gt;
HL7:  ORC-22.1.1 : OrderingFacilityAddress.StreetAddress.StreetorMailingAddress&lt;br&gt;
HL7:  ORC-22.2 : OrderingFacilityAddress.OtherDesignation&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPAddress)&lt;br&gt;
.Address.City&lt;br&gt;
HL7:  ORC-22.3 : OrderingFacilityAddress.City&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCity)&lt;br&gt;
.Address.State&lt;br&gt;
HL7:  ORC-22.4 : OrderingFacilityAddress.StateorProvince&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPProvinceDR)&lt;br&gt;
.Address.Zip&lt;br&gt;
HL7:  ORC-22.5 : OrderingFacilityAddress.ZiporPostalCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPZipDR)&lt;br&gt;
.Address.Country&lt;br&gt;
HL7:  ORC-22.6 : OrderingFacilityAddress.Country&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountryDR)&lt;br&gt;
.Address.County&lt;br&gt;
HL7:  ORC-22.9 : OrderingFacilityAddress.CountyParishCode&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPCountyParishDR)&lt;br&gt;
.ContactInfo.WorkPhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
WorkPhoneNumber is parsed from the first instance of ORC-23 with subfield 2&lt;br&gt;
in ["",WPN,ASN,EMR] and subfield 3 in ["",PH] and from which a phone number&lt;br&gt;
can be parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPPhone)&lt;br&gt;
.ContactInfo.MobilePhoneNumber&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
MobilePhoneNumber is parsed from the first instance of ORC-23 with subfield&lt;br&gt;
2 = "BPN" and subfield 3 in [CP,BP] and from which a phone number can be&lt;br&gt;
parsed using the above algorithm.&lt;br&gt;
HL7:  ORC-23 : OrderingFacilityPhoneNumber&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;
.ContactInfo.EmailAddress&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
EmailAddress is parsed from the first non-null instance of ORC-23.4.&lt;br&gt;
HL7:  ORC-23.4 : OrderingFacilityPhoneNumber.EmailAddress&lt;br&gt;
VIEWERLIB: User.HS.CTHospital(HOSPEmail)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. For Orders than can have&lt;br&gt;
Results (LabOrder, RadOrder, OtherOrder), if the Order actually has a&lt;br&gt;
Result and FromTime, EnteredOn, and Result.ResultTime are all null, an&lt;br&gt;
error will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
HL7:  ORC-9.1 : DateTimeofTransaction.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIUpdateDate) + User.HS.OEOrdItem(OEORIUpdateTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>Start date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
FromTime is parsed from (in order of precedence) TQ1-7.1, RXE-1.4,&lt;br&gt;
OBR-27.4, OBR-6.1, or ORC-7.4. Though ORC-7 is a repeating field, HL7ToSDA3&lt;br&gt;
only parses the first non-null instance. OBR-27 is also a repeating field,&lt;br&gt;
and HL7ToSDA3 parses every non-null instance of it. The last non-null&lt;br&gt;
instance of StartDateTime.Time in OBR-27 is the one that takes precedence.&lt;br&gt;
Note that an RDE_O11 message may contain TQ1 segments in two different&lt;br&gt;
places. HL7ToSDA3 parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For each type of Order, in the OnValidate method of the Streamlet class, if&lt;br&gt;
FromTime is null, it is defaulted to EnteredOn. Then, if the Order has a&lt;br&gt;
Result and FromTime is still null, it is defaulted to Result.ResultTime.&lt;br&gt;
Finally, if the Order has a Result and FromTime is still null, an error&lt;br&gt;
will be logged and the Order will not be saved.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a FromTime, then that FromTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  OBR-6.1 : RequestedDateTime.Time&lt;br&gt;
HL7:  OBR-27.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  RXE-1.4.1 : QuantityTiming.StartDateTime.Time&lt;br&gt;
HL7:  TQ1-7.1 : StartDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORISttDat) + User.HS.OEOrdItem(OEORISttTim)&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>End date and time of the Order&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
ToTime is parsed from (in order of precedence) TQ1-8, RXE-1.5, OBR-27.5,&lt;br&gt;
or ORC-7.5. Though ORC-7 is a repeating field, HL7ToSDA3 only parses the&lt;br&gt;
first non-null instance. OBR-27 is also a repeating field, and HL7ToSDA3&lt;br&gt;
parses every non-null instance of it. The last non-null instance of&lt;br&gt;
EndDateTime.Time in OBR-27 is the one that takes precedence. Note that an&lt;br&gt;
RDE_O11 message may contain TQ1 segments in two different places. HL7ToSDA3&lt;br&gt;
parses the one following the RXE segment.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If the Order contains at least 1 DosageStep in the DosageSteps property,&lt;br&gt;
and if the first DosageStep in that list has a ToTime, then that ToTime&lt;br&gt;
will override this one in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  ORC-7.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  OBR-27.5.1 : QuantityTiming.EndDateTime.Time&lt;br&gt;
HL7:  RXE-1.5.1 : QuantityTiming.EndDateTimeTime&lt;br&gt;
HL7:  TQ1-8.1   : EndDateTime.Time&lt;br&gt;
VIEWERLIB: User.HS.OEOrdItem(OEORIEndDate) + User.HS.OEOrdItem(OEORIEndTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Result" type="Result">
            <s:annotation>
                <s:documentation>VIEWERLIB: see HS.SDA3.Result&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Specimens" type="ArrayOfSpecimen">
            <s:annotation>
                <s:documentation>HL7:  SPM&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ClinicalInformation" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-13 : ReleventClinicalInformation&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservation" type="LabTestItem">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is a copy of the parent observation (as a LabTestItem). For&lt;br&gt;
example, the parent observation could be a bacterial culture identified in&lt;br&gt;
a specimen taken from the patient, and this order would contain the&lt;br&gt;
antibiotic susceptibilities of that culture.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentResultObservation itself is not&lt;br&gt;
stored in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-26.1 : ParentResult.ParentObservationIdentifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-26.1.1 : ParentResult.ParentObservationIdentifier.Text&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-26.1.2 : ParentResult.ParentObservationIdentifier.Identifier&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-26.1.3 : ParentResult.ParentObservationIdentifier.NameofCodingSystem&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, and 6 will be parsed&lt;br&gt;
into the Code, Description, and CodeSystem, respectively, of a PriorCode in&lt;br&gt;
the list of PriorCodes.&lt;br&gt;
HL7:  OBR-26.1.4 : ParentResult.ParentObservationIdentifier.AlternateText&lt;br&gt;
HL7:  OBR-26.1.5 : ParentResult.ParentObservationIdentifier.AlternateIdentifier&lt;br&gt;
HL7:  OBR-26.1.6 : ParentResult.ParentObservationIdentifier.NameofAlternateCodingSystem&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservationSubId">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is the SubId of the parent observation.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentResultObservationSubId itself is not&lt;br&gt;
stored in the Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-26.2 : ParentResult.ParentObservationSubidentifier&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="30"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ParentResultObservationText" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-26.3 : ParentResultObservationText&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentPlacerId" type="s:string">
            <s:annotation>
                <s:documentation>HL7:  OBR-29.1.1 : Parent.PlacerAssignedIdentifier.EntityIdentifier&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentPlacerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the Parent ID is assigned to the order when it was placed&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-29.1 will be used if a value can be parsed from it.&lt;br&gt;
ParentPlacerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.1.2 : Parent.PlacerAssignedIdentifier.NamespaceID&lt;br&gt;
HL7:  OBR-29.1.3 : Parent.PlacerAssignedIdentifier.UniversalID&lt;br&gt;
HL7:  OBR-29.1.4 : Parent.PlacerAssignedIdentifier.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ParentFillerId" type="s:string">
            <s:annotation>
                <s:documentation>If the Result in this Order is the child of an observation in another&lt;br&gt;
Order, this is the FillerId of the parent observation.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For Orders with atomic Results only, if the ParentFillerId,&lt;br&gt;
ParentResultObservation.Code, and ParentResultObservationSubId are all&lt;br&gt;
non-null and identify a lab.HS.EPVisitTestSetData (LabResultItem) already&lt;br&gt;
in the Viewer Cache, that EPVisitTestSetData will be copied into the&lt;br&gt;
current EPVisitTestSet (Result). ParentFillerId itself is not stored in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.2.1 : Parent.FillerAssignedIdentifier.EntityIdentifier&lt;br&gt;
Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ParentFillerAssigningAuthority">
            <s:annotation>
                <s:documentation>The namespace from which the Parent ID was assigned to the order when it was&lt;br&gt;
filled&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
OBR-29.2 will be used if a value can be parsed from it.&lt;br&gt;
ParentFillerAssigningAuthority is composed of subfields 2,&lt;br&gt;
3, and 4 concatenated together as "[.2]^[.3]^[.4]", but only if at least&lt;br&gt;
one of these is not null.&lt;br&gt;&lt;br&gt;
HL7:  OBR-29.2.2 : Parent.FillerAssignedIdentifier.NamespaceID&lt;br&gt;
HL7:  OBR-29.2.3 : Parent.FillerAssignedIdentifier.UniversalID&lt;br&gt;
HL7:  OBR-29.2.4 : Parent.FillerAssignedIdentifier.UniversalIDType&lt;br&gt;
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="ReasonForStudy" type="ReasonforStudy">
            <s:annotation>
                <s:documentation>HL7:  OBR-31 : ReasonforStudy&lt;br&gt;
VIEWERLIB: Not stored&lt;br&gt;&lt;br&gt;
.Code&lt;br&gt;
HL7:  OBR-31.1 : ReasonforStudy.Identifier&lt;br&gt;
.Description&lt;br&gt;
HL7:  OBR-31.2 : ReasonforStudy.Text&lt;br&gt;
.SDACodingStandard&lt;br&gt;
HL7:  OBR-31.3 : ReasonforStudy.NameofCodingSystem&lt;br&gt;
.CodeSystemVersionId&lt;br&gt;
HL7:  OBR-31.7 : ReasonforStudy.CodingSystemVersionID&lt;br&gt;
.PriorCodes&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If subfield 4 or 5 is not null, then subfields 4, 5, 6, and 8 will be&lt;br&gt;
parsed into the Code, Description, CodeSystem, and CodeSystemVersionId,&lt;br&gt;
respectively, of a PriorCode in the list of PriorCodes.&lt;br&gt;
HL7:  OBR-31.4 : ReasonforStudy.AlternateIdentifier&lt;br&gt;
HL7:  OBR-31.5 : ReasonforStudy.AlternateText&lt;br&gt;
HL7:  OBR-31.6 : ReasonforStudy.NameofAlternateCodingSystem&lt;br&gt;
HL7:  OBR-31.8 : ReasonforStudy.AlternateCodingSystemVersionID&lt;br&gt;</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>This optional property is only utilized as a tie-breaker when aggregating&lt;br&gt;
at the Access Gateway. The system will only populate it for Encounter-less&lt;br&gt;
data, and only if no EnteredOn is supplied.  Data sources may populate&lt;br&gt;
this if they have no EnteredOn, or if EnteredOn is used to represent&lt;br&gt;
something other than how recent this record is. For Encounter-less data, if&lt;br&gt;
there are two records from different sources, we first use the facility&lt;br&gt;
tier, and if the same, we use the "most recent" record, as determined by&lt;br&gt;
this, or EnteredOn if this isn't populated.&lt;br&gt;
In addition to the above, we also populate this property when we process&lt;br&gt;
inbound SDA with an ActionCode="I" - a mass inactivate.  This is to allow&lt;br&gt;
for some poorly behaved systems that are not able to tell us that something&lt;br&gt;
(like a medication) has been discontinued - instead, they send in data&lt;br&gt;
which only contains new meds, and custom pipeline code detects this and&lt;br&gt;
inserts a mass inactivate first.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Identifier used by systems outside HealthShare.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
If present on any SDA object corresponding to a streamlet type, ExternalId&lt;br&gt;
will be the only property used for matching (besides EncounterNumber and&lt;br&gt;
aggregation key, which are always used). For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and ExternalId but&lt;br&gt;
different Allergy.Code values, they will still be considered a match. A&lt;br&gt;
null ExternalId will not match a non-null ExternalId. For example, if two&lt;br&gt;
HS.SDA3.Allergy objects have the same EncounterNumber and Allergy.Code, but&lt;br&gt;
one has an ExternalId and one does not, they will not match. Matching on&lt;br&gt;
ExternalId is SQLUPPER collated.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>A string that uniquely identifies an Encounter within a patient record.&lt;br&gt;
In cases where HS attempts to generate an EncounterNumber, the logic is:&lt;br&gt;
-If EncounterType is "G" or "S", generate EncounterNumber as "HSgenerated"&lt;br&gt;
followed by an incremental number.&lt;br&gt;
-Else if Patient MRN and Encounter FromTime are not null, generate&lt;br&gt;
EncounterNumber as "[MRN]-[FromTime date]".&lt;br&gt;
-Else no EncounterNumber can be generated.&lt;br&gt;&lt;br&gt;
HL7ToSDA3:&lt;br&gt;
If PV1-19.1 is null, HealthShare attempts to generate an EncounterNumber&lt;br&gt;
using the above logic. If one cannot be generated, no Encounter is parsed&lt;br&gt;
to the SDA and all the data parsed from the HL7 is Encounter-less. If one&lt;br&gt;
can be parsed or generated, then Diagnoses, Observations, Orders,&lt;br&gt;
Procedures, Problems, Appointments, and Documents, in addition to&lt;br&gt;
Encounter, will be parsed with EncounterNumber.&lt;br&gt;&lt;br&gt;
Streamlet cache:&lt;br&gt;
For Encounters, this is the only match property (besides AggregationKey).&lt;br&gt;
See HS.SDA3.Encounter for more info on special processing of&lt;br&gt;
EncounterNumber for that type. For Patient and classes that do not&lt;br&gt;
correspond to streamlet types, EncounterNumber is not used. For classes&lt;br&gt;
that do correspond to streamlet types, EncounterNumber is optionally used&lt;br&gt;
to link an SDA object to an Encounter. Only objects linked to the same&lt;br&gt;
Encounter can match, and Encounter-less data can only match Encounter-less&lt;br&gt;
data. If an inbound SDA object contains an EncounterNumber for which no&lt;br&gt;
Encounter exists for that Patient, then an error will be logged and the&lt;br&gt;
streamlet will not be saved.&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
In the Viewer Cache, data is structured hierarchically. Some types are&lt;br&gt;
stored "under" an Encounter, while others are not. If an SDA object has no&lt;br&gt;
EncounterNumber but is Encounter-level in the Viewer Cache, then it will be&lt;br&gt;
inserted into the Patient's silent Encounter in the Viewer Cache only. If&lt;br&gt;
the Patient has no silent Encounter, one will be created in the Viewer&lt;br&gt;
Cache only. If an SDA object is linked to an Encounter but is not&lt;br&gt;
Encounter-level in the Viewer Cache, then that link is simply not reflected&lt;br&gt;
in the Viewer Cache, except for Allergy and Illness History. Though not&lt;br&gt;
Encounter-level, these types do have fields for EncounterNumber in the&lt;br&gt;
Viewer Cache.&lt;br&gt;&lt;br&gt;
HL7:  PV1-19.1 : VisitNumber.IDNumber</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="GenomicsOrderExtension"/>
        <s:element minOccurs="0" name="VCFStreams" type="ArrayOfBlob">
            <s:annotation>
                <s:documentation>A stream of VCF data - this can be very large
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Variants" type="ArrayOfGenomicsVariant">
            <s:annotation>
                <s:documentation>A filtered list of the clinically significant variant data parsed from the VCF streams
We filter by "report,true" in the key value pairs stored in column 8 (INFO)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="LinkedFillerID">
            <s:annotation>
                <s:documentation>Many genomics orders are associated with a lab order.  If so, this will
contain the filler ID of that lab order
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="GenomicsOrderExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfBlob">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Blob" nillable="true" type="Blob"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Blob">
    <s:annotation>
        <s:documentation>Used to hold very long objects in the SDA</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="HSBlobStream" type="s:base64Binary">
                    <s:annotation>
                        <s:documentation>The blob stream is not actually stored in the streamlet's SDA string.  It is stored either
in a file, or in ^HS.SDA3.Blob.  This allows long data to be used without exceeding the 3MB
limit on total streamlet size.  When the streamlet is exported to a container, the HSBlobStream
does get included inline</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="HSBlobId" type="s:long">
                    <s:annotation>
                        <s:documentation>Used internally - a pointer to the blob contents when stored in the database.
When stored in the streamlet database, we'll use a tag of $C(4) instead of the "HSBlobId"
to allow easy parsing of the SDA string, to allow it to insert the blob stream contents
from the place where it is stored.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="FileType" type="s:string">
                    <s:annotation>
                        <s:documentation>If the blob can be stored as a file, this will be the extension</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ActionCode" type="s:string">
                    <s:annotation>
                        <s:documentation>Not stored
May be input as "D" as a delete instruction
Internally, we may temporarily set it to U to indicate that we're in the process of updating it</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="LoadFromFile">
                    <s:annotation>
                        <s:documentation>Not Stored
Used only on the original SDA input, to allow the contents of the HSBlobStream
to be loaded from an external file, instead of being input.
If used, this should be a fully qualified file reference, and HSBlobStream
should not be populated.
If supplied, the value of this property will be copied into OriginalFileReference.</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="200"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
                <s:element minOccurs="0" name="OriginalFileReference">
                    <s:annotation>
                        <s:documentation>For informational purposes, this will store whatever was input in LoadFromFile</s:documentation>
                    </s:annotation>
                    <s:simpleType>
                        <s:restriction base="s:string">
                            <s:maxLength value="200"/>
                        </s:restriction>
                    </s:simpleType>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfGenomicsVariant">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="GenomicsVariant" nillable="true" type="GenomicsVariant"/>
    </s:sequence>
</s:complexType>
<s:complexType name="GenomicsVariant">
    <s:annotation>
        <s:documentation>One line of a VCF file.  When we store SDA, we only extract the small subset of variants
that are clinically significant.  The properties are taken from the VCF spec (columns 1-6)</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="DataType">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="GenomicsVariantExtension"/>
                <s:element minOccurs="0" name="CHROM" type="s:string">
                    <s:annotation>
                        <s:documentation>Chromosome: An identifier from the reference genome or an angle-bracketed ID String (&lt;ID&gt;")
pointing to a contig in the assembly file.  No colons or white space permitted</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="POS" type="Numeric">
                    <s:annotation>
                        <s:documentation>Position: The reference position, with the 1st base having position 1.  It is permitted to have
multiple records with the same POS.  Telomeres are indicated by using positions 0 or N+1, where N
is the lenght of the corresponding chromosome or contig</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ID" type="s:string">
                    <s:annotation>
                        <s:documentation>ID - identifier: Semi-colon separated list of unique identifiers where available.  If this is a
dbSNP (single nucleotide pair) variant it is encouraged to use the rs number(s).  No identifier should
be present in more than one data record.
TBD: We think these comments mean that CHROM+POS+ID is like a primary key for the row</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="REF" type="s:string">
                    <s:annotation>
                        <s:documentation>Reference base(s): Each base must be one of A,C,G,T,N (case insensitive).  Multiple bases are permitted.
The value in the POS field refers to the position of the first base in the String.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="ALT" type="s:string">
                    <s:annotation>
                        <s:documentation>Alternate base(s): Comma separated list of alternate non-reference alleles called on at least one of the
samples.  Options are base strings made up of the bases A,C,G,T,N,* (case insensitive) or an angle-bracketed
ID string ("&lt;ID&gt;") or a breakend replacement string.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="QUAL" type="Numeric">
                    <s:annotation>
                        <s:documentation>Quality: Phred-scaled quality score for the assertion made in ALT. i.e. - -10Log10 prob(call in ALT is wrong)</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="GenomicsVariantExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfCarePlan">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="CarePlan" nillable="true" type="CarePlan"/>
    </s:sequence>
</s:complexType>
<s:complexType name="CarePlan">
    <s:sequence>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="CarePlanExtension">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Type" type="CarePlanType">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SubType" type="CarePlanSubType">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Providers" type="ArrayOfDocumentProvider">
            <s:annotation>
                <s:documentation>The list of individual care providers (along with roles and dates) associated with a care plan
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SupportContacts" type="ArrayOfSupportContact">
            <s:annotation>
                <s:documentation>The list of individual support contacts (along with roles and dates) associated with a care plan
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Authors" type="ArrayOfDocumentProvider">
            <s:annotation>
                <s:documentation>The authors of a care plan
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Organizations" type="ArrayOfDocumentOrganization">
            <s:annotation>
                <s:documentation>The list of organizations (along with roles and dates) associated with a care plan
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SetId" type="s:string">
            <s:annotation>
                <s:documentation>The published care plan set id, taken from CCDA /ClinicalDocument/SetId
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Version" type="s:string">
            <s:annotation>
                <s:documentation>The published care plan version, taken from the document metadata %VersionNumber
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Status" type="s:string">
            <s:annotation>
                <s:documentation>Currently, possible values are: "A" - Active, "I" - Inactive
Derived from the document %IsActive property
VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="HealthConcernIds" type="ArrayOfHealthConcernIdsItemString">
            <s:annotation>
                <s:documentation>ExternalIds of Health Concerns in this care plan</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="GoalIds" type="ArrayOfGoalIdsItemString">
            <s:annotation>
                <s:documentation>ExternalIds of Goals in this care plan</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Interventions" type="ArrayOfIntervention">
            <s:annotation>
                <s:documentation>Interventions in this care plan</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Outcomes" type="ArrayOfOutcome">
            <s:annotation>
                <s:documentation>Outcomes in this care plan</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CreatedBy" type="User">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CreatedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Used for the care plan identifier</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="CarePlanExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="CarePlanType">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="CarePlanTypeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="CarePlanTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="CarePlanSubType">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="CarePlanSubTypeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="CarePlanSubTypeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfHealthConcernIdsItemString">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="HealthConcernIdsItem" nillable="true" type="s:string"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfGoalIdsItemString">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="GoalIdsItem" nillable="true" type="s:string"/>
    </s:sequence>
</s:complexType>
<s:complexType name="ArrayOfIntervention">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Intervention" nillable="true" type="Intervention"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Intervention">
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="InterventionExtension"/>
                <s:element minOccurs="0" name="Description" type="s:string">
                    <s:annotation>
                        <s:documentation>Textual description of an intervention</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Status" type="s:string">
                    <s:annotation>
                        <s:documentation>Intervention status. Used to represent planned (active) vs completed.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Performers" type="ArrayOfDocumentProvider">
                    <s:annotation>
                        <s:documentation>Performers for the intervention</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="GoalIds" type="ArrayOfGoalIdsItemString">
                    <s:annotation>
                        <s:documentation>ExternalId of Goal that is addressed by this intervention</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="InterventionExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfOutcome">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Outcome" nillable="true" type="Outcome"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Outcome">
    <s:annotation>
        <s:documentation>An outcome of a care plan activity</s:documentation>
    </s:annotation>
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="OutcomeExtension"/>
                <s:element minOccurs="0" name="Description" type="s:string">
                    <s:annotation>
                        <s:documentation>Textual description of an outcome observation</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Observation" type="Observation">
                    <s:annotation>
                        <s:documentation>The coded form of this outcome, including &lt;br&gt;&lt;br&gt;
-Standard medical code for this outcome, if applicable.&lt;br&gt;
- If applicable, desired outcome expressed in terms of unit, amount etc. An observation record may be used in capturing this info. (e.g., HbA1C "&lt; 6.5") or a range ("5 - 10"), behaves like ResultNormalRange field of LabResultItem
- Unit for desired outcome&lt;br&gt;</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="InterventionId" type="s:string">
                    <s:annotation>
                        <s:documentation>ExternalId of Intervention which this is an outcome of.</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="OutcomeExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfHealthConcern">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="HealthConcern" nillable="true" type="HealthConcern"/>
    </s:sequence>
</s:complexType>
<s:complexType name="HealthConcern">
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="HealthConcernExtension"/>
                <s:element minOccurs="0" name="Description" type="s:string">
                    <s:annotation>
                        <s:documentation>Textual description of a health concern.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Status" type="HealthConcernStatus">
                    <s:annotation>
                        <s:documentation>Health concern status (coded in CCDA).</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Priority" type="Priority">
                    <s:annotation>
                        <s:documentation>Priority of health concern</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Authors" type="ArrayOfDocumentProvider">
                    <s:annotation>
                        <s:documentation>Who is expressing this concern. May be Patient, Practitioner, Related Person or Organization.</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="HealthConcernExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="HealthConcernStatus">
    <s:complexContent>
        <s:extension base="CodeTableDetail">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="HealthConcernStatusExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="HealthConcernStatusExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfGoal">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="Goal" nillable="true" type="Goal"/>
    </s:sequence>
</s:complexType>
<s:complexType name="Goal">
    <s:complexContent>
        <s:extension base="SuperClass">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="GoalExtension"/>
                <s:element minOccurs="0" name="Description" type="s:string">
                    <s:annotation>
                        <s:documentation>Textual description of a goal.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Target" type="Observation">
                    <s:annotation>
                        <s:documentation>The aim of this goal in coded form, including:&lt;br&gt;
- Standard medical code for this goal, if applicable.e.g., SNOMED-CT, NIC, NOC, NANDA&lt;br&gt;
- If applicable, desired outcome expressed in terms of unit, amount etc. An observation record may be used in capturing this info. (e.g., HbA1C "&lt; 6.5") or a range ("5 - 10"), behaves like ResultNormalRange field of LabResultItem&lt;br&gt;
- Unit for desired outcome</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="TargetCode" type="ObservationCode">
                    <s:annotation>
                        <s:documentation>TargetCode is only used for streamlet matching.
Any values set here will be overwritten with Target.ObservationCode by HS.SDA3.Streamlet.Goal OnBeforeMatch.</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Status" type="GoalStatus">
                    <s:annotation>
                        <s:documentation>Goal status (coded in CCDA as Progress towards Goal Observation)</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Priority" type="Priority">
                    <s:annotation>
                        <s:documentation>Goal priority</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="Authors" type="ArrayOfDocumentProvider">
                    <s:annotation>
                        <s:documentation>Authors of the goal</s:documentation>
                    </s:annotation>
                </s:element>
                <s:element minOccurs="0" name="HealthConcernIds" type="ArrayOfHealthConcernIdsItemString">
                    <s:annotation>
                        <s:documentation>ExternalIds of health concerns that this goal addresses</s:documentation>
                    </s:annotation>
                </s:element>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="GoalExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="GoalStatus">
    <s:complexContent>
        <s:extension base="CodeTableDetail">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="GoalExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfSocialDeterminant">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="SocialDeterminant" nillable="true" type="SocialDeterminant"/>
    </s:sequence>
</s:complexType>
<s:complexType name="SocialDeterminant">
    <s:sequence>
        <s:element minOccurs="0" name="CustomPairs" type="ArrayOfNVPair">
            <s:annotation>
                <s:documentation>The generic container to hold all sorts of data about this object&lt;br&gt;&lt;br&gt;
Viewer cache:&lt;br&gt;
For every SDA3 type corresponding to a streamlet type except CustomObject,&lt;br&gt;
the CustomPairs are inserted into the Viewer Cache as web.SDA3.NVPairs. In&lt;br&gt;
addition to the Name and Value, web.SDA3.NVPair also stores the aggregation&lt;br&gt;
key of the patient record, the info type of the containing streamlet, and&lt;br&gt;
the ID of the corresponding object in the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair&lt;br&gt;&lt;br&gt;
.Name&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Name)&lt;br&gt;
.Value&lt;br&gt;
VIEWERLIB: web.SDA3.NVPair(Value)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Extension" type="SocialDeterminantExtension"/>
        <s:element minOccurs="0" name="Status">
            <s:annotation>
                <s:documentation>Streamlet cache:&lt;br&gt;
In the OnInactivate method of the Streamlet class, if the Status is not&lt;br&gt;
already "I", it is set to "I".&lt;br&gt;
In the OnValidate method, if the Status is null, it is defaulted to "A" for&lt;br&gt;
"Active".&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QStatus)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="50"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="Comments" type="s:string">
            <s:annotation>
                <s:documentation>Length subject to the total streamlet size limit - 3,000,000&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QComments)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="Warning" type="Boolean">
            <s:annotation>
                <s:documentation>Upstream system or inbound interface chooses to flag specific values as needing special attention&lt;br&gt;
In Clinical Viewer, will highlight row as red and display text indicating warning state.&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
The value that is inserted into the Viewer Cache and ultimately displayed&lt;br&gt;
to the user is the Description of one of the "YESNO" standard type items in&lt;br&gt;
Trak, which can be configured. If Warning=1 the Description of the "Y" item&lt;br&gt;
will be shown, and if Warning=0 the Description of the "N" value will be&lt;br&gt;
shown. If Warning="", an empty string ("") will be inserted and shown.&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QWarning)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SocialDeterminantCode" type="SocialDeterminantCode">
            <s:annotation>
                <s:documentation>Social Determinant Code&lt;br&gt;
Ex. "Access to public transportation"&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QDescription)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SocialDeterminantValueCoded" type="SocialDeterminantValueCode">
            <s:annotation>
                <s:documentation>The coded value associated with the social determinant.&lt;br&gt;
Social Determinant value could be coded, numeric or text.&lt;br&gt;
For properties SocialDeterminantValueCoded, SocialDeterminantValueNumeric and &lt;br&gt;
SocialDeterminantValueText, only one of them will be populated.&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QValue)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SocialDeterminantValueText">
            <s:annotation>
                <s:documentation>The text value associated with the social determinant&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QValue)</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="StrippedString">
                    <s:maxLength value="32000"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="SocialDeterminantValueNumeric" type="Numeric">
            <s:annotation>
                <s:documentation>The numeric value associated with the social determinant&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QValue)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="SocialDeterminantUnitOfMeasure" type="UoM">
            <s:annotation>
                <s:documentation>The unit of measure associated with Property SocialDeterminantValueNumeric&lt;br&gt;&lt;br&gt;
Viewer Cache:&lt;br&gt;
If SocialDeterminantValueNumeric is not null, then it is appended with this&lt;br&gt;
value (either the Description, or the Code if that is null) before being&lt;br&gt;
inserted into the Viewer Cache.&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QValue)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionCode" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ActionScope" type="s:string">
            <s:annotation>
                <s:documentation>Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredBy" type="User">
            <s:annotation>
                <s:documentation>The person who noted the observation.&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QUESUserDR)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredAt" type="Organization">
            <s:annotation>
                <s:documentation>The organization or system which created the record.&lt;br&gt;&lt;br&gt;
Viewer Cache:
EnteredAt is not inserted into the Viewer Cache as a code table entry but&lt;br&gt;
rather a string value, either the Description, or if that is null, the&lt;br&gt;
Code.&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QSOCIALDET(QEnteredAt)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="EnteredOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>The date when the value was recorded.&lt;br&gt;&lt;br&gt;
VIEWERLIB: questionnaire.QPROGRAMS(QUESDate) + questionnaire.QPROGRAMS(QUESTime)</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CreatedBy" type="User">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored.&lt;br&gt;
Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="CreatedTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored.&lt;br&gt;
Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="UpdatedOn" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored.&lt;br&gt;
Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="FromTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored.&lt;br&gt;
Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ToTime" type="TimeStamp">
            <s:annotation>
                <s:documentation>VIEWERLIB: Not stored.&lt;br&gt;
Not used.</s:documentation>
            </s:annotation>
        </s:element>
        <s:element minOccurs="0" name="ExternalId">
            <s:annotation>
                <s:documentation>Used for the social determinant identifier</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
        <s:element minOccurs="0" name="EncounterNumber">
            <s:annotation>
                <s:documentation>Default streamlet processing will utilize EncounterNumber for matching. &lt;br&gt;
It is strongly recommended that EncounterNumber is NOT populated for SocialDeterminant data.</s:documentation>
            </s:annotation>
            <s:simpleType>
                <s:restriction base="s:string">
                    <s:maxLength value="220"/>
                </s:restriction>
            </s:simpleType>
        </s:element>
    </s:sequence>
</s:complexType>
<s:complexType name="SocialDeterminantExtension">
    <s:complexContent>
        <s:extension base="DataType"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SocialDeterminantCode">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SocialDeterminantCodeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SocialDeterminantCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="SocialDeterminantValueCode">
    <s:complexContent>
        <s:extension base="CodeTableTranslated">
            <s:sequence>
                <s:element minOccurs="0" name="Extension" type="SocialDeterminantValueCodeExtension"/>
            </s:sequence>
        </s:extension>
    </s:complexContent>
</s:complexType>
<s:complexType name="SocialDeterminantValueCodeExtension">
    <s:complexContent>
        <s:extension base="CodeTableExtension"/>
    </s:complexContent>
</s:complexType>
<s:complexType name="ArrayOfAdditionalInfoItemPairOfAdditionalInfoKeyAdditionalInfoItem">
    <s:sequence>
        <s:element maxOccurs="unbounded" minOccurs="0" name="AdditionalInfoItem" nillable="true" type="PairOfAdditionalInfoKeyAdditionalInfoItem"/>
    </s:sequence>
</s:complexType>
<s:complexType name="PairOfAdditionalInfoKeyAdditionalInfoItem">
    <s:simpleContent>
        <s:extension base="AdditionalInfoItem">
            <s:attribute name="AdditionalInfoKey" type="s:string" use="required"/>
        </s:extension>
    </s:simpleContent>
</s:complexType>
<s:simpleType name="AdditionalInfoItem">
    <s:restriction base="s:string"/>
</s:simpleType>
</s:schema>